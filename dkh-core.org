#+TITLE: Damon Haley's Emacs 24 Configuration
#+OPTIONS: toc:2 num:nil ^:nil
#+CATEGORY: Emacs Init File
#+STARTUP: overview

#+begin_quote
“Men are only as good as their technical development allows them to be.”

George Orwell

Inside the Whale and other essays
#+end_quote

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

I've been using [[http://eschulte.me/emacs24-starter-kit/#installation][Emacs Starter Kit]] and the literate programming
features in [[http://orgmode.org/worg/org-contrib/babel/][org-babel]] for some time.

Partly inspired by [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file][Sacha Chua's 2012 blog post]], I finally decided to
make my config public to share.

** Installation
   :PROPERTIES:
   :CUSTOM_ID: installation
   :END:

1. Install Emacs version 24 or greater.  Use your package manager if
   you have one and it has an install candidate for Emacs 24,
   otherwise install it directly [[http://savannah.gnu.org/projects/emacs/][from source]], or Mac binaries may be
   downloaded from the /nightlies/ section of
   http://emacsformacosx.com/builds
2. Checkout a version of the starter kit using git -- if you're new to
   git checkout this [[http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html][git-tutorial]], also we'd highly recommend that you
   try out [[http://zagadka.vm.bytemark.co.uk/magit/magit.html][magit]] the Emacs mode for git interaction.

#+begin_src sh

git clone http://github.com/eschulte/emacs24-starter-kit.git .emacs.d

#+end_src

3. You can now start emacs and let the starter kit download it's required
packages from Marmalade.

4. While still in emacs 24, download the latest version of el-get devel:

Open up a scratch buffer and evaluate this lisp

#+begin_src emacs-lisp :tangle no

 (url-retrieve
   "https://raw.github.com/dimitri/el-get/master/el-get-install.el"
   (lambda (s) (let (el-get-master-branch) (goto-char (point-max))
   (eval-print-last-sexp))))

#+end_src 
   
It will take a minute or four for el-get to clone itself, but when this
process is no longer in a ps listing, then you can close down emacs.

When el-get is done,

You should see this message:

"Congrats, el-get is installed and ready to serve!"

5. Okily Dokily!, now Download E-WAX

#+begin_src sh

cd ~/.emacs.d git submodule add https://github.com/dhaley/ewax.git $USER

#+end_src 

6. Now, let's run the E-WAX install script.

#+begin_src sh

cd $USER ./install.sh

#+end_src 

This will take probably five to ten minutes while gnus and org-mode
download (and byte compile your .el into .elc).
    
When the script is finished, run emacs, which will download some stuff
with el-get.

You'll know el-get is done when you don't see any git clone action
going on in your process list.

#+begin_src sh

ps -ef | grep git


#+end_src


YOU'RE DONE!!!!!

HOPEFULLY!!!

♡(✿ˇ◡ˇ)人(ˇ◡ˇ✿)♡
    
** Starter Kit functionality that needs improvement:

One thing I don't like about starter kit is that if one has all the
blocks tanlged off or (no elisp blocks at all) the starter kit will
throw an error.

To prevent, that I always end my literate config files (in ~/emacs.d/$USER)
 with the following block just to be safe:

#+begin_src emacs-lisp :tangle no

(message (concat "0 " (buffer-name) "... Done"))
    
#+end_src
            
Also, I included a MAKEFILE in E-Wax to automatically delete .el files
generated from org-babel-tangle file. This is because as you change
your configs, the starter kit is not smart enough to regenerate your
files.

It just does this:

#+begin_src sh

LISP:
	rm -f *.el

#+end_src 

This assumes that you don't have any non-literate config files not
generated from org-mode based config files.
        
** E-WAX FUNCTIONALITY THAT NEEDS IMPROVEMENT ［ ］Pass［✔］Fail

E-Wax needs much more annotation.  A lot of documentation and comments
were stripped out when I made this project that should still be put
back in where relevant.

E-Wax Should probably take fuller advantage of autoloads, to more
dynamically only load parts of the confiuration as it is need. Right
now it's pretty monolithic (but good).

A lot of my important GNUS configuration is still in a private
gnus-init-file and needs to be moved into E-Wax.  It needs a lot of
annotation for it to make since to someone new to Gnus.

The PHP and Drupal fucntionality need to be reviewed.

More documentation both inside the code and in this file to come...
        
E-wax is written, stolen or maintained by Damon Haley
<dhaley@hushmail.com>
http://vinylisland.org
    
Remember: This is free software. Reuse and learning from existing code
is not just allowed but encouraged.

*** E-WAX Goals
**** Reduce Data Overload
***** Use Gnus virtual groups, scoring and kill threads to manage large volumes of email and RSS feeds
***** Use Org-mode to manage a hotlist of 10-20 items at a time
***** Use Org-mode hierarchies to hide and expand relevant items belonging to hot list
***** Use workflows that make sense
****** use magit home buffer for coding
******* use VC-mode
******** c x v = (vc-diff)






* Implementation
  :PROPERTIES:
  :CUSTOM_ID: implementation
  :END:

** Messages buffer
[2012-01-03 Tue 11:42]

The buffer called *Messages* is GnuEmacs’s error log, where all sorts
of useful information is printed, including information that appears
in the EchoArea (except for keystroke echoes). You can adjust the
number of messages kept in the buffer with the variable

#+begin_src emacs-lisp 

(setq message-log-max 1000)

#+end_src

*** initialization

#+begin_src emacs-lisp 


(require 'use-package)

#+end_src 


**** Utility macros and functions

#+begin_src emacs-lisp 

(defmacro hook-into-modes (func modes)
  `(dolist (mode-hook ,modes)
     (add-hook mode-hook ,func)))

(defun system-idle-time ()
  (with-temp-buffer
    (call-process "ioreg" nil (current-buffer) nil
                  "-c" "IOHIDSystem" "-d" "4" "-S")
    (goto-char (point-min))
    (and (re-search-forward "\"HIDIdleTime\" = \\([0-9]+\\)" nil t)
         (/ (float (string-to-number (match-string 1)))
            1000000000.0))))

(defun quickping (host)
  (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))


#+end_src 


**** Read system environment

#+begin_src emacs-lisp

(let ((plist (expand-file-name "~/.MacOSX/environment.plist")))
  (when (file-readable-p plist)
    (let ((dict (cdr (assq 'dict (cdar (xml-parse-file plist))))))
      (while dict
        (if (and (listp (car dict))
                 (eq 'key (caar dict)))
            (setenv (car (cddr (car dict)))
                    (car (cddr (car (cddr dict))))))
        (setq dict (cdr dict))))

    ;; Configure exec-path based on the new PATH
    (setq exec-path nil)
    (mapc (apply-partially #'add-to-list 'exec-path)
          (nreverse (split-string (getenv "PATH") ":")))))

#+end_src 
          
****  Load customization settings

#+begin_src emacs-lisp 
      
(defvar running-alternate-emacs nil)

(if (string= invocation-directory
             "/Applications/EmacsAlt.app/Contents/MacOS/")

    (let ((settings (with-temp-buffer
                      (insert-file-contents
                       (expand-file-name "settings.el" user-emacs-directory))
                      (goto-char (point-min))
                      (read (current-buffer)))))

      (setq running-alternate-emacs t
            user-data-directory
            (replace-regexp-in-string "/data/" "/data-alt/"
                                      user-data-directory))

      (let* ((regexp "/\\.emacs\\.d/data/")
             (replace "/.emacs.d/data-alt/"))
        (dolist (setting settings)
          (let ((value (and (listp setting)
                            (nth 1 (nth 1 setting)))))
            (if (and (stringp value)
                     (string-match regexp value))
                (setcar (nthcdr 1 (nth 1 setting))
                        (replace-regexp-in-string regexp replace value)))))

        (eval settings)))

  ;;(load (expand-file-name "settings" user-emacs-directory))
)

#+end_src   
     
*** Enable disabled commands

#+begin_src emacs-lisp 

(put 'downcase-region  'disabled nil)   ; Let downcasing work
(put 'erase-buffer     'disabled nil)
(put 'eval-expression  'disabled nil)   ; Let ESC-ESC work
(put 'narrow-to-page   'disabled nil)   ; Let narrowing work
(put 'narrow-to-region 'disabled nil)   ; Let narrowing work
(put 'set-goal-column  'disabled nil)
(put 'upcase-region    'disabled nil)   ; Let upcasing work

#+end_src 

** Pre-process

If there is anything you want to load before running E-Wax, then
annotate your elisp in the following file:

#+begin_src emacs-lisp 

(org-babel-load-file "~/git/.emacs.d/dkh-pre-setup.org")

#+end_src 

** Load Starter Kit packages

#+begin_src emacs-lisp 

(starter-kit-load "misc-recommended")

#+end_src 
** Verbose debug

#+begin_src emacs-lisp 

(message "emacs-init started ...")
(setq debug-on-error t)

#+end_src 

** Packages
*** El-Get

#+begin_src emacs-lisp 

;; added by dkh
(add-to-list 'load-path (concat user-emacs-directory "el-get/el-get"))

(setq load-path
      (append (list nil
                    )
              load-path))

(add-to-list 'load-path (expand-file-name "~/git/foss/org-mode/contrib/lisp"))

(add-to-list 'load-path (expand-file-name "~/git/src/gnus/lisp"))
   (require 'gnus-load)

;;(add-to-list 'load-path (expand-file-name "~/git/src/use-package"))


#+end_src 

**** Get stable branch

#+begin_src emacs-lisp :tangle no
(unless (require 'el-get nil t)
  (url-retrieve
   "https://github.com/dimitri/el-get/raw/master/el-get-install.el"
   (lambda (s)
     (end-of-buffer)
     (eval-print-last-sexp))))

#+end_src 

**** OR get devel branch

#+begin_src emacs-lisp

;; So the idea is that you copy/paste this code into your *scratch* buffer, ;; hit C-j, and you have a working developper edition of el-get.
 (url-retrieve
   "https://raw.github.com/dimitri/el-get/master/el-get-install.el"
   (lambda (s) (let (el-get-master-branch) (goto-char (point-max))
   (eval-print-last-sexp))))

#+end_src 


**** Sources and packages




#+begin_src emacs-lisp

(require 'el-get)

;; (setq
;;  el-get-sources
;;  '(
;;    (:name eproject :type git :url "https://github.com/jrockway/eproject.git" :features "eproject-extras")
;;    ))


;; now set our own packages
(setq
 my:el-get-packages
 '(
   auto-install
   autosmiley
   browse-kill-ring+
   dictem
   el-get ; el-get is self-hosting
   emacs-w3m
   emoticons
   erc-highlight-nicknames
   erc-nick-notify
   face-list
   fliptext
   gnus-alias
   gnus-harvest
   grep+
   ipa
   keychain-environment
   paste2
   protbuf
   psvn
   savehist-20+
   second-sel
   tail
   thing-cmds ;; for thing-region
   thingatpt-ext ;; for 'string
   ))


;; (when (el-get-executable-find "svn")
;;   (loop for p in '(psvn                 ; M-x svn-status
;;                    )
;;         do (add-to-list 'el-get-sources p)))


;; (setq my:el-get-packages
;;       (append
;;        my:el-get-packages
;;        (loop for src in el-get-sources collect (el-get-source-name src))))


(el-get 'sync my:el-get-packages)

#+end_src 


*** Install the packages I need if not already installed

#+begin_src emacs-lisp 

(defun rwd-require-package (name)
(or (package-installed-p name) (package-install name)))

(setq dkh-required-packages
      (list
        'ace-jump-mode
        'auctex
        'auto-indent-mode
        'bitlbee
        'bm
        'bookmark+
        'browse-kill-ring
        'buffer-move
        'color-theme
        'color-theme-solarized
        'etags-select
        'expand-region
        'fill-column-indicator
        'gist
        'guru-mode
        'js2-mode
        'key-chord
        'lorem-ipsum
        'magit
        'nav
        'oauth2
        'org2blog
        'org-mime
        'pastebin
        'rainbow-delimiters
        'rainbow-mode
        'rotate-text
        'sauron
        'session
        'smex
        'switch-window
        'synonyms
        'undo-tree
        'window-number
        'winpoint
        'workgroups
        'xml-rpc
        'yaml-mode
        'zencoding-mode
))

(package-refresh-contents)
(dolist (package dkh-required-packages) (when (not (package-installed-p package)) (package-install package)))

#+end_src 


** Recursive-edit-with-single-window

#+begin_src emacs-lisp :tangle no

;; inspired by Erik Naggum's `recursive-edit-with-single-window'
(defmacro recursive-edit-preserving-window-config (body)
  "*Return a command that enters a recursive edit after executing BODY.
 Upon exiting the recursive edit (with\\[exit-recursive-edit] (exit)
 or \\[abort-recursive-edit] (abort)), restore window configuration
 in current frame."
  `(lambda ()
     "See the documentation for `recursive-edit-preserving-window-config'."
     (interactive)
     (save-window-excursion
       ,body
       (recursive-edit))))

(bind-key "C-c 0"
  (recursive-edit-preserving-window-config (delete-window)))
(bind-key "C-c 1"
  (recursive-edit-preserving-window-config
   (if (one-window-p 'ignore-minibuffer)
       (error "Current window is the only window in its frame")
     (delete-other-windows))))

#+end_src 


#+begin_src emacs-lisp :tangle no

(eval-when-compile
  (defvar emacs-min-top)
  (defvar emacs-min-left)
  (defvar emacs-min-height)
  (defvar emacs-min-width))

(unless noninteractive
  (if running-alternate-emacs
      (progn
        (defvar emacs-min-top (if (= 1050 (x-display-pixel-height)) 389 537))
        (defvar emacs-min-left 9)
        (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 25 35))
        (defvar emacs-min-width 80))

    (defvar emacs-min-top 22)
    (defvar emacs-min-left (- (x-display-pixel-width) 918))
    (defvar emacs-min-height (if (= 1050 (x-display-pixel-height)) 55 64))
    (defvar emacs-min-width 100)))

(defun emacs-min ()
  (interactive)
  (set-frame-parameter (selected-frame) 'fullscreen nil)
  (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil)
  (set-frame-parameter (selected-frame) 'top emacs-min-top)
  (set-frame-parameter (selected-frame) 'left emacs-min-left)
  (set-frame-parameter (selected-frame) 'height emacs-min-height)
  (set-frame-parameter (selected-frame) 'width emacs-min-width)

  (when running-alternate-emacs
    (set-background-color "grey85")
    (set-face-background 'fringe "gray80")))

(if window-system
    (add-hook 'after-init-hook 'emacs-min))

(defun emacs-max ()
  (interactive)
  (if t
      (progn
        (set-frame-parameter (selected-frame) 'fullscreen 'fullboth)
        (set-frame-parameter (selected-frame) 'vertical-scroll-bars nil)
        (set-frame-parameter (selected-frame) 'horizontal-scroll-bars nil))
    (set-frame-parameter (selected-frame) 'top 26)
    (set-frame-parameter (selected-frame) 'left 2)
    (set-frame-parameter (selected-frame) 'width
                         (floor (/ (float (x-display-pixel-width)) 9.15)))
    (if (= 1050 (x-display-pixel-height))
        (set-frame-parameter (selected-frame) 'height
                             (if (>= emacs-major-version 24)
                                 66
                               55))
      (set-frame-parameter (selected-frame) 'height
                           (if (>= emacs-major-version 24)
                               75
                             64)))))

(defun emacs-toggle-size ()
  (interactive)
  (if (> (cdr (assq 'width (frame-parameters))) 100)
      (emacs-min)
    (emacs-max)))

(bind-key "C-c m" 'emacs-toggle-size)

#+end_src 



#+begin_src emacs-lisp 

(setq user-initials "dkh")

(defcustom user-initials nil
  "*Initials of this user."
  :set
  #'(lambda (symbol value)
      (if (fboundp 'font-lock-add-keywords)
          (mapc
           #'(lambda (mode)
               (font-lock-add-keywords
                mode (list (list (concat "\\<\\(" value " [^:\n]+\\):")
                                 1 font-lock-warning-face t))))
           '(c-mode c++-mode emacs-lisp-mode lisp-mode
                    python-mode perl-mode java-mode groovy-mode)))
      (set symbol value))
  :type 'string
  :group 'mail)

(defun insert-user-timestamp ()
  "Insert a quick timestamp using the value of `user-initials'."
  (interactive)
  (insert (format "%s (%s): " user-initials
                  (format-time-string "%Y-%m-%d" (current-time)))))

(bind-key "C-c n" 'insert-user-timestamp)
(bind-key "C-c o" 'customize-option)
(bind-key "C-c O" 'customize-group)

(defvar printf-index 0)

(defun insert-counting-printf (arg)
  (interactive "P")
  (if arg
      (setq printf-index 0))
  (if t
      (insert (format "std::cerr << \"step %d..\" << std::endl;\n"
                      (setq printf-index (1+ printf-index))))
    (insert (format "printf(\"step %d..\\n\");\n"
                    (setq printf-index (1+ printf-index)))))
  (forward-line -1)
  (indent-according-to-mode)
  (forward-line))

(bind-key "C-c p" 'insert-counting-printf)
(bind-key "C-c q" 'fill-region)
(bind-key "C-c r" 'replace-regexp)
(bind-key "C-c s" 'replace-string)
(bind-key "C-c u" 'rename-uniquely)


#+end_src   

#+begin_src emacs-lisp :tangle no

(defun tinify-url (url)
  (interactive "sURL to shorten: ")
  (let* ((api-login "jwiegley")
         (api-key
          (funcall
           (plist-get
            (car (auth-source-search :host "api.j.mp" :user api-login
                                     :type 'netrc :port 80))
            :secret))))
    (flet ((message (&rest ignore)))
      (with-current-buffer
          (let ((query
                 (format "format=txt&longUrl=%s&login=%s&apiKey=%s"
                         (url-hexify-string url) api-login api-key)))
            (url-retrieve-synchronously
             (concat "http://api.j.mp/v3/shorten?" query)))
        (goto-char (point-min))
        (re-search-forward "^$")
        (prog1
            (kill-new (buffer-substring (1+ (point)) (1- (point-max))))
          (kill-buffer (current-buffer)))))))

(bind-key "C-c U" 'tinify-url)

#+end_src

#+begin_src emacs-lisp 

(bind-key "C-c v" 'ffap)

#+end_src

#+begin_src emacs-lisp 

(defun view-clipboard ()
  (interactive)
  (delete-other-windows)
  (switch-to-buffer "*Clipboard*")
  (let ((inhibit-read-only t))
    (erase-buffer)
    (clipboard-yank)
    (goto-char (point-min))
    (html-mode)
    (view-mode)))

(bind-key "C-c V" 'view-clipboard)
;;(bind-key "C-c z" 'clean-buffer-list)

(bind-key "C-c [" 'align-regexp)
(bind-key "C-c =" 'count-matches)
(bind-key "C-c ;" 'comment-or-uncomment-region)

#+end_src 

;;;_  . C-c C-?

#+begin_src emacs-lisp :tangle no

(defun delete-to-end-of-buffer ()
  (interactive)
  (kill-region (point) (point-max)))

(bind-key "C-c C-z" 'delete-to-end-of-buffer)

#+end_src


;;;_  . C-c M-?

#+begin_src emacs-lisp 

(defun unfill-paragraph (arg)
  (interactive "*p")
  (let (beg end)
    (forward-paragraph arg)
    (setq end (copy-marker (- (point) 2)))
    (backward-paragraph arg)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (when (> (count-lines beg end) 1)
      (while (< (point) end)
        (goto-char (line-end-position))
        (let ((sent-end (memq (char-before) '(?. ?\; ?! ??))))
          (delete-indentation 1)
          (if sent-end
              (insert ? )))
        (end-of-line))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "[^.;!?:]\\([ \t][ \t]+\\)" end t)
          (replace-match " " nil nil nil 1))))))

(bind-key "C-c M-q" 'unfill-paragraph)

(defun unfill-region (beg end)
  (interactive "r")
  (setq end (copy-marker end))
  (save-excursion
    (goto-char beg)
    (while (< (point) end)
      (unfill-paragraph 1)
      (forward-paragraph))))

#+end_src       

;;;_ , ctl-period-map

;;;_  . C-. ?

#+begin_src emacs-lisp 

(bind-key "C-. m" 'kmacro-keymap)

#+end_src 
;;;_  . C-. C-i

#+begin_src emacs-lisp 

(bind-key "C-. C-i" 'indent-rigidly)

#+end_src 

** Help map
#+begin_src emacs-lisp 

(defvar lisp-find-map)
(define-prefix-command 'lisp-find-map)

(bind-key "C-h e" 'lisp-find-map)

;;;_  . C-h e ?

#+end_src


* Custom settings
** Custom file location


*** Ewax default files directory

#+begin_src emacs-lisp 

(setq ewax-default-directory "~/git/.emacs.d")

;;(expand-file-name "dkh-gnus.el" ewax-default-directory)

#+end_src 

#+begin_src emacs-lisp 

(setq custom-file (expand-file-name "custom.el" ewax-default-directory))

#+end_src 

** Default directory

#+begin_src emacs-lisp :tangle no

(setq default-directory "~/git/")

#+end_src 

** Save my history

#+begin_src emacs-lisp 

(setq savehist-file "~/.emacs.d/history")

#+end_src 


** Scratch Buffer

#+begin_src emacs-lisp 

(setq initial-scratch-message "ಠ_ಠ")
;; empty out the comments on the scratch buffer, (i hate that text)

#+end_src 

** Enable all disabled commands

#+begin_src emacs-lisp 

;; Enable all disabled commands (eval-expression, narrow-to-..., etc.)
(setq disabled-command-function nil)
#+end_src 

** Window settings
*** Pop up windows

#+begin_src emacs-lisp 

(setq pop-up-windows nil)

#+end_src 

*** Use same window

#+begin_src emacs-lisp 

(add-to-list 'same-window-buffer-names "*Help*")
(add-to-list 'same-window-buffer-names "*Apropos*")
(add-to-list 'same-window-buffer-names "*Summary*")
 (add-to-list 'same-window-buffer-names "*Backtrace*")



;; Define buffers that should appear in the same window.
(add-to-list 'same-window-buffer-names "*Buffer List*")
(add-to-list 'same-window-buffer-names "*Colors*")
(add-to-list 'same-window-buffer-names "*Command History*")
(add-to-list 'same-window-buffer-names "*Diff*")
(add-to-list 'same-window-buffer-names "*Proced*")
(add-to-list 'same-window-buffer-names "*vc-dir*")
(add-to-list 'same-window-buffer-names "*SQL*")
(add-to-list 'same-window-buffer-names "scratch.org")


(setq same-window-regexps '(
                          "\*grep\*"
))

(add-to-list 'same-window-regexps "\\*compilation\\*\\(\\|<[0-9]+>\\)")
(add-to-list 'same-window-regexps "\\*Help\\*\\(\\|<[0-9]+>\\)")

(add-to-list 'same-window-regexps "\\*Shell Command Output\\*\\(\\|<[0-9]+>\\)")

(add-to-list 'same-window-regexps "\\*dictem.*")

#+end_src 

*** Clean buffers

#+begin_src emacs-lisp :tangle no

(setq
clean-buffer-list-kill-never-buffer-names (quote ("*scratch*" "*Messages*" "*server*" "*Group*" "*Org Agenda*" "todo.txt" "&bitlbee"))
clean-buffer-list-kill-never-regexps (quote ("^ \\*Minibuf-.*\\*$" "^\\*Summary" "^\\*Article" "^#"))
clean-buffer-list-kill-regexps (quote (".*")))



#+end_src 

** Icomplete mode

#+begin_src emacs-lisp 

(icomplete-mode 1)

(setq sentence-end-double-space nil)

(global-set-key (kbd "RET") 'newline-and-indent)

#+end_src 

** Scrollbars

#+begin_src emacs-lisp 

(scroll-bar-mode -1)                   ;; turn off the scrollbar
;;(scroll-bar-mode 1)                       ;; otherwise, show a scrollbar...
;;(set-scroll-bar-mode 'right))             ;; ... on the right

#+end_src 


** Fonts

#+begin_src emacs-lisp 

(setq mswindows-p (string-match "windows" (symbol-name system-type)))
(setq macosx-p (string-match "darwin" (symbol-name system-type)))
(setq linux-p (string-match "gnu/linux" (symbol-name system-type)))

;; We know we have consolas on OS X, so use it
;; We also need to do this as near the beginning as possible, since it crashes
;; otherwise?
(when (and macosx-p
  (when (member "Consolas" (font-family-list))
    (set-face-font 'default "consolas-11"))))
(when mswindows-p
  (set-face-font 'default "consolas-8"))
(when linux-p
  (when (member "Inconsolata" (font-family-list))
;;    (set-face-font 'default "inconsolata-11")
;;    (set-face-font 'default "DejaVu Sans Mono-9")
(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-12"))
))

(when macosx-p
  ;;Change meta to alt
  (setq mac-command-modifier 'meta)
  ;;avoid hiding with M-h
  (setq mac-pass-command-to-system nil))

#+end_src 

 You can get text properties of any char by typing `C-u C-x ='

 Under Windows, you can get the current font string by typing
 `(insert (format "\n%S" (w32-select-font)))' followed by `C-x C-e'

 You can find the current font by typing
 `M-x ielm RET (frame-parameters) RET'
 see the line `font'

 To check if some font is available in Emacs do following:
    1.   Switch to the `*scratch*' buffer.
    2.   Type `(prin1-to-string (x-list-fonts "font-you-want-to-check or
         pattern"))'.
    3.   Place the cursor after the last closing paren and hit
         `C-j'. List of the names of available fonts matching given
         pattern will appear in the current buffer (`*scratch*').
    4.   For listing of all available fonts, use
         `(prin1-to-string (x-list-fonts "*"))' or
         `(dolist (i (x-list-fonts "*")) (princ i) (terpri))'
         for a better output.

 Format: "-a-b-c-d-e-f-g-h-i-j-k-l-"
 where

 a = foundry

 b = font family <<<

 c = weight
     Valid options: `bold', `demibold', `light', `medium', `normal'.

 d = slant
     Valid options: `i' for italic and `r' for roman.

 e = set width
     Ignored by NT-Emacs.

 f = pixels
     Nominal font height in pixels. (Eg. 13 pixels roughly corresponds to
     10 points (a point is 1/72 of an inch) on a 96dpi monitor, so the
     font spec above is selecting a 10 point bold Courier font)

 g = points in tenths of a point
     10 point is 100

 h = horiz resolution in dpi
     I think these numbers represent the "design resolution" of the font -
     on X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

 i = vertical resolution in dpi
     I think these numbers represent the "design resolution" of the font -
     on X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

 j = spacing
     Spacing as in mono-spaced or proportionally spaced.
     Values are `c' (constant) or `m' (monospace) to mean fixed-width or
     `p' for proportionally spaced.

 k = average width in tenths of a pixel

 l = character set
     NT-Emacs understands: ansi, oem, symbol to refer to the standard
     Windows character sets (the first two, at least, are locale
     dependant). "iso8859" and "iso8859-1" are accepted as synonyms for
     ansi.

 Use `xfontsel' utility (or the command-line `xlsfonts') to try out
 different fonts. After choosing a font, click the select button in
 `xfontsel' window. This will copy font name you choose to copy & paste
 buffer.
 Edit your `~/.Xresources' file to have a line with "Emacs.font".
 Then do a `xrdb -merge ~/.Xresources' or restart your X11 to validate the
 modification. I let emacs do this for me:

#+begin_src emacs-lisp 

(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
    (when (or (string= file ".Xdefaults")
              (string= file ".Xresources"))
      (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
      (message (format "Merged %s into X resource database" file)))))

(add-hook 'after-save-hook 'merge-x-resources)

#+end_src 

Now Emacs should start with that font.

For reasons unknown to me,'emacs' takes a long file to change fonts in an X
environment.

Rather than using (set-default-font ...) in .emacs, stick the font
definition in your .Xresources file (key 'Emacs*font') and then use 'xrdb
-load' to activate it. You will find that startup time is greatly improved!

#+begin_src emacs-lisp 

;; avoid Emacs hanging for a while changing default font
(modify-frame-parameters nil '((wait-for-wm . nil)))

#+end_src 

*** Faces

#+begin_src emacs-lisp :tangle no

(custom-set-faces                                                                           
  ;; custom-set-faces was added by Custom.                                                  
  ;; If you edit it by hand, you could mess it up, so be careful.                           
  ;; Your init file should contain only one such instance.                                  
 ;; If there is more than one, they won't work right.                                      
 '(mumamo-background-chunk-major ((((class color) (min-colors 8)) (:background "white")))))

#+end_src 

*** Cycle font (functions)

#+begin_src emacs-lisp 

(defun cycle-font (num)
  "Change font in current frame.
Each time this is called, font cycles thru a predefined set of fonts.
If NUM is 1, cycle forward.
If NUM is -1, cycle backward.
Warning: tested on Windows Vista only."
  (interactive "p")
  ;; this function sets a property “state”. It is a integer. Possible values are any index to the fontList.
  (let (fontList fontToUse currentState nextState )
    (setq fontList (list
                    "Courier New-10" "DejaVu Sans Mono-9"
;;"Lucida Console-10"
                    "DejaVu Sans-10"
;; "Lucida Sans Unicode-10"
;; "Arial Unicode MS-10" 
;;                    "inconsolata-11"
"DejaVu Sans Mono-9" "DejaVu Sans Mono-10" "DejaVu Sans Mono-12"
))
    ;; fixed-width "Courier New" "Unifont"  "FixedsysTTF" "Miriam Fixed" "Lucida Console" "Lucida Sans Typewriter"
    ;; variable-width "Code2000"
    (setq currentState (if (get 'cycle-font 'state) (get 'cycle-font 'state) 0))
    (setq nextState (% (+ currentState (length fontList) num) (length fontList)))

    (setq fontToUse (nth nextState fontList))
    (set-frame-parameter nil 'font fontToUse)
    (redraw-frame (selected-frame))
    (message "Current font is: %s" fontToUse )

    (put 'cycle-font 'state nextState)
    )
  )

(defun cycle-font-forward ()
  "Switch to the next font, in the current frame.
See `cycle-font'."
  (interactive)
  (cycle-font 1)
  )

(defun cycle-font-backward ()
  "Switch to the previous font, in the current frame.
See `cycle-font'."
  (interactive)
  (cycle-font -1)
  )

#+end_src 

** Recent files mode

#+begin_src emacs-lisp

;; enable recent files mode.
(recentf-mode t)

(setq recentf-save-file "~/.emacs.d/recentf")


#+end_src 

** Recursive minibuffers (config)

#+begin_src emacs-lisp 

(setq enable-recursive-minibuffers t)

#+end_src 

** Security (PGP)

Designed for use with Keychain (see:
http://docs.funtoo.org/wiki/Keychain) a tool for loading the SSH
Agent and keeping it running and accessible on a machine for longer
than a single login session.

#+begin_src emacs-lisp 

(require 'keychain-environment)

#+end_src 

** Emacs maintenance
*** Delete old versions
#+begin_src emacs-lisp 

(setq delete-old-versions t)

#+end_src 
 
** Guru Mode

Guru mode disables some common keybindings and suggests the use of the
established Emacs alternatives instead.

#+begin_src emacs-lisp :tangle no

(require 'guru-mode)
(guru-mode) ;; to enable in all buffers

#+end_src

** Save place
[2012-06-26 Tue 14:12]

If you wish your place in any file to always be automatically saved,
simply put this in your `~/.emacs' file:

#+begin_src emacs-lisp 

(setq-default save-place t)
(require 'saveplace)

#+end_src 

** Faces
#+begin_src emacs-lisp 

(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(diff-added ((t (:foreground "DarkGreen"))))
 '(diff-added2 ((t (:foreground "SeaGreen"))))
 '(diff-changed ((t (:foreground "MediumBlue"))))
 '(diff-context ((t (:foreground "Black"))))
 '(diff-file-header ((t (:background "grey85" :foreground "Red"))))
 '(diff-header ((t (:background "grey85" :foreground "red"))))
 '(diff-hunk-header ((t (:background "grey90" :foreground "black"))))
 '(diff-index ((t (:foreground "Green"))))
 '(diff-nonexistent ((t (:foreground "DarkBlue"))))
 '(diff-removed ((t (:foreground "firebrick"))))
 '(diff-removed2 ((t (:foreground "Orange"))))
 '(font-lock-comment-face ((((class color)) (:foreground "firebrick"))))
 '(helm-M-x-key ((t (:foreground "dark red" :underline t))))
 '(helm-candidate-number ((t (:background "#faffb5" :foreground "black"))))
 '(helm-selection ((t (:background "#b5ffd1" :underline t))))
 '(helm-separator ((t (:foreground "#ffbfb5"))))
 '(helm-source-header ((t (:background "#abd7f0" :foreground "black" :underline t))))
 '(helm-visible-mark ((t (:background "#d1f5ae"))))
 '(hl-line ((t (:background "cornsilk"))))
 '(ledger-register-pending-face ((t (:weight bold))))
 '(lusty-match-face ((t (:inherit helm-match))))
 '(magit-branch-face ((((class color) (background light)) (:foreground "Blue"))))
 '(magit-diff-none-face ((((class color) (background light)) (:foreground "grey50"))))
 '(magit-header ((t (:weight bold))))
 '(magit-topgit-current ((t nil)))
 '(match ((t (:background "light cyan"))))
 '(slime-highlight-edits-face ((((class color) (background light)) (:background "gray98"))))
 '(trailing-whitespace ((((class color) (background light)) (:background "light salmon"))))
 '(wg-brace-face ((((class color)) (:foreground "dark slate blue"))))
 '(wg-command-face ((((class color)) (:foreground "dark cyan"))))
 '(wg-current-workgroup-face ((((class color)) (:foreground "black"))))
 '(wg-divider-face ((((class color)) (:foreground "dark slate blue"))))
 '(wg-filename-face ((((class color)) (:foreground "dark blue"))))
 '(wg-frame-face ((((class color)) (:foreground "black"))))
 '(wg-message-face ((((class color)) (:foreground "dark blue"))))
 '(wg-mode-line-face ((((class color)) (:foreground "dark blue"))))
 '(wg-other-workgroup-face ((((class color)) (:foreground "dark slate grey"))))
 '(wg-previous-workgroup-face ((((class color)) (:foreground "dark blue"))))
 '(whitespace-line ((t (:background "lemon chiffon" :foreground "dark violet")))))

#+end_src 
** autosave

#+begin_src emacs-lisp :tangle no

(setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))) 

#+end_src 

* Functionality (Ease of use)
*** Modes

This stuff is needed to auto spell checking in gnus, etc.

#+begin_src emacs-lisp 

(add-hook 'c-mode-common-hook 'flyspell-prog-mode)
(add-hook 'tcl-mode-hook 'flyspell-prog-mode)

#+end_src 

** Frame functionality
*** Positioning of frame when starting Emacs

#+begin_src emacs-lisp :tangle no


(setq default-frame-alist '(
                            (height . 61) (width . 98)
                            (top . 72) (left . 36)
                            ))
(setq initial-frame-alist '((top . 72) (left . 775)))

#+end_src 

*** Set up initial frame

#+begin_src emacs-lisp :tangle no

(when window-system
  ;; list of frame parameters for creating the initial frame
  (setq initial-frame-alist '((top . 0) (left . 0)))

  (setq initial-frame-alist
        (append (list
                 '(internal-border-width . 2)
                 '(line-spacing          . 1))
                initial-frame-alist))

  ;; list of default values for frame creation
  (setq default-frame-alist
        (cond ((= (x-display-pixel-height) 1200)
               '((left . 0) (height . 74)))

              ((= (x-display-pixel-height) 1024)
               '((left . 0) (height . 63)))

              ((= (x-display-pixel-height) 800)
               (cond (running-ms-windows
                      '((left . 0) (height . 55)))
                     (running-gnu-linux
                      '((left . 0) (height . 47)
                        (vertical-scroll-bars . right)))))

              ((= (x-display-pixel-height) 768)
               '((left . 0) (height . 46)))))
)

#+end_src 

*** Set frame size according to resolution

#+begin_src emacs-lisp 

(defun set-frame-size-according-to-resolution ()
    (interactive)
    (if window-system
    (progn
      (if (> (x-display-pixel-width) 1500) ;; 1500 is the delimiter marging in px to consider the screen big
             (set-frame-width (selected-frame) 237) ;; on the big screen make the fram 237 columns big
             (set-frame-width (selected-frame) 177)) ;; on the small screen we use 177 columns
      (setq my-height (/ (- (x-display-pixel-height) 150) ;; cut 150 px of the screen height and use the rest as height for the frame
                               (frame-char-height)))
      (set-frame-height (selected-frame) my-height)
      (set-frame-position (selected-frame) 3 90) ;; position the frame 3 pixels left and 90 px down
  )))

  ;; (set-frame-size-according-to-resolution)
  (global-set-key (kbd "C-x 9") 'set-frame-size-according-to-resolution)

#+end_src 

*** Frame title

#+begin_src emacs-lisp 
(setq frame-title-format
  '("" invocation-name ": "(:eval (if (buffer-file-name)
                (abbreviate-file-name (buffer-file-name))
                  "%b"))))

#+end_src

** Window functionality (navigation, etc)
This is a visual replacement for C-x o, so here's what
dim-switch-window.el will look like if you happen to use it:
*** Switch Window

Switch window the cowabunga, dude! way

#+begin_src emacs-lisp 

(require 'switch-window)

#+end_src 

*** Show a marker in the left fringe for lines not in the buffer

#+begin_src emacs-lisp 

(setq default-indicate-empty-lines t)

#+end_src

*** Windmove

#+begin_src emacs-lisp 

(setq windmove-wrap-around t)

#+end_src 
*** Window Number Mode

#+begin_src emacs-lisp 

(require 'window-number)
(window-number-mode)
(window-number-meta-mode)

#+end_src 

*** Other window bindings

#+begin_src emacs-lisp 
;;; switch

;; Experiment with more convenient keys than `C-x o' and `M-- C-x o'.
(define-key global-map [(hyper ?\x8a7)] 'other-window)
(define-key global-map [(hyper ?\x8bd)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?\247)] 'other-window)
(define-key global-map [(hyper ?\275)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?`)] 'other-window)
(define-key global-map [(hyper ?~)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?<)] 'other-window)
(define-key global-map [(hyper ?>)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?,)] 'other-window)
(define-key global-map [(hyper ?.)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper print)] 'other-window)

#+end_src

*** Window Functions

#+begin_src emacs-lisp 

(defun my-swap-windows ()
  "If you have 2 windows, it swaps them."
  (interactive)
  (cond ((not (= (count-windows) 2))
         (message "You need exactly 2 windows to do this."))
        (t
         (let* ((w1 (first (window-list)))
                (w2 (second (window-list)))
                (b1 (window-buffer w1))
                (b2 (window-buffer w2))
                (s1 (window-start w1))
                (s2 (window-start w2)))
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (set-window-start w1 s2)
           (set-window-start w2 s1)))))

(defun my-toggle-window-split ()
  "Vertical split shows more of each line, horizontal split shows
more lines. This code toggles between them. It only works for
frames with exactly two windows."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

;; I want to be able to conmute between a split and a single window (sort of "C-x 1" for the one on focus)
(defun toggle-windows-split()
"Switch back and forth between one window and whatever split of windows we might have in the frame. The idea is to maximize the current buffer, while being able to go back to the previous split of windows in the frame simply by calling this command again."
(interactive)
(if (not(window-minibuffer-p (selected-window)))
(progn
(if (< 1 (count-windows))
(progn
(window-configuration-to-register ?u)
(delete-other-windows))
(jump-to-register ?u))))
;;(my-iswitchb-close)
)

(defun split-window-switch-buffer () (interactive)
  "Split current window and display the two last buffers used."
  (split-window)
  (switch-to-buffer (other-buffer (current-buffer)))
  )

(defun hsplit-window-switch-buffer () (interactive)
  "Split current window horizontally and display the two last buffers used."
  (split-window-horizontally)
  (switch-to-buffer (other-buffer (current-buffer)))
  )

(setq swapping-buffer nil)
(setq swapping-window nil)

(defun swap-buffers-in-windows ()
  "Swap buffers between two windows"
  (interactive)
  (if (and swapping-window
           swapping-buffer)
      (let ((this-buffer (current-buffer))
            (this-window (selected-window)))
        (if (and (window-live-p swapping-window)
                 (buffer-live-p swapping-buffer))
            (progn (switch-to-buffer swapping-buffer)
                   (select-window swapping-window)
                   (switch-to-buffer this-buffer)
                   (select-window this-window)
                   (message "Swapped buffers."))
          (message "Old buffer/window killed.  Aborting."))
        (setq swapping-buffer nil)
        (setq swapping-window nil))
    (progn
      (setq swapping-buffer (current-buffer))
      (setq swapping-window (selected-window))
      (message "Buffer and window marked for swapping."))))

(defun rotate-windows ()
 "Rotate your windows" (interactive) (cond ((not (> (count-windows) 1)) (message "You can't rotate a single window!"))
(t
 (setq i 1)
 (setq numWindows (count-windows))
 (while  (< i numWindows)
   (let* (
          (w1 (elt (window-list) i))
          (w2 (elt (window-list) (+ (% i numWindows) 1)))

          (b1 (window-buffer w1))
          (b2 (window-buffer w2))

          (s1 (window-start w1))
          (s2 (window-start w2))
          )
     (set-window-buffer w1  b2)
     (set-window-buffer w2 b1)
     (set-window-start w1 s2)
     (set-window-start w2 s1)
     (setq i (1+ i)))))))

(require 'buffer-move)

#+end_src 

*** Window functions

#+begin_src emacs-lisp 

(defun select-next-window ()
  "Switch to the next window" 
  (interactive)
  (select-window (next-window)))

(defun select-previous-window ()
  "Switch to the previous window" 
  (interactive)
  (select-window (previous-window)))

(defun buffer-same-mode (change-buffer-fun)
  (let ((current-mode major-mode)
        (next-mode nil))
    (while (not (eq next-mode current-mode))
      (funcall change-buffer-fun)
      (setq next-mode major-mode))))

(defun previous-buffer-same-mode ()
  (interactive)
  (buffer-same-mode #'previous-buffer))

(defun next-buffer-same-mode ()
  (interactive)
  (buffer-same-mode #'next-buffer))

(global-set-key [H-tab] 'previous-buffer-same-mode)
(global-set-key [C-H-tab] 'next-buffer-same-mode)

#+end_src


*** More Window functions

#+begin_src emacs-lisp 

;;----------------------------------------------------------------------------
;; When splitting window, show (other-buffer) in the new window
;;----------------------------------------------------------------------------
(defun split-window-func-with-other-buffer (split-function)
  (lexical-let ((s-f split-function))
    (lambda ()
      (interactive)
      (funcall s-f)
      (set-window-buffer (next-window) (other-buffer)))))

(global-set-key "\C-x2" (split-window-func-with-other-buffer 'split-window-vertically))
(global-set-key "\C-x3" (split-window-func-with-other-buffer 'split-window-horizontally))

;;----------------------------------------------------------------------------
;; Rearrange split windows
;;----------------------------------------------------------------------------
(defun split-window-horizontally-instead ()
  (interactive)
  (save-excursion
    (delete-other-windows)
    (funcall (split-window-func-with-other-buffer 'split-window-horizontally))))

(defun split-window-vertically-instead ()
  (interactive)
  (save-excursion
    (delete-other-windows)
    (funcall (split-window-func-with-other-buffer 'split-window-vertically))))

(global-set-key "\C-x|" 'split-window-horizontally-instead)
(global-set-key "\C-x_" 'split-window-vertically-instead)

#+end_src 

** Copy/Paste functionality

#+begin_src emacs-lisp 

;; have pasting work right in emacs 24
(setq x-select-enable-primary t)

#+end_src 

replace a region in emacs with yank buffer contents

#+begin_src emacs-lisp 

(delete-selection-mode t)

#+end_src 

In linux, if copy/paste doesn't work with other apps, you need to add
this line:

#+begin_src emacs-lisp 

(setq x-select-enable-clipboard t)

#+end_src 

*** Copy current file path

One of the drawbacks of integrating the GNU Emacs copy-and-paste
mechanism with X is that Emacs will grab the clipboard or selection
every time you do a kill. This becomes a problem over slow network
links (such as, for example, a DSL connection from home to work, and
from there to a remote datacenter). I wrote replacements for myself
that make clipboard operations explicit. This works with CVS GNU
Emacs. Note that this affects the clipboard, so it will work with
Firefox and “modern” X apps, but older X apps like xterm need to be
modified to use CLIPBOARD rather than the PRIMARY selection.


#+begin_src emacs-lisp :tangle no

  ;; Disable automatic cutting and pasting to the clipboard.
  ;; This causes noticeable delays over slow network links.
  ;; The function `insert-clipboard-contents' and the function
  ;; `set-clipboard-contents' let me do this explicitly.
  (setq interprogram-cut-function nil)
  (setq interprogram-paste-function nil)

  (defun get-clipboard-contents-as-string ()
    "Return the value of the clipboard contents as a string."
    (let ((x-select-enable-clipboard t))
      (or (x-cut-buffer-or-selection-value)
          x-last-selected-text-clipboard)))

  (defun insert-clipboard-contents ()
    "Insert the value of the current X selection at point.
  Uses the clipboard value if it is defined or not empty, otherwise
  falls back on the primary selection."
    (interactive)
    (let ((text (get-clipboard-contents-as-string)))
      (when text
        ;; This operation is very much like a yank, so set mark like
        ;; yank does.  Note that the "longlines" mode advice on this
        ;; function depends on mark having been set.
        (push-mark)
        (insert text))))

  (defun set-clipboard-contents-from-string (str)
    "Copy the value of string STR into the clipboard."
    (let ((x-select-enable-clipboard t))
      (x-select-text str)))

  (defun set-clipboard-contents (beg end)
    "Copy the value of the current region into the clipboard."
    (interactive "r")
    (set-clipboard-contents-from-string
     (buffer-substring-no-properties beg end))
    (setq deactivate-mark t))

  (defun set-clipboard-contents-delete (beg end)
    "Cut the value of the current region into the clipboard.
  The current region is deleted (without updating the kill ring)."
    (interactive "r")
    (set-clipboard-contents-from-string
     (buffer-substring-no-properties beg end))
    (delete-region beg end)
    (setq deactivate-mark t))

  (defun set-clipboard-contents-and-kill-ring-from-string (str)
    "Copy the value of string STR into the clipboard, and make it the latest kill."
    (set-clipboard-contents-from-string str)
    (kill-new str)
    (message "%s" str))

  (eval-after-load "longlines"
    '(progn
       (defadvice insert-clipboard-contents (after longlines-decode-kill activate)
         ;; Depends on insert-clipboard-contents having set mark at the
         ;; begging of the text.  If we have to stop doing that, we
         ;; should turn this into "around" advice that can capture point
         ;; before doing the insert.
         (when longlines-mode
           (longlines-decode-region (point) (mark t))
           (when longlines-showing
             (longlines-show-hard-newlines))))
       (defadvice set-clipboard-contents (around longlines-encode-kill activate)
         (if longlines-mode
             (let ((str (buffer-substring beg end)))
               (with-temp-buffer
                 (insert str)
                 (longlines-encode-region (point-min) (point-max))
                 (setq beg (point-min))
                 (setq end (point-max))
                 ad-do-it))
           ad-do-it))
       (defadvice set-clipboard-contents-delete (before longlines-encode-kill activate)
         (when longlines-mode
           (longlines-encode-region beg end)))))

  (defun path-to-clipboard ()
    "Copy the current file's path to the clipboard.

  If the current buffer has no file, copy the buffer's default directory."
    (interactive)
    (let ((path (expand-file-name (or (buffer-file-name) default-directory))))
      (set-clipboard-contents-from-string path)
      (message "%s" path)))

  (defun npath-to-clipboard ()
    "Copy the current file's path to the clipboard, with a network filename.
  The resulting value will have the correct syntax to use with SCP.

  If the current buffer has no file, copy the buffer's default directory."
    (interactive)
    (let* ((host (system-name))
           (path (expand-file-name (or (buffer-file-name) default-directory)))
           (network-path (concat host ":" path)))
      (set-clipboard-contents-from-string network-path)
      (message "%s" network-path)))

#+end_src

#+begin_src emacs-lisp 

(defun copy-buffer-file-name (use-backslashes)
  "Puts the file name of the current buffer (or the current directory,
if the buffer isn't visiting a file) onto the kill ring, so that it
can be retrieved with \\[yank], or by another program.  With argument,
uses backslashes instead of forward slashes."
  (interactive "P")
  (let ((fn (subst-char-in-string
             ?/
             (if use-backslashes ?\\ ?/)
             (or
              (buffer-file-name (current-buffer))
              ;; Perhaps the buffer isn't visiting a file at all.  In
              ;; that case, let's return the directory.
              (expand-file-name default-directory)))))
    (when (null fn)
      (error "Buffer doesn't appear to be associated with any file or 
directory."))
    (kill-new fn)
    (message "%s" fn)
    fn))

(global-set-key (kbd "H-f") 'copy-buffer-file-name)

#+end_src 


** Completion functionality
*** Ignore case in completion

#+begin_src emacs-lisp 

(setq completion-ignore-case t)

#+end_src 



*** Some files I don't want to see often

#+begin_src emacs-lisp 

(setq completion-ignored-extensions
      (append (list
                    ".bak"
                  ".old"
                  ".tar"
                  ".new"
                  ".tar.gz"
                  ".jeff"
                    )
              completion-ignored-extensions))

#+end_src 

*** Pc-Complete

#+begin_src emacs-lisp 

(defconst pcmpl-git-commands
  '("add" "bisect" "branch" "checkout" "clone"
    "commit" "diff" "fetch" "grep"
    "init" "log" "merge" "mv" "pull" "push" "rebase"
    "reset" "rm" "show" "status" "tag" )
  "List of `git' commands")
 
(defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
  "The `git' command to run to get a list of refs")
 
(defun pcmpl-git-get-refs (type)
  "Return a list of `git' refs filtered by TYPE"
  (with-temp-buffer
    (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
    (goto-char (point-min))
    (let ((ref-list))
      (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
        (add-to-list 'ref-list (match-string 1)))
      ref-list)))
 
(defun pcomplete/git ()
  "Completion for `git'"
  ;; Completion for the command argument.
  (pcomplete-here* pcmpl-git-commands)  
  ;; complete files/dirs forever if the command is `add' or `rm'
  (cond
   ((pcomplete-match (regexp-opt '("add" "rm")) 1)
    (while (pcomplete-here (pcomplete-entries))))
   ;; provide branch completion for the command `checkout'.
   ((pcomplete-match "checkout" 1)
    (pcomplete-here* (pcmpl-git-get-refs "heads")))))

#+end_src 

** Mode-line functionality
*** Show approx buffer size in modeline

#+begin_src emacs-lisp 

(size-indication-mode)

#+end_src 

*** Show buffer position in modeline

;; show buffer pos in the
;; use sml-modeline if available

#+begin_src emacs-lisp 

(if (require 'sml-modeline nil 'noerror)    
  (progn (sml-modeline-mode 1) mode line))

#+end_src

*** Diminish
[2011-10-04 Tue 13:47]Emacs' version on a status-bar is called the
mode-line, and contains all kind of information – the current buffer
name, the cursor position and a lot of other things, depending on what
major and minor modes are active.

Customizing the mode-line is, unfortunately, rather hard. One day,
I'll write something about that… but for now at least we may be able
to improve things a little bit, by reducing mode line pollution. Mode
line pollution? Well, many parts of emacs like to announce their
presence and state in the mode line. With the limited space available
there, this can become a bit of an issue, the (Lisp Interaction
company Yas abbrev) takes quite some space:
                                                  

But there are some ways to limit the space taken by modes and
minor-modes. Note, these snippets should go in your .emacs, and you
need to restart emacs to make them active.

First, the minor modes (note, you can see the currently activated ones
with C-h m); install the handy diminish.el (or get it using the
emacs-goodies-el package when using Debian/Ubuntu) and add something
like the following:

#+begin_src emacs-lisp 

(when (require 'diminish nil 'noerror)
  (eval-after-load "company"
      '(diminish 'company-mode "Cmp"))
    (eval-after-load "yasnippet"
    '(diminish 'yas/minor-mode "Y")))

;; And the major-modes, for example for Emacs Lisp mode:

(add-hook 'emacs-lisp-mode-hook 
  (lambda()
    (setq mode-name "el")))

#+end_src 

** Mouse functionality
*** Make URLs in comments/strings clickable

#+begin_src emacs-lisp 

(add-hook 'find-file-hooks 'goto-address-prog-mode)

#+end_src 

** Color functionality
*** Color themes

**** Long live Solarized

#+begin_src emacs-lisp 

(require 'color-theme)
(require 'color-theme-solarized)
(load-theme 'solarized-dark t)
;;(setq solarized-termcolors "256")

#+end_src

*** Somewhere over the rainbow

#+begin_src emacs-lisp 

(require 'rainbow-mode)
(rainbow-mode t)
(setq rainbow-x-colors t)
(require 'rainbow-delimiters)

(when (require 'rainbow-delimiters nil 'noerror)
  (progn
    (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode))
    (add-hook 'js2-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'c-mode-common-hook 'rainbow-delimiters-mode)
;;    (add-hook 'php-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))

#+end_src

*** Sort list-colors-display by Hue

Perm URL with updates: http://xahlee.org/emacs/emacs24_features.html

You can call list-colors-display to list colors and their RGB hex
values. But the result is not sorted. Now, you can sort it by
hue. Much better. Put this in your emacs init file:

#+begin_src emacs-lisp 

(setq list-colors-sort 'hsv )

#+end_src 

** Point, Search Rectangle & Region functionality
*** Store and restore point

When two windows view the same buffer at the same time, and one
window is switched to another buffer and back, point is now the
same as in the other window, not as it was before we switched away.
This mode tries to work around this problem by storing and
restoring per-window positions for each buffer.

#+begin_src emacs-lisp 

(require 'winpoint)
(window-point-remember-mode 1)

#+end_src 

*** I like returning to the same place

Purpose: When you visit a file, point goes to the last place where
  it was when you previously visited the same file.
  
To use it, turn it on in the options menu - “Save place in files
between Sessions”

#+begin_src emacs-lisp 

(require 'saveplace)                          ;; get the package

#+end_src 

*** Goto last change - this is bodacious 

#+begin_src emacs-lisp 

(when (require 'goto-last-change nil 'noerror)
  (global-set-key (kbd "C-x C-/") 'goto-last-change))

#+end_src 

*** Expand Region

#+begin_src emacs-lisp 

(add-to-list 'load-path "~/.emacs.d/src/expand-region.el")
(require 'expand-region)
(global-set-key (kbd "H-SPC") 'er/expand-region)

(defun er/add-text-mode-expansions ()
  (make-variable-buffer-local 'er/try-expand-list)
  (setq er/try-expand-list (append
                            er/try-expand-list
                            '(mark-paragraph
                              mark-page))))

(add-hook 'text-mode-hook 'er/add-text-mode-expansions)

#+end_src 

*** Get Selection or unit under Point

#+begin_src emacs-lisp 

(defun get-selection-or-unit  (unit)
  "Return the string and boundary of text selection or UNIT under cursor.

If `region-active-p' is true, then the region is the unit. Else,
it depends on the UNIT. See `unit-at-cursor' for detail about
UNIT.

Returns a vector [text a b], where text is the string and a and b
are its boundary."
  (interactive)

  (let (mytext p1 p2)
    (if (region-active-p)
        (progn
          (setq p1 (region-beginning))
          (setq p2 (region-end))
          (setq mytext (buffer-substring p1 p2) )
          (vector (buffer-substring-no-properties p1 p2) p1 p2 )
          )
      (unit-at-cursor unit)
 ) ) )

(defun unit-at-cursor  (unit)
  "Return the string and boundary of UNIT under cursor.

Returns a vector [text a b], where text is the string and a and b are its boundary.

UNIT can be:
• 'word — sequence of 0 to 9, A to Z, a to z, and hyphen.
• 'glyphs — sequence of visible glyphs. Useful for file name, url, …, that doesn't have spaces in it.
• 'line — delimited by “\\n”.
• 'block — delimited by “\\n\\n” or beginning/end of buffer.
• 'buffer — whole buffer. (respects `narrow-to-region')
• a vector [beginRegex endRegex] — The elements are regex strings used to determine the beginning/end of boundary chars. They are passed to `skip-chars-backward' and `skip-chars-forward'. For example, if you want paren as delimiter, use [\"^(\" \"^)\"]

Example usage:
    (setq bds (unit-at-cursor 'line))
    (setq myText (elt bds 0) p1 (elt bds 1) p2 (elt bds 2)  )

This function is similar to `thing-at-point' and `bounds-of-thing-at-point'.
The main differences are:
• this function returns the text and the 2 boundaries as a vector in one shot.
• 'line always returns the line without end of line character, avoiding inconsistency when the line is at end of buffer.
• 'word does not depend on syntax table.
• 'block does not depend on syntax table."
  (let (p1 p2)
    (save-excursion
        (cond
         ( (eq unit 'word)
           (let ((wordcharset "-A-Za-zÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ"))
             (skip-chars-backward wordcharset)
             (setq p1 (point))
             (skip-chars-forward wordcharset)
             (setq p2 (point)))
           )

         ( (eq unit 'glyphs)
           (progn
             (skip-chars-backward "[:graph:]")
             (setq p1 (point))
             (skip-chars-forward "[:graph:]")
             (setq p2 (point)))
           )

         ( (eq unit 'buffer)
           (progn
             (setq p1 (point-min))
             (setq p2 (point-max))
             )
           )

         ((eq unit 'line)
          (progn
            (setq p1 (line-beginning-position))
            (setq p2 (line-end-position))))
         ((eq unit 'block)
          (progn
            (if (re-search-backward "\n\n" nil t)
                (progn (forward-char 2)
                       (setq p1 (point) ) )
              (setq p1 (line-beginning-position) )
              )

            (if (re-search-forward "\n\n" nil t)
                (progn (backward-char)
                       (setq p2 (point) ))
              (setq p2 (line-end-position) ) ) ))

         ((vectorp unit)
          (let (p0)
             (setq p0 (point))
             (skip-chars-backward (elt unit 0))
             (setq p1 (point))
             (goto-char p0)
             (skip-chars-forward (elt unit 1))
             (setq p2 (point))))
         ) )

    (vector (buffer-substring-no-properties p1 p2) p1 p2 )
    ) )

(defun region-or-thing (thing)
  "Return a vector containing the region and its bounds if there is one
or the thing at the point and its bounds if there is no region"
  (if (use-region-p)
      (vector (buffer-substring-no-properties (region-beginning) (region-end))
              (region-beginning) (region-end))
    (let* ((bounds (bounds-of-thing-at-point thing))
           (beg (car bounds))
           (end (cdr bounds)))
      (vector (buffer-substring-no-properties beg end) beg end))))

(defun google-search ()
  "Do a Google search of the region or symbol at the point"
  (interactive)
  (let ((phrase (elt (region-or-thing 'symbol) 0)))
    (browse-url (concat "http://www.google.com/search?q="
                        (replace-regexp-in-string " " "+" phrase)))))


#+end_src 

*** Sacha Chua search word functions

#+begin_src emacs-lisp 

(defun sacha/search-word-backward ()
  "Find the previous occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-backward "w_")
    (goto-char
     (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
         (match-beginning 0)
       cur))))

(defun sacha/search-word-forward ()
  "Find the next occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-forward "w_")
    (goto-char
     (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
         (match-beginning 0)
       cur))))

(global-set-key (kbd "C-H-r") 'sacha/search-word-backward)
(global-set-key (kbd "C-H-s") 'sacha/search-word-forward)
(defadvice search-for-keyword (around sacha activate)
  "Match in a case-insensitive way."
  (let ((case-fold-search t))
    ad-do-it))

#+end_src 

*** Thing at point functions

#+begin_src emacs-lisp 

(defun ash-forward-string (&optional arg)
  "Move forward to ARGth string."
  (setq arg (or arg 1))
  (if (not (bobp))
      (save-match-data
        (when (or (and (looking-at-p "\\s-*\"")
                       (not (looking-back "\\\\")))
                  (re-search-backward "[^\\\\]\"" nil nil))
          (looking-at "\\s-*\"")
          (goto-char (match-end 0))
          (forward-char -1))))
  (while (and (> arg 0)
              (not (eobp))
              (looking-at-p "\\s-*\""))
    (forward-sexp 1)
    (setq arg (1- arg)))
  (while (and (< arg 0)
              (not (bobp))
              (looking-at-p "\""))
    (forward-sexp -1)
    (setq arg (1+ arg)))
  (ignore))

(put 'string 'forward-op 'ash-forward-string)

(defun ash-kill-string (&optional arg) 
  "Kill ARG strings under point."
  (interactive "*p")
  (setq arg (or (and (not (zerop arg)) arg) 1))
  (if (> arg 0)
      (kill-region
       (progn (forward-thing 'string 0) (point))
       (progn (forward-thing 'string arg) (point)))
    (kill-region
     (progn (forward-thing 'string 1) (point))
     (progn (forward-thing 'string arg) (point)))))

#+end_src 

*** Translate word at point function

#+begin_src emacs-lisp 

(defun translate ()
  "Translate the word at point using WordReference."
  (interactive)
  (browse-url (concat "http://www.wordreference.com/fren/" 
              (thing-at-point 'word)))
)

#+end_src 

*** Thing at point
**** Answers.com

#+begin_src emacs-lisp 
(defun answers-define ()
  "Look up the word under cursor in a browser."
  (interactive)
  (browse-url
   (concat "http://www.answers.com/main/ntquery?s="
           (thing-at-point 'word))))

#+end_src 

*** Replace region function

#+begin_src emacs-lisp 

(defun my-replace-region ()
  (interactive)
  (unless (use-region-p)
    (error "no region"))
  (let ((what (buffer-substring-no-properties
               (region-beginning) (region-end)))
        (replacement (read-string "replace with: ")))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward what nil t)
        (replace-match replacement)))))

#+end_src 

*** Rectangles
**** Kill save rectangle function

#+begin_src emacs-lisp 

(defun kill-save-rectangle (start end &optional fill)       
  "Save the rectangle as if killed, but don't kill it.  See 
`kill-rectangle' for more information."                     
  (interactive "r\nP")                                      
  (kill-rectangle start end fill)                           
  (goto-char start)                                         
  (yank-rectangle))

(global-set-key (kbd "C-x r M-k") 'kill-save-rectangle)

#+end_src 

** Confirm exiting emacs

#+begin_src emacs-lisp 

(defun confirm-exit-emacs ()
        "ask for confirmation before exiting emacs"
        (interactive)
        (if (yes-or-no-p "Are you sure you want to exit? ")
                (save-buffers-kill-emacs)))

(global-unset-key "\C-x\C-c")
(global-set-key "\C-x\C-c" 'confirm-exit-emacs)

#+end_src 



** Saving history

#+begin_src emacs-lisp 

(require 'savehist-20+)
(savehist-mode 1)

#+end_src 

** Bell

#+begin_src emacs-lisp 

;; provided by snogglethorpe
(defcustom mode-line-bell-string "ding" ;"â™ª"
  "Message displayed in mode-line by `mode-line-bell' function."
  :group 'user)
(defcustom mode-line-bell-delay 1.0
  "Number of seconds `mode-line-bell' displays its message."
  :group 'user)

;; internal variables
(defvar mode-line-bell-cached-string nil)
(defvar mode-line-bell-propertized-string nil)

(defun mode-line-bell ()
  "Briefly display a highlighted message in the mode-line.

  The string displayed is the value of `mode-line-bell-string',
  with a red background; the background highlighting extends to the
  right margin.  The string is displayed for `mode-line-bell-delay'
  seconds.

  This function is intended to be used as a value of `ring-bell-function'."

  (unless (equal mode-line-bell-string mode-line-bell-cached-string)
    (setq mode-line-bell-propertized-string
          (propertize
           (concat
            (propertize
             "x"
             'display
             `(space :align-to (- right ,(string-width mode-line-bell-string))))
            mode-line-bell-string)
           'face '(:background "red")))
    (setq mode-line-bell-cached-string mode-line-bell-string))
  (message mode-line-bell-propertized-string)
  (sit-for mode-line-bell-delay)
  (message ""))

(setq ring-bell-function 'mode-line-bell)

#+end_src 

** auto byte-compile elisp files

If you code elisp, it's nice to have the elisp file automatically byte-compiled everytime you save it. Put the following in your emacs init file:

;; auto compile elisp files after save

#+begin_src emacs-lisp 

(add-hook 'emacs-lisp-mode-hook (lambda () (add-hook 'after-save-hook 'emacs-lisp-byte-compile t t)) )

#+end_src 

** Make script files executable automatically

You can force Emacs to make a file executable (respecting your umask
settings) if Emacs considers it a script. To determine if it is a
script, Emacs will look for the hash-bang notation in the file and
treat it as a script if it finds it.

Add this to your .emacs and Emacs will then make the file executable
if it is a script.

#+begin_src emacs-lisp 

(add-hook 'after-save-hook
  'executable-make-buffer-file-executable-if-script-p)

#+end_src 

** Cyberpunk Cursor

#+begin_src emacs-lisp 

(blink-cursor-mode 1)

(defvar blink-cursor-colors (list  "#92c48f" "#6785c5" "#be369c" "#d9ca65")
  "On each blink the cursor will cycle to the next color in this list.")

(setq blink-cursor-count 0)

(defun blink-cursor-timer-function ()
  "Cyberpunk variant of timer `blink-cursor-timer'. OVERWRITES original version in `frame.el'.

This one changes the cursor color on each blink. Define colors in `blink-cursor-colors'."
  (when (not (internal-show-cursor-p))
    (when (>= blink-cursor-count (length blink-cursor-colors))
      (setq blink-cursor-count 0))
    (set-cursor-color (nth blink-cursor-count blink-cursor-colors))
    (setq blink-cursor-count (+ 1 blink-cursor-count))
    )
  (internal-show-cursor nil (not (internal-show-cursor-p)))
  )

#+end_src 

** CUA

#+begin_src emacs-lisp 

(cua-selection-mode t)

(global-set-key "\M-[" 'cua-set-rectangle-mark)

#+end_src

** Fill column

#+begin_src emacs-lisp 

(require 'fill-column-indicator)

(setq fci-rule-width 1)
(setq fci-rule-color "darkblue")

(define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode 1)))
(global-fci-mode 1)

#+end_src 

** KeyChords

#+begin_src emacs-lisp 

(require 'key-chord)
(key-chord-mode 1)

(key-chord-define-global "''"     "`'\C-b")
(key-chord-define-global ",,"     'indent-for-comment)
(key-chord-define-global "qq"     "the ")
(key-chord-define-global "QQ"     "The ")
(key-chord-define-global ",."     'append-next-kill)
(key-chord-define-global "4r"     "$")
(key-chord-define-global "jk" 'goto-line)
(key-chord-define-global "df"     'bookmark-jump)
(key-chord-define-global "sd"     'er/expand-region)
(key-chord-define-global "kl"     'dabbrev-expand)
(key-chord-define-global "AS" 'my-swap-windows)
(key-chord-define-global "SD" 'my-toggle-window-split)
(key-chord-define-global "DF" 'toggle-windows-split)
(key-chord-define-global "FG" 'split-window-switch-buffer)
(key-chord-define-global "GH" 'hsplit-window-switch-buffer)
(key-chord-define-global "JK" 'rotate-windows)
(key-chord-define-global "KL" 'swap-buffers-in-windows)
(key-chord-define-global "L:" 'transpose-windows)

#+end_src

** Line numbers

#+begin_src emacs-lisp 

(setq linum-mode-inhibit-modes-list '(eshell-mode                                                 
                                      shell-mode                                                  
                                      erc-mode                                                    
                                      jabber-roster-mode                                          
                                      jabber-chat-mode                                            
                                      gnus-group-mode                                             
                                      gnus-summary-mode                                           
                                      gnus-article-mode))                                         
                                                                                                  
(defadvice linum-on (around linum-on-inhibit-for-modes)                                           
  "Stop the load of linum-mode for some major modes."                                             
    (unless (member major-mode linum-mode-inhibit-modes-list)                                     
      ad-do-it))                                                                                  
                                                                                                  
(ad-activate 'linum-on)

#+end_src 

** Rotate text

#+begin_src emacs-lisp 

(require 'rotate-text)
(autoload 'rotate-text "rotate-text" nil t)
(autoload 'rotate-text-backward "rotate-text" nil t)

#+end_src

** artbollocks

#+begin_src emacs-lisp 

(if (require 'artbollocks-mode nil t)
    (progn
      (setq weasel-words-regex
            (concat "\\b" (regexp-opt
                           '("one of the"
                             "should"
                             "just"
                             "sort of"
                             "a lot"
                             "probably"
                             "maybe"
                             "perhaps"
                             "I think"
                             "really"
                             "pretty"
                             "maybe"
                             "nice"
                             "action"
                             "utilize"
                             "leverage") t) "\\b"))
      ;; Fix a bug in the regular expression to catch repeated words
      (setq lexical-illusions-regex "\\b\\(\\w+\\)\\W+\\(\\1\\)\\b")
      ;; Don't show the art critic words, or at least until I figure
      ;; out my own jargon
      (setq artbollocks nil)
      (add-hook 'org-capture-mode-hook 'artbollocks-mode)

      ))

#+end_src 

** miniedit

#+begin_src emacs-lisp 

(if (require 'miniedit nil t)
    (miniedit-install))

#+end_src 

** Auto-indent mode

#+begin_src emacs-lisp 

(require 'auto-indent-mode)

#+end_src

** Kill Ring
*** Kill Ring

#+begin_src emacs-lisp 


(global-set-key (kbd "C-M-y") '(lambda ()
   (interactive)
   (popup-menu 'yank-menu)))

(require 'second-sel)



#+end_src 

*** Undo-tree

#+begin_src emacs-lisp 

(require 'undo-tree)
(global-undo-tree-mode 1)

(defalias 'redo 'undo-tree-redo)

(global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
(global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】

#+end_src

*** Kill ring hook

#+begin_src emacs-lisp 

(add-hook 'before-revert-hook  (lambda () (kill-ring-save (point-min) (point-max))))

#+end_src 

** electric-pair-mode



new minor mode electric-pair-mode. When on, typing any left bracket
automatically insert the right matching bracket. Brackets includes the
ASCII ones: ""''(){}[], but also any unicode ones: «»‹›“”‘’「」『』〈〉
《》〔〕…. (➲ Matching Brackets in Unicode)


#+begin_src emacs-lisp 

(electric-pair-mode)

#+end_src 


Deleting one bracket doesn't delete the other. (If you want that,
install autopairs package. (➲ A Guide on Emacs Package System))

Exactly which brackets are auto-closed depends on the current major
mode's syntax table. ((info "(elisp) Syntax Tables"))

If you always want certain brackets be inserted in pairs, you can
customize the variable “electric-pair-pairs”. Its value should be a
Association List. ((info "(elisp) Association Lists"))

For example, the double curly bracket isn't auto-closed when in
text-mode. But if you put the following in your emacs init:

#+begin_src emacs-lisp 

(global-set-key (kbd "C-H-'") "“")     ; insert opening double curly bracket by keypad 8

;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
(setq electric-pair-pairs '(
                            (?\" . ?\")
                            (?\“ . ?\”)
                            (?\‘ . ?\’)
                            ) )



#+end_src

Now type 8 on keypad, it'll insert opening curly bracket, and the
matching one will be automatically closed by electric-pair-mode.

* Org (Organize your life)
** Org files

#+begin_src emacs-lisp 

(setq org-clock-persist-file (expand-file-name "org-clock-save" ewax-default-directory))
(setq org-id-locations-file (expand-file-name "org-id-locations" ewax-default-directory))

#+end_src 


** Org Agenda

See ~/git/.emacs.d/dkh-pre-setup.org file

** Diary location

#+begin_src emacs-lisp 

(setq diary-file "~/git/.emacs.d/.diary")

#+end_src 

> I just put a line in my .emacs, e.g.
> 
> (add-to-list 'holiday-other-holidays '(holiday-fixed 7 24 "Pioneer Day"))

That's even better! The variable holiday-local-holidays could be another choice.


** Org modules I like

#+begin_src emacs-lisp 

(require 'org-habit) ;; added by dkh

#+end_src 

** Org Latex

#+begin_src emacs-lisp

(require 'org-latex)
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")))

(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
             `("book"
               "\\documentclass{book}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
             )

(add-to-list 'org-export-latex-classes
      '("org-article"
         "\\documentclass{org-article}
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}" . "\\paragraph*{%s}")
         ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
          '("koma-article"
             "\\documentclass{scrartcl}
             [NO-DEFAULT-PACKAGES]
             [EXTRA]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(setq org-export-latex-listings 'minted)
(setq org-export-latex-custom-lang-environments
      '(
       (emacs-lisp "common-lispcode")
        ))
(setq org-export-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")))
(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-export-latex-listings 'listings)
(setq org-export-latex-custom-lang-environments
      '((emacs-lisp "common-lispcode")))
(setq org-export-latex-listings-options
      '(("frame" "lines")
        ("basicstyle" "\\footnotesize")
        ("numbers" "left")
        ("numberstyle" "\\tiny")))
(setq org-latex-to-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"))
(org-add-link-type
 "latex" nil
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span class=\"%s\">%s</span>" path desc))
    ((eq format 'latex)
     (format "\\%s{%s}" path desc)))))

#+end_src 

** org subtree cut function
#+begin_src emacs-lisp 

(define-key org-mode-map (kbd "C-c k") 'org-cut-subtree)

(setq org-export-with-section-numbers nil)
(setq org-html-include-timestamps nil)

(defun sacha/org-export-subtree-as-html-fragment ()
  (interactive)
  (org-export-region-as-html
   (org-back-to-heading)
   (org-end-of-subtree)
   t))

(setq org-link-abbrev-alist
  '(("google" . "http://www.google.com/search?q=")
    ("gmap" . "http://maps.google.com/maps?q=%s")
    ("blog" . "http://sachachua.com/blog/p/")))

#+end_src

** org-bable
#+begin_src emacs-lisp 

(org-babel-do-load-languages
    'org-babel-load-languages '((python . t) (R . t) (perl . t)))

#+end_src 


* Navigation (Driving the car)
** Ibuffer

#+begin_src emacs-lisp 

(setq ibuffer-saved-filter-groups
      (quote
       (("default"
         ("ssh"
          (or
           (name . "\\*tramp") 
           (name . "^\\*debug tramp")
           ))

         ("emacs"
          (or
           (mode . occur-mode)
           (mode . bookmark-bmenu-mode)
           (mode . help-mode)
           (name . "^\\*scratch\\*$")
           (name . "^\\*Messages\\*$")

           (name . "^\\*Compile-Log\\*$")
           (name . "^\\*Backtrace\\*$")
           (name . "^\\*info\\*$")
           (name . "^\\*Occur\\*$")
           (name . "^\\*grep\\*$")
           (name . "^\\*Process List\\*$")
           (name . "^\\*gud\\*$")
           (name . "^\\*compilation\\*$")
           (name . "^\\*Kill Ring\\*$")
           ))
         ("agenda" (or (name . "^\\*Calendar\\*$")
                       (name . "^\\*Org Agenda")
                       (name . "^\\*scratch\\* (org)$")
                       (filename . "git\\/dkh\-org")
                       (mode . muse-mode)
                       ))
         ("blog" (or 
                       (filename . "git\\/blog")
                       (filename . "git\\/netlsd")
                       ))

         ("cu agenda" (or (filename . "git\\/cu")))
         ("latex" (or (mode . latex-mode)
                      (mode . LaTeX-mode)
                      (mode . bibtex-mode)
                      (mode . reftex-mode)))
         ("irc"
          (or
           (name . "^\\*Sauron\\*$")
           (mode . garak-mode)
           (name . "^\\*Garak\\*$")
           (mode . erc-mode)
           (mode . twittering-mode)
  (name . "^\\*scratch\\* (irc)$")
         ))
         ("jabber"
          (or
          (name . "^\\*-jabber.*")
           (name . "\\*fsm-debug\\*")
          (name . "^\\*scratch\\* (jabber)$")
        ))
         ("test"
          (or
           (name . "test")
           (filename . "user\\@localhost:/home/www/htdocs")
           ))
         ("devel"
          (or
           (name . "^\\*eshell\\-devel\\-drupal\\*$")
           (name . "devel")
           (filename . "localhost:/home/www")
           (filename . "localhost:/home/user")
           ))

         ("stage"
          (or
           (name . "stage")
           (name . "staging")
           (filename . "host-staging.domain.com")
           (name . "\\*ansi\\-term\\-stage\\*")
           ))
         ("prod"
          (or
           (name . "prod")
           (filename . "host-prod.domain.com")
           ))
         ("IGP Project Trunk"
          (filename . "igp_reporting_trunk"))
         ("competitions" (or
                          (filename . "competitions")
                          (filename . "apache2\/competitions")
                          ))
         ("templates"
          (filename . "templates_trunk"))
         ("gnus" (or
                  (mode . message-mode)
                  (mode . bbdb-mode)
                  (mode . mail-mode)
                  (mode . gnus-group-mode)
                  (mode . gnus-summary-mode)
                  (mode . gnus-article-mode)
                  (name . "^\\.bbdb$")
                  (name . "^\\.newsrc-dribble")
                  (name . "^\\*gnus trace\\*$")
                  (name . "^\\*scratch\\* (gnus)$")
                  ))
         ("tool config" (or (mode . emacs-lisp-mode)
                            (filename . "\\.emacs\\.d")
                            (filename . "git\\/vinylisland")
                            (name . "^\\.conkerorrc$")
                            (filename . "org-mode-doc")
                            ))

         ("w3m" (or
                 (mode . w3m-mode)
               ;;  (name . "\\(w3m\\)$")
                  (name . "w3m")
                 ))
         ("documentation" (or (mode . Info-mode)
                              (mode . apropos-mode)
                              (mode . woman-mode)
                              (mode . help-mode)
                              (mode . Man-mode)))
         ("Magit" (name . "\*magit"))
         ))))

(setq ibuffer-never-show-predicates
      (list
       ;; Gnus development version
       "^\\*Completions\\*$"
       "^\\*nnimap"
       "^\\*gnus trace"
       "^\\*imap log"
       ;; Elim
       "^\\*elim"
       ;; others
       "^\\*Completions\\*$"
       "^\\*BBDB\\*$"
       "^\\.bbdb$"
       "^\\.newsrc-dribble$"
       ;;       "^\\*magit-"        ;; magit stuff
       "^\\*fsm-debug"     ;; jabber
       "\\.org_archive$"   ;; orgmode archive files
       "^\\*jekyll-aa\\*$" ;; local jekyll server
       "\\.diary$"
;;       "^mumamo-fetch-major-mode-setup-php-mode$"
       ))

                                        ; default groups for ibuffer
;; http://www.shellarchive.co.uk/content/emacs_tips.html#sec17


;; ibuffer, I like my buffers to be grouped
(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups
             "default")))

(setq ibuffer-never-show-predicates
      (list "\\*Completions\\*"
            "\\*vc\\*"))

;; Switching to ibuffer puts the cursor on the most recent buffer
(defadvice ibuffer (around ibuffer-point-to-most-recent) ()
  "Open ibuffer with cursor pointed to most recent buffer name"
  (let ((recent-buffer-name (buffer-name)))
    ad-do-it
    (ibuffer-jump-to-buffer recent-buffer-name)))
(ad-activate 'ibuffer)

(setq ibuffer-show-empty-filter-groups nil)

(defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups ()
                                                 activate)
  (setq ad-return-value (nreverse ad-return-value)))

(setq ibuffer-restore-window-config-on-quit t)

;; Enable ibuffer-filter-by-filename to filter on directory names too.
(eval-after-load "ibuf-ext"
  '(define-ibuffer-filter filename
     "Toggle current view to buffers with file or directory name matching QUALIFIER."
     (:description "filename"
      :reader (read-from-minibuffer "Filter by file/directory name (regexp): "))
     (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                        (buffer-local-value 'dired-directory buf))
       (string-match qualifier it))))

#+end_src 

** Iswitchb

#+begin_src emacs-lisp :tangle no

;; iswitchb ignores
;;============================================================
(add-to-list 'iswitchb-buffer-ignore "^ ")
(add-to-list 'iswitchb-buffer-ignore "*Messages*")
(add-to-list 'iswitchb-buffer-ignore "*ECB")
(add-to-list 'iswitchb-buffer-ignore "*Buffer")
(add-to-list 'iswitchb-buffer-ignore "*Completions")
(add-to-list 'iswitchb-buffer-ignore "*ftp ")
(add-to-list 'iswitchb-buffer-ignore "*bsh")
(add-to-list 'iswitchb-buffer-ignore "*jde-log")
(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")

#+end_src 


** IDO

#+begin_src emacs-lisp 

;; ido makes competing buffers and finding files easier
;; http://www.emacswiki.org/cgi-bin/wiki/InteractivelyDoThings

(setq 
  ido-save-directory-list-file "~/.emacs.d/ido.last"
)

(set `ido-ignore-files '("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./"
"\\`\\./" "\\.el?$"))

(setq ido-ignore-buffers 
  '("\\` " "^\*Mess" "^\*Back" ".*Completions" "^\*Ido" "^\*trace"
     "^\*compilation" "^\*GTAGS" "^session\.*" "^\*" "^\\*Completions\\*$"))

(setq  ido-work-directory-list '("~/git" "~/.emacs.d" "~/docs" ))



(setq  ido-case-fold  t                 ; be case-insensitive
  ido-enable-last-directory-history t ; remember last used dirs
  ido-max-work-directory-list 30   ; should be enough
  ido-max-work-file-list      50   ; remember many
)

(setq ido-use-filename-at-point 'guess)

(setq ido-use-url-at-point nil)         ; don't use url at point (annoying)

(setq ido-enable-flex-matching t)   ; don't try to be too smart

(setq ido-max-prospects 8)              ; don't spam my minibuffer

(setq  ido-confirm-unique-completion t) ; wait for RET, even with unique completion

;; when using ido, the confirmation is rather annoying...
(setq confirm-nonexistent-file-or-buffer nil)

                                          ; 50 files ought to be enough.
  (setq recentf-max-saved-items 50)
  
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
  
                                          ; IDO switch between irc channels.

;; get rid of `find-file-read-only' and replace it with something
  ;; more useful.
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

(setq ido-create-new-buffer 'always)

(setq ido-file-extensions-order '(".org" ".php" ".txt" ".py" ".xml" ".el" ".ini" ".cfg" ".cnf"))

(defun rgr/ido-erc-buffer()
(interactive)
(switch-to-buffer
 (ido-completing-read "Channel:" 
                      (save-excursion
                        (delq
                         nil
                         (mapcar (lambda (buf)
                                   (when (buffer-live-p buf)
                                     (with-current-buffer buf
                                       (and (eq major-mode 'erc-mode)
                                            (buffer-name buf)))))
                                 (buffer-list)))))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(lambda (x) (and (string-match-p "^\\.." x) x))

(lambda (a b)
      (let ((a-tramp-file-p (string-match-p ":\\'" a))
            (b-tramp-file-p (string-match-p ":\\'" b)))
        (cond
         ((and a-tramp-file-p b-tramp-file-p)
          (string< a b))
         (a-tramp-file-p nil)
         (b-tramp-file-p t)
         (t (time-less-p
             (sixth (file-attributes (concat ido-current-directory b)))
             (sixth (file-attributes (concat ido-current-directory a))))))))

(setq ido-enable-tramp-completion nil)

(setq ido-use-virtual-buffers 't)

(add-to-list 'ido-work-directory-list-ignore-regexps tramp-file-name-regexp)

(setq ido-default-buffer-method 'selected-window)

(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
    (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)

(defun ido-sort-mtime ()
      (setq ido-temp-list
            (sort ido-temp-list 
                  (lambda (a b)
                    (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                          (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                      (if (= (nth 0 ta) (nth 0 tb))
                          (> (nth 1 ta) (nth 1 tb))
                        (> (nth 0 ta) (nth 0 tb)))))))
      (ido-to-end  ;; move . files to end (again)
       (delq nil (mapcar
                  (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                  ido-temp-list))))

#+end_src                   

** Find file as root function(s)

#+begin_src emacs-lisp 

(defun find-file-as-root ()
  "Find a file as root."
  (interactive)
  (let* ((parsed (when (tramp-tramp-file-p default-directory)
                   (coerce (tramp-dissect-file-name default-directory)
                           'list)))
         (default-directory
           (if parsed
               (apply 'tramp-make-tramp-file-name
                      (append '("sudo" "root") (cddr parsed)))
             (tramp-make-tramp-file-name "sudo" "root" "localhost"
                                         default-directory))))
    (call-interactively 'find-file)))

(defun toggle-alternate-file-as-root (&optional filename)
  "Toggle between the current file as the default user and as root."
  (interactive)
  (let* ((filename (or filename (buffer-file-name)))
         (parsed (when (tramp-tramp-file-p filename)
                   (coerce (tramp-dissect-file-name filename)
                           'list))))
    (unless filename
      (error "No file in this buffer."))

    (find-alternate-file
     (if (equal '("sudo" "root") (butlast parsed 2))
         ;; As non-root
         (if (or
              (string= "localhost" (nth 2 parsed))
              (string= (system-name) (nth 2 parsed)))
             (car (last parsed))
           (apply 'tramp-make-tramp-file-name
                  (append (list tramp-default-method nil) (cddr parsed))))

       ;; As root
       (if parsed
           (apply 'tramp-make-tramp-file-name
                  (append '("sudo" "root") (cddr parsed)))
         (tramp-make-tramp-file-name "sudo" nil nil filename))))))

(defun th-find-file-sudo (file)
  "Opens FILE with root privileges."
  (interactive "F")
  (set-buffer (find-file (concat "/sudo::" file))))

(defadvice find-file (around th-find-file activate)
  "Open FILENAME using tramp's sudo method if it's read-only."
  (if (and (not (file-writable-p (ad-get-arg 0)))
       (not (file-remote-p (ad-get-arg 0)))
       (y-or-n-p (concat "File "
                 (ad-get-arg 0)
                 " is read-only.  Open it as root? ")))
      (th-find-file-sudo (ad-get-arg 0))
    ad-do-it))

#+end_src 

** filecache

#+begin_src emacs-lisp 

(require 'filecache)

(defun file-cache-ido-find-file (file)
  "Using ido, interactively open file from file cache'.
First select a file, matched using ido-switch-buffer against the contents
in `file-cache-alist'. If the file exist in more than one
directory, select directory. Lastly the file is opened."
  (interactive (list (file-cache-ido-read "File: "
                                          (mapcar
                                           (lambda (x)
                                             (car x))
                                           file-cache-alist))))
  (let* ((record (assoc file file-cache-alist)))
    (find-file
     (expand-file-name
      file
      (if (= (length record) 2)
          (car (cdr record))
        (file-cache-ido-read
         (format "Find %s in dir: " file) (cdr record)))))))

(defun file-cache-ido-read (prompt choices)
  (let ((ido-make-buffer-list-hook
         (lambda ()
           (setq ido-temp-list choices))))
    (ido-read-buffer prompt)))
(add-to-list 'file-cache-filter-regexps "docs/html")
(add-to-list 'file-cache-filter-regexps "\\.svn-base$")
(add-to-list 'file-cache-filter-regexps "\\.dump$")

#+end_src 

** Imenu

#+begin_src emacs-lisp 

(setq imenu-auto-rescan 't)

#+end_src 

** Smex
smex-save-file is a variable defined in `smex.el'.

#+begin_src emacs-lisp 

(setq smex-save-file "~/.emacs.d/.smex-items")

#+end_src 

** Registers

#+TITLE:   Starter Kit Registers
#+OPTIONS: toc:nil num:nil ^:nil

*** Starter Kit Registers
Registers allow you to jump to a file or other location quickly. Use
=C-x r j= followed by the letter of the register (i for =init.el=, s
for this file) to jump to it.

You should add registers here for the files you edit most often.

#+srcname: starter-kit-registers

Documentation:
Alist of elements (NAME . CONTENTS), one for each Emacs register.
NAME is a character (a number).  CONTENTS is a string, number, marker, list
or a struct returned by `registerv-make'.
A list of strings represents a rectangle.
A list of the form (file . FILE-NAME) represents the file named FILE-NAME.
A list of the form (file-query FILE-NAME POSITION) represents
 position POSITION in the file named FILE-NAME, but query before
 visiting it.
A list of the form (WINDOW-CONFIGURATION POSITION)
 represents a saved window configuration plus a saved value of point.
A list of the form (FRAME-CONFIGURATION POSITION)
 represents a saved frame configuration plus a saved value of point.
;; (cond ((file-exists-p (expand-file-name "~/work/rldev")

#+begin_src emacs-lisp 

(dolist (r `( (?e (file . "~/git/ewax/dkh-core.org"))))
             (set-register (car r) (cadr r)))

#+end_src 


** Command aliases

#+begin_src emacs-lisp 

(defalias 'tc 'dkh/toggle-chrome)
(defalias 'll 'load-library)  ;; dynamic, instead of require
(defalias 'es 'eshell)
(defalias 'r 'list-registers)
(defalias 'ev 'eval-buffer)
(defalias 'td 'toggle-debug-on-error)
(defalias 'sc 'sql-connect)

(defalias 'j 'jabber)

(defalias 'iw 'ispell-word)
;; (defalias 'fm 'flyspell-mode)

(defalias 'egi 'el-get-install)
(defalias 'pi 'package-install)
(defalias 'ai 'auto-install-from-emacswiki)
(defalias 'bc  'bbdb-create)
(defalias 'bb  'bbdb)

(defalias 'qrr 'query-replace-regexp)

(defalias 'rn 'wdired-change-to-wdired-mode) ; rename file in dired
(defalias 'g 'grep)
(defalias 'gf 'grep-find)
(defalias 'fd 'find-dired)
(defalias 'ntr 'narrow-to-region)
(defalias 'lml 'list-matching-lines)
(defalias 'dml 'delete-matching-lines)
(defalias 'dnml 'delete-non-matching-lines)
(defalias 'sl 'sort-lines)
(defalias 'dtw 'delete-trailing-whitespace)
(defalias 'lcd 'list-colors-display)
(defalias 'rb 'revert-buffer)
(defalias 'rs 'replace-string)
(defalias 'rr 'reverse-region)
(defalias 'lf 'load-file)
(defalias 'man 'woman)

(defalias 'sh 'shell)
(defalias 'ps 'powershell)
(defalias 'fb 'flyspell-buffer)
(defalias 'sbc 'set-background-color)

(defalias 'rof 'recentf-open-files)

; elisp
(defalias 'eb 'eval-buffer)
(defalias 'er 'eval-region)
(defalias 'ed 'eval-defun)
(defalias 'ele 'eval-last-sexp)
(defalias 'eis 'elisp-index-search)

; modes
(defalias 'hm 'html-mode)
(defalias 'tm 'text-mode)
(defalias 'elm 'emacs-lisp-mode)
(defalias 'vbm 'visual-basic-mode)
(defalias 'vlm 'visual-line-mode)
(defalias 'wsm 'whitespace-mode)
(defalias 'gwsm 'global-whitespace-mode)
(defalias 'om 'org-mode)
(defalias 'ssm 'shell-script-mode)
(defalias 'cc 'calc)
(defalias 'dsm 'desktop-save-mode)

(defalias 'acm 'auto-complete-mode)

(defalias 'eu 'eudc-query-form)
#+end_src 
    
* Documentation
** Self-documentation
*** Which func mode

Which-func is a minor-mode that will add the function point is inside
to the mode-line. This is mainly useful if you are looking at large
functions, but it could also be nice if you use vertical
splits. Which-func mode is built into emacs, so you have to go through
very little work to enable it.

This package prints name of function where your current point is
located in mode line. It assumes that you work with imenu package and
imenu--index-alist is up to date.

#+begin_src emacs-lisp

(which-function-mode t)
(setq which-func-modes t)
(which-func-mode 1)

#+end_src 

*** Man

#+begin_src emacs-lisp 
(setq Man-switches "-a")

(defadvice Man-build-page-list (after reverse-page-list activate)
  (setq Man-page-list (nreverse Man-page-list)))

#+end_src 
  
*** 25.16 Using (info "(emacs)Dialog Boxes")

Don't use dialog boxes to ask questions

#+begin_src emacs-lisp 

(setq use-dialog-box nil)

#+end_src 

Don't use a file dialog to ask for files

#+begin_src emacs-lisp 

(setq use-file-dialog nil)

#+end_src 

** Google Definitions

#+begin_src emacs-lisp 

(require 'mm-url)
(defun google-define-word-or-phrase (query)
  (interactive "sInsert word or phrase to search: ")
  (let* ((url (concat "http://www.google.com.pe/search?hl=en&q=define%3A"
              (replace-regexp-in-string " " "+" query)))
     (definition
       (save-excursion
         (with-temp-buffer
           (mm-url-insert url)
           (goto-char (point-min))
           (if (search-forward "No definitions found of " nil t)
           "No definitions found"
         (buffer-substring (search-forward "<li>") (- (search-forward "<") 1)))))))
    (message "%s: %s" query definition)))

#+end_src 

** Eldoc

#+begin_src emacs-lisp 

(eldoc-mode t)

#+end_src 


* Utilities (tools)

** Tramp

*** General
    
#+begin_src emacs-lisp 

(setq tramp-default-method "ssh")

(setq tramp-default-user "username")

(setq tramp-debug-buffer t)
(setq tramp-verbose 10)

(setq password-cache nil)
;;(setq password-cache-expiry nil)

(setq tramp-backup-directory-alist backup-directory-alist)


#+end_src 

*** Clean up tramp before saving desktop

#+begin_src emacs-lisp 

(add-hook 'desktop-save-hook 'tramp-cleanup-all-buffers)



#+end_src 

** Shells
*** Eshell

#+begin_src emacs-lisp :tangle no

(setq eshell-directory-name "~/git/.emacs.d/eshell/")

;;       (starter-kit-load "eshell")

;;This makes Eshell’s ‘ls’ file names RET-able. Yay!
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file (buffer-substring-no-properties
                     (previous-single-property-change point 'help-echo)
                     (next-single-property-change point 'help-echo))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))

  (defun ted-eshell-ls-find-file ()
          (interactive)
    (let ((fname (buffer-substring-no-properties
              (previous-single-property-change (point) 'help-echo)
              (next-single-property-change (point) 'help-echo))))
            ;; Remove any leading whitespace, including newline that might
            ;; be fetched by buffer-substring-no-properties
      (setq fname (replace-regexp-in-string "^[ \t\n]*" "" fname))
            ;; Same for trailing whitespace and newline
      (setq fname (replace-regexp-in-string "[ \t\n]*$" "" fname))
      (cond
       ((equal "" fname)
        (message "No file name found at point"))
       (fname
        (find-file fname)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Here is a cool function by MilanZamazal? that brings lots of Debian commands together. Note how options are defined and documented using eshell-eval-using-options.

    (defun eshell/deb (&rest args)
      (eshell-eval-using-options
       "deb" args
       '((?f "find" t find "list available packages matching a pattern")
         (?i "installed" t installed "list installed debs matching a pattern")
         (?l "list-files" t list-files "list files of a package")
         (?s "show" t show "show an available package")
         (?v "version" t version "show the version of an installed package")
         (?w "where" t where "find the package containing the given file")
         (nil "help" nil nil "show this usage information")
         :show-usage)
       (eshell-do-eval
        (eshell-parse-command
         (cond
          (find
           (format "apt-cache search %s" find))
          (installed
           (format "dlocate -l %s | grep '^.i'" installed))
          (list-files
           (format "dlocate -L %s | sort" list-files))
          (show
           (format "apt-cache show %s" show))
          (version
           (format "dlocate -s %s | egrep '^(Package|Status|Version):'" version))
          (where
           (format "dlocate %s" where))))
        t)))

;; aliases

(defalias 'open 'find-file)
(defalias 'openo 'find-file-other-window)

(defun eshell/emacs (file)
          (find-file file))


(setq eshell-aliases-file "~/git/.emacs.d/eshell/alias")

  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)

(defvar explicit-su-file-name "/bin/su")
(defvar explicit-su-args '("-"))

(defun su (&optional buffer)
  (interactive
   (list
    (and current-prefix-arg
     (prog1
         (read-buffer "SU buffer: "
              (generate-new-buffer-name "*su*"))
       (if (file-remote-p default-directory)
       ;; It must be possible to declare a local default-directory.
       (setq default-directory
             (expand-file-name
          (read-file-name
           "Default directory: " default-directory default-directory
           t nil 'file-directory-p))))))))
  (setq buffer (get-buffer-create (or buffer "*su*")))
  ;; Pop to buffer, so that the buffer's window will be correctly set
  ;; when we call comint (so that comint sets the COLUMNS env var properly).
  (pop-to-buffer buffer)
  (unless (comint-check-proc buffer)
    (let* ((prog explicit-su-file-name)
       (name (file-name-nondirectory prog))
       (startfile (concat "~/.emacs_" name))
       (xargs-name (intern-soft (concat "explicit-" name "-args"))))
  (apply 'make-comint-in-buffer "su" buffer prog
         (if (file-exists-p startfile) startfile)
         (if (and xargs-name (boundp xargs-name))
         (symbol-value xargs-name)
       '("-i")))
  (shell-mode)))
  buffer)

#+end_src 

*** AnsiTerm

In the above mentioned article Joseph wrote a nice little bit of elisp
to get to a running ansi-term efficiently, by hitting F2. The nice
thing about it is that it does what I mean:

 1. If I'm already in an ansi-term, but it's called "*ansi-term*"
    rename it.
 2. If I'm already in an ansi-term, but it's called something else,
    start a new ansi-term called "*ansi-term*"
 3. If I'm in another non-terminal buffer, switch to a buffer called
    "*ansi-term*" or create a new one if it doesn't exist

There's one more catch though, as Joseph explains, an ansi-term can be
considered "stopped" such that it is no longer running but the buffer
still exists. In that case I don't want the third rule to switch me to
a defunct terminal, so instead I want it to kill the buffer and create
a new ansi-term. Here is my enhanced elisp:

#+begin_src emacs-lisp 

(defun visit-ansi-term ()
  (interactive)
  "Creates an ansi-term and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))
;;        (default-directory "/home/www")
        (term-cmd "/bin/bash")
)
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (ansi-term term-cmd)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))))))

(global-set-key (kbd "C-x <f2>") 'visit-ansi-term)

#+end_src 

Localhost

For terminal emulation on the local host, this simple function names
the buffers *localhost*, *localhost<2>*, etc…

#+begin_src emacs-lisp 

(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))


(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))

#+end_src 

For remote hosts, an additional function was required since the
ansi-term command doesn’t support additional arguments:

#+begin_src emacs-lisp 

;; Use this for remote so I can specify command line arguments
(defun remote-term (new-buffer-name cmd &rest switches)
  (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
  (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
  (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name cmd nil switches))
  (set-buffer term-ansi-buffer-name)
  (term-mode)
  (term-char-mode)
  (term-set-escape-char ?\C-x)
  (switch-to-buffer term-ansi-buffer-name))

#+end_src 

You can then define a new function in your init file for each host you
frequently visit with it’s own buffer name and connection parameters:

#+begin_src emacs-lisp 

(defun open-prod ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@prod.domain.com"))

(defun open-stage ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@host-staging.domain.com"))

(defun open-test ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@localhost"))


(defun open-devel ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@localhost"))

(global-set-key (kbd "C-x <f6>") 'open-devel)
(global-set-key (kbd "C-x <f7>") 'open-test)
(global-set-key (kbd "C-x <f8>") 'open-stage)
(global-set-key (kbd "C-x <f9>") 'open-prod)

#+end_src 

*** Shell functions

#+begin_src emacs-lisp 

(defun shell-command-on-region-to-string (start end command)                    
  (with-output-to-string                                                        
    (shell-command-on-region start end command standard-output)))               
                                                                                
(defun shell-command-on-region-with-output-to-end-of-buffer (start end command) 
  (interactive                                                                  
   (let ((command (read-shell-command "Shell command on region: ")))            
     (if (use-region-p)                                                         
         (list (region-beginning) (region-end) command)                         
       (list (point-min) (point-max) command))))                                
  (save-excursion                                                               
    (goto-char (point-max))                                                     
    (insert (shell-command-on-region-to-string start end command))))

(defun shell-here ()
  "Open a shell in `default-directory'."
  (interactive)
  (let ((dir (expand-file-name default-directory))
        (buf (or (get-buffer "*shell*") (shell))))
    (goto-char (point-max))
    (if (not (string= (buffer-name) "*shell*"))
        (switch-to-buffer-other-window buf))
    (message list-buffers-directory)
    (if (not (string= (expand-file-name list-buffers-directory) dir))
        (progn (comint-send-string (get-buffer-process buf)
                                   (concat "cd \"" dir "\"\r"))
               (setq list-buffers-directory dir)))))

(setq ansi-color-names-vector
      ["black" "tomato" "PaleGreen2" "gold1"
       "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])

(setq ansi-color-map (ansi-color-make-color-map))

(add-hook 'shell-mode-hook 
     '(lambda () (toggle-truncate-lines 1)))
(setq comint-prompt-read-only t)

(defvar my-local-shells
  '("*shell0*" "*shell1*" "*shell2*" "*shell3*" "*music*"))
(defvar my-remote-shells
  '("*dhaley*" "*pup*" "*pup-staging*" "*heaven2*" "*heaven3*"))
(defvar my-shells (append my-local-shells my-remote-shells))

(custom-set-variables
 '(comint-scroll-to-bottom-on-input t)  ; always insert at the bottom
 ;; '(comint-completion-autolist t)     ; show completion list when ambiguous
 '(comint-input-ignoredups t)           ; no duplicates in command history
 '(comint-buffer-maximum-size 20000)    ; max length of the buffer in lines
 '(comint-prompt-read-only nil)         ; if this is t, it breaks shell-command
 '(comint-get-old-input (lambda () "")) ; what to run when i press enter on a
                                        ; line above the current prompt
 '(protect-buffer-bury-p nil)
)

;; truncate buffers continuously
(add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

(defun make-my-shell-output-read-only (text)
  "Add to comint-output-filter-functions to make stdout read only in my shells."
  (if (member (buffer-name) my-shells)
      (let ((inhibit-read-only t)
            (output-end (process-mark (get-buffer-process (current-buffer)))))
        (put-text-property comint-last-output-start output-end 'read-only t))))
(add-hook 'comint-output-filter-functions 'make-my-shell-output-read-only)

(defun my-dirtrack-mode ()
  "Add to shell-mode-hook to use dirtrack mode in my shell buffers."
  (when (member (buffer-name) my-shells)
    (shell-dirtrack-mode 0)
    (set-variable 'dirtrack-list '("^.*[^ ]+:\\(.*\\)>" 1 nil))
    (dirtrack-mode 1)))
(add-hook 'shell-mode-hook 'my-dirtrack-mode)

; interpret and use ansi color codes in shell output windows
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

(defun set-scroll-conservatively ()
  "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
  (set (make-local-variable 'scroll-conservatively) 10))
(add-hook 'shell-mode-hook 'set-scroll-conservatively)

;; i think this is wrong, and it buries the shell when you run emacsclient from
;; it. temporarily removing.
;; (defun unset-display-buffer-reuse-frames ()
;;   "Add to shell-mode-hook to prevent switching away from the shell buffer
;; when emacsclient opens a new buffer."
;;   (set (make-local-variable 'display-buffer-reuse-frames) t))
;; (add-hook 'shell-mode-hook 'unset-display-buffer-reuse-frames)

(require 'protbuf)
(add-hook 'shell-mode-hook 'protect-process-buffer-from-kill-mode)


(defun make-comint-directory-tracking-work-remotely ()
  "Add this to comint-mode-hook to make directory tracking work
while sshed into a remote host, e.g. for remote shell buffers
started in tramp. (This is a bug fix backported from Emacs 24:
http://comments.gmane.org/gmane.emacs.bugs/39082"
  (set (make-local-variable 'comint-file-name-prefix)
       (or (file-remote-p default-directory) "")))
(add-hook 'comint-mode-hook 'make-comint-directory-tracking-work-remotely)

(defun enter-again-if-enter ()
  "Make the return key select the current item in minibuf and shell history isearch.
An alternate approach would be after-advice on isearch-other-meta-char."
  (when (and (not isearch-mode-end-hook-quit)
             (equal (this-command-keys-vector) [13])) ; == return
    (cond ((active-minibuffer-window) (minibuffer-complete-and-exit))
          ((member (buffer-name) my-shells) (comint-send-input)))))
(add-hook 'isearch-mode-end-hook 'enter-again-if-enter)

(defadvice comint-previous-matching-input
    (around suppress-history-item-messages activate)
  "Suppress the annoying 'History item : NNN' messages from shell history isearch.
If this isn't enough, try the same thing with
comint-replace-by-expanded-history-before-point."
  (let ((old-message (symbol-function 'message)))
    (unwind-protect
      (progn (fset 'message 'ignore) ad-do-it)
    (fset 'message old-message))))

(defadvice comint-send-input (around go-to-end-of-multiline activate)
  "When I press enter, jump to the end of the *buffer*, instead of the end of
the line, to capture multiline input. (This only has effect if
`comint-eol-on-send' is non-nil."
  (flet ((end-of-line () (end-of-buffer)))
    ad-do-it))

;; not sure why, but comint needs to be reloaded from the source (*not*
;; compiled) elisp to make the above advise stick.
(load "comint.el.gz")

;; for other code, e.g. emacsclient in TRAMP ssh shells and automatically
;; closing completions buffers, see the links above.

#+end_src 

*** Improving ansi-term

I use ansi-term quite a bit. Why leave Emacs to have a terminal?
However, there were a few issues I had with ansi-term that were quite
annoying.

However, because Emacs is awesome, the issues were pretty easily
fixed.

First things first, I didn't like that running `exit` in my terminal
left a useless buffer around. A little searching around online, and I
found the following solution, using defadvice:

#+begin_src emacs-lisp :tangle no

    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
            ad-do-it
            (kill-buffer buffer))
        ad-do-it))
    (ad-activate 'term-sentinel)

#+end_src 
    
This tells term (which is used by ansi-term) to kill the buffer after
the terminal is exited. The original I found online also killed the
frame, but I use one frame with multiple windows, so I removed that
call.

Secondly, I always use bash. I don't need ansi-term to ask me which
shell to use every time I invoke it. Once again, defadvice to the
rescue. I wrote the following bit of advice that lets the user set the
shell program to a variable, then advise ansi-term to always use that
(and not ask). The defvar could just as easily be made a defcustom,
and perhaps one day I'll do that. For now, though, this works for me.


#+begin_src emacs-lisp :tangle no

    (defvar my-term-shell "/bin/bash")
    (defadvice ansi-term (before force-bash)
      (interactive (list my-term-shell)))
    (ad-activate 'ansi-term)

#+end_src     
    
Another issue I has was with the display of certain characters and
control codes. The following hook sets the term to use UTF-8.

#+begin_src emacs-lisp 

    (defun my-term-use-utf8 ()
      (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
    (add-hook 'term-exec-hook 'my-term-use-utf8)

#+end_src

Next, I wanted urls that show up in my terminal (via man pages, help,
info, errors, etc) to be clickable. This was solved very easily by
hooking `goto-address-mode` into ansi-term. To make add more hooks
into ansi-term easier in the future, I defined my own hook function,
currently with just `goto-address-mode`:

#+begin_src emacs-lisp :tangle no

    (defun my-term-hook ()
      (goto-address-mode))

#+end_src       

Then added my hook to term-mode-hook:

#+begin_src emacs-lisp 

    (add-hook 'term-mode-hook 'my-term-hook)

#+end_src 
    
After this, I realized that C-y doesn't work in ansi-term like you'd
expect. It pastes into the buffer, sure, but the text doesn't get sent
to the process. So if you copy a bash command, then C-y it into the
buffer, nothing happens when you press enter (because, as far as
ansi-term is concerned, no text was entered at the prompt). The
following function will paste whatever is copied into ansi-term in
such a way that the process can, well, process it:

#+begin_src emacs-lisp 

    (defun my-term-paste (&optional string)
     (interactive)
     (process-send-string
      (get-buffer-process (current-buffer))
      (if string string (current-kill 0))))

#+end_src 
      
Then I just add the binding to my hook from before, making it this:

#+begin_src emacs-lisp :tangle no

    (defun my-term-hook ()
      (goto-address-mode)
      (define-key term-raw-map "\C-y" 'my-term-paste))

#+end_src 
      
Since I've already hooked it into 'term-mode-hook, there's no reason
to do so again. Simply reevaluate the function.

Finally, I've recently been using the [[http://ethanschoonover.com/solarized][solarized theme]], both in Emacs
and in my terminals. However, ansi-term wasn't quite playing well with
this. The colors were wrong in ansi-term, even though they were right
in the rest of Emacs. A friend and co-worker of mine wrote the
following bit of elisp that, when added to the term-mode-hook, makes
ansi-term use the right colors for solarized. (Note that this is only
needed if you use solarized and your ansi-term doesn't look right.
Installing solarized, either in emacs or on your system, is beyond the
scope of this post. However, I should mention that you can find it via
M-x package-list-packages. The one you probably want is
`color-theme-solarized `.) So, adding the elisp he wrote to my
my-term-hook results in this:

#+begin_src emacs-lisp 

    (defun my-term-hook ()
      (goto-address-mode)
      (define-key term-raw-map "\C-y" 'my-term-paste)
      (let ((base03  "#002b36")
            (base02  "#073642")
            (base01  "#586e75")
            (base00  "#657b83")
            (base0   "#839496")
            (base1   "#93a1a1")
            (base2   "#eee8d5")
            (base3   "#fdf6e3")
            (yellow  "#b58900")
            (orange  "#cb4b16")
            (red     "#dc322f")
            (magenta "#d33682")
            (violet  "#6c71c4")
            (blue    "#268bd2")
            (cyan    "#2aa198")
            (green   "#859900"))
        (setq ansi-term-color-vector
              (vconcat `(unspecified ,base02 ,red ,green ,yellow ,blue
                                     ,magenta ,cyan ,base2)))))

#+end_src 
                                     
Again, its already added to my term-mode-hook, so reevaluate and off
we go.

So there you have it. With a little bit of elisp, ansi-term is much
more streamlined (in my opinion) and better to work with. Hopefully
this information will help others in the future. Posted by [[https://profiles.google.com/111299187812335372965][Brian Zwahr]]
at [[http://emacs-journey.blogspot.com/2012/06/improving-ansi-term.html][12:02 PM]] [[http://www.blogger.com/email-post.g?blogID%3D3610844988855884806&postID%3D7346863015606057752][# ]] [[http://www.blogger.com/post-edit.g?blogID%3D3610844988855884806&postID%3D7346863015606057752&from%3Dpencil][# ]] Labels: [[http://emacs-journey.blogspot.com/search/label/ansi-term][ansi-term]], [[http://emacs-journey.blogspot.com/search/label/emacs][emacs]], [[http://emacs-journey.blogspot.com/search/label/hook][hook]], [[http://emacs-journey.blogspot.com/search/label/term][term]], [[http://emacs-journey.blogspot.com/search/label/terminal][terminal]],
[[http://emacs-journey.blogspot.com/search/label/utf-8][utf-8]], [[http://emacs-journey.blogspot.com/search/label/utf8][utf8]]


*** set up shell

M-x shell runs ~/.emacs_SHELLNAME (or ~/.emacs.d/init_SHELLNAME.sh) on
startup. True ‪#Emacs‬ knights ought to know that.

On the other hand running M-x ansi-term just executes your regular
.zshrc/.bashrc/etc. And one more thing - shell != terminal emulator

** Dired

** [[http://www.emacswiki.org/cgi-bin/wiki?DiredReuseDirectoryBuffer][Resuse directory buffer]]

#+begin_src emacs-lisp :tangle no

(put 'dired-find-alternate-file 'disabled nil)

#+end_src 

** General

#+begin_src emacs-lisp :tangle no

;; enable the use of the command `dired-find-alternate-file'
;; without confirmation
(put 'dired-find-alternate-file 'disabled nil)

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map "b" 'my-browser-find-file)))

(defun my-dired-browser-find-file ()
  "Dired function to view a file in a web browser"
  (interactive)
  (browse-url (browse-url-file-url (dired-get-filename))))

(add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))

;; (setq dired-omit-file "^\\.?#\\|^\\.$\\|^\\.\\.$")

(setq dired-omit-files 
      (rx (or (seq bol (? ".") "#")         ;; emacs autosave files 
              (seq "~" eol)                 ;; backup-files 
              (seq bol "svn" eol)           ;; svn dirs 
;;              (seq ".git" eol)
;;              (seq bol "." (not (any "."))) ;; dot-files                                                                                                                                                                    
;;              (seq ".pyc" eol)
              )))
(setq dired-omit-extensions 
      (append dired-latex-unclean-extensions 
              dired-bibtex-unclean-extensions 
              dired-texinfo-unclean-extensions))
(add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))

(defun 2zip ()
  "Zip the current file/dir in `dired'.
If multiple files are marked, only zip the first one.
Require unix zip commandline tool."
  (interactive)
  (require 'dired)
  (let ( (fileName (elt (dired-get-marked-files) 0))  )
    (shell-command (format "zip -r '%s.zip' '%s'" (file-relative-name fileName) (file-relative-name fileName)))
    ))

(autoload 'dired-jump "dired-x" "Jump to dired corresponding current buffer.") 
(autoload 'dired-jump-other-window "dired-x" "jump to dired in other window.")


(setq toggle-diredp-find-file-reuse-directory t)

#+end_src 

** Gnus

*** Settings

#+begin_src emacs-lisp 

;;(setq check-mail-boxes (quote ("~/Messages/incoming/mail\\..*\\.spool")))
;; (setq check-mail-summary-function (quote check-mail-box-summary))

(setq gnus-activate-level 2)
(setq gnus-after-getting-new-news-hook (quote (gnus-group-list-groups gnus-group-save-newsrc gnus-display-time-event-handler)))


 
 (setq gnus-agent-expire-all t)
 (setq gnus-agent-expire-days 14)
 (setq gnus-agent-go-online t)
 (setq gnus-agent-mark-unread-after-downloaded nil)
 (setq gnus-agent-synchronize-flags t)
;; (setq gnus-alias-default-identity "cu)
;; (setq gnus-alias-identity-alist (quote (("cu" "" nil "" nil "" "")
;; ("VinylIsland" "" "\"Damon Haley\" <dkh@member.fsf.org>" "University of
;; Colorado" nil "" "Damon Haley
;; Vinyl Island Society
;; http://www.vinylisland.org") ("Fang Wax Club" "" "\"Damon Haley\" <vinylisl@ssl-mail.com>" "New Artisans LLC" nil "" ""))))
;; (setq gnus-alias-identity-rules (quote (("Ledger Mailing List" ("To" "ledger-cli@googlegroups\\.com" current) "NewArtisans") ("Emacs Mailing Lists" ("To" "emacs" current) "NewArtisans") ("Emacs Newsgroups" ("Newsgroups" "emacs" current) "NewArtisans") ("BoostPro Mail" ("From" "@boostpro\\.com" current) "BoostPro") ("BoostPro Clients" ("To" "@\\(ti\\)\\.com" current) "BoostPro") ("BoostPro Clients (Copied)" ("Cc" "@\\(ti\\)\\.com" current) "BoostPro") ("C++, LLVM, Boost, and Clang Groups" ("Newsgroups" "\\(c\\+\\+\\|clang\\|llvm\\|[Bb]oost\\|[Rr]yppl\\)" current) "BoostPro") ("C++, LLVM, Boost, and Clang Mailing Lists" ("To" "\\(c\\+\\+\\|clang\\|llvm\\|[Bb]oost\\|[Rr]yppl\\|llvm\\|cfe\\)" current) "BoostPro"))))
;; (setq gnus-alias-override-user-mail-address t)
;; (setq gnus-alias-unknown-identity-rule (quote error))


(setq gnus-always-read-dribble-file t)
 (setq gnus-article-date-lapsed-new-header t)
 (setq gnus-article-update-date-headers nil)
 (setq gnus-asynchronous t)
 (setq gnus-check-new-newsgroups nil)
 (setq gnus-completing-read-function (quote gnus-ido-completing-read))

 (setq gnus-default-adaptive-score-alist (quote ((gnus-dormant-mark (from 20) (subject 100)) (gnus-ticked-mark (subject 30)) (gnus-read-mark (subject 30)) (gnus-del-mark (subject -150)) (gnus-catchup-mark (subject -150)) (gnus-killed-mark (subject -1000)) (gnus-expirable-mark (from -1000) (subject -1000)))))
 (setq gnus-default-article-saver (quote gnus-summary-write-to-file))


(setq gnus-gcc-mark-as-read t)
 (setq gnus-generate-tree-function (quote gnus-generate-horizontal-tree))
 (setq gnus-group-default-list-level 2)
 (setq gnus-group-line-format "%S%p%P%M%5y: %(%B%G%B%)
")

;; gnus-group-line-format "%M%S%p%P%(%-40,40G%)%-5uy %ud\n"


 (setq gnus-group-mode-hook (quote (gnus-topic-mode gnus-agent-mode)))

;; (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
;; (add-hook 'gnus-group-mode-hook 'hl-line-mode)


(setq gnus-group-use-permanent-levels t)
 (setq gnus-harvest-sender-alist (quote
 ((".*@\\(cu\\|colorado\\|ti\\)\\.edu" . damon\.haley@colorado\.edu) (".*@fsf\\.org" . dkh@member\.fsf\.org))))

 (setq gnus-ignored-mime-types (quote ("application/x-pkcs7-signature" "application/ms-tnef" "text/x-vcard")))
 (setq gnus-interactive-exit (quote quiet))
 (setq gnus-large-newsgroup 4000)
;; when to prompt for how many
 ;; gnus-large-newsgroup 100
;; (setq gnus-large-newsgroup 20)
;; (setq gnus-local-domain "boostpro.com")
 (setq gnus-mailing-list-groups "\\`\\(list\\|wg21\\)\\.")
 (setq gnus-mark-unpicked-articles-as-read t)
;; (setq gnus-message-archive-group (quote ((format-time-string "sent.%Y"))))
 (setq gnus-message-replyencrypt nil)

;; (setq gnus-parameters (quote (("list\\." (subscribed . t) (gcc-self . t)) ("list\\.wg21\\.\\(.*\\)" (to-address . "c++std-\\1@accu.org") (to-list . "c++std-\\1@accu.org") (gcc-self . t) (gnus-list-identifiers "\\[c\\+\\+std-.+?\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "c++std-\\1@accu.org") (header :contains "list-id" "<c++std-\\1.accu.org>")))) ("\\(johnw\\|INBOX\\)" (total-expire . t) (expiry-target . "mail.archive")) ("johnw" (expiry-wait . immediate)) ("INBOX" (expiry-wait . 14)) ("mail\\." (gnus-use-scoring nil)) ("mail\\.archive" (gnus-summary-line-format "%«%U%R %uS %ur %»%(%*%-14,14f   %4u&size; %1«%B%s%»%)
;; ")) ("list\\.ledger\\.devel" (to-address . "ledger-cli@googlegroups.com") (to-list . "ledger-cli@googlegroups.com") (gcc-self . t) (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "ledger-cli@googlegroups.com") (header :contains "list-id" "<ledger-cli.googlegroups.com>")))) ("list\\.bahai\\.tarjuman" (to-address . "TARJUMAN-LIST@listserv.buffalo.edu") (to-list . "TARJUMAN-LIST@listserv.buffalo.edu") (sieve header :contains ("To" "From" "Cc" "Sender") "TARJUMAN-LIST@LISTSERV.BUFFALO.EDU")) ("list\\.emacs\\.devel" (to-address . "emacs-devel@gnu.org") (to-list . "emacs-devel@gnu.org") (total-expire . t) (expiry-wait . 90) (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "emacs-devel@gnu.org") (header :contains "list-id" "<emacs-devel.gnu.org>")))) ("list\\.emacs\\.help" (to-address . "help-gnu-emacs@gnu.org") (to-list . "help-gnu-emacs@gnu.org") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "help-gnu-emacs@gnu.org") (header :contains "list-id" "<help-gnu-emacs.gnu.org>")))) ("list\\.emacs\\.bugs" (to-list . "bug-gnu-emacs@gnu.org") (sieve anyof ((header :matches ("To" "From" "Cc" "Sender") "*@debbugs.gnu.org") (header :contains ("To" "From" "Cc" "Sender") "bug-gnu-emacs@gnu.org") (header :contains "list-id" "<bug-gnu-emacs.gnu.org>")))) ("list\\.emacs\\.diffs" (to-address . "emacs-diffs@gnu.org") (to-list . "emacs-diffs@gnu.org") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "emacs-diffs@gnu.org") (header :contains "list-id" "<emacs-diffs.gnu.org>")))) ("list\\.emacs\\.elpa\\.diffs" (to-address . "emacs-elpa-diffs@gnu.org") (to-list . "emacs-diffs@gnu.org") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "emacs-elpa-diffs@gnu.org") (header :contains "list-id" "<emacs-elpa-diffs.gnu.org>")))) ("list\\.emacs\\.buildstatus" (to-address . "emacs-buildstatus@gnu.org") (to-list . "emacs-buildstatus@gnu.org") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "emacs-buildstatus@gnu.org") (header :contains "list-id" "<emacs-buildstatus.gnu.org>")))) ("list\\.emacs\\.sources" (to-address . "gnu-emacs-sources@gnu.org") (to-list . "gnu-emacs-sources@gnu.org") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "gnu-emacs-sources@gnu.org") (header :contains "list-id" "<gnu-emacs-sources.gnu.org>")))) ("list\\.emacs\\.orgmode" (to-address . "emacs-orgmode@gnu.org") (to-list . "emacs-orgmode@gnu.org") (list-identifier . "\\[O\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "emacs-orgmode@gnu.org") (header :contains "list-id" "<emacs-orgmode.gnu.org>")))) ("list\\.boost\\.cppnow" (to-address . "boostcon-plan@googlegroups.com") (to-list . "boostcon-plan@googlegroups.com") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "boostcon-plan@googlegroups.com") (header :contains "list-id" "<boostcon-plan.googlegroups.com>")))) ("list\\.boost\\.ryppl" (to-address . "ryppl-dev@googlegroups.com") (to-list . "ryppl-dev@googlegroups.com") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "ryppl-dev@googlegroups.com") (header :contains "list-id" "<ryppl-dev.googlegroups.com>")))) ("list\\.boost\\.devel" (to-address . "boost@lists.boost.org") (to-list . "boost@lists.boost.org") (list-identifier . "\\[boost\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "boost@lists.boost.org") (header :contains "list-id" "<boost.lists.boost.org>")))) ("list\\.boost\\.\\(users\\|announce\\)" (to-address . "boost-\\1@lists.boost.org") (to-list . "boost-\\1@lists.boost.org") (list-identifier . "\\\\[Boost-\\1\\\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "boost-\\1@lists.boost.org") (header :contains "list-id" "<boost-\\1.lists.boost.org>")))) ("list\\.isocpp\\.\\(proposals\\|discussion\\)" (to-address . "std-\\1@isocpp.org") (to-list . "std-\\1@isocpp.org") (list-identifier . "\\\\[\\\\(lang\\\\|lib\\\\|std\\\\)-\\1\\\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "std-\\1@isocpp.org") (header :contains "list-id" "<std-\\1.isocpp.org>")))) ("list\\.clang\\.devel" (to-address . "cfe-dev@cs.uiuc.edu") (to-list . "cfe-dev@cs.uiuc.edu") (list-identifier . "\\[\\(cfe-dev\\|LLVMdev\\)\\]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "cfe-dev@cs.uiuc.edu") (header :contains "list-id" "<cfe-dev.cs.uiuc.edu>")))) ("list\\.llvm\\.devel" (to-address . "llvmdev@cs.uiuc.edu") (to-list . "llvmdev@cs.uiuc.edu") (list-identifier . "\\[\\(cfe-dev\\|LLVMdev\\)]") (sieve anyof ((header :contains ("To" "From" "Cc" "Sender") "llvmdev@cs.uiuc.edu") (header :contains "list-id" "<llvmdev.cs.uiuc.edu>")))))))
;; (setq gnus-permanently-visible-groups "INBOX")

;; Always want to see important groups regardless of whether they are empty.
(setq gnus-permanently-visible-groups (
                                       rx(or ".*INBOX" "INBOX.mail" "INBOX.unsorted" "INBOX.mail.unsorted" "unsorted_hushmail" "unsorted_innovate" "list.Sent Items" "Sent Items" "INBOX.monika_fleshner" "INBOX.patricia_rankin" "INBOX.merlyn.holmes" "INBOX.gretchen_oconnell" "INBOX.stein_sture" "INBOX.daryl_kohlerschmidt" "INBOX.managed_services" "INBOX.laima" "laima" "JUNK" "OUTBOX" "TRASH")))


(setq gnus-read-active-file nil)
 (setq gnus-read-newsrc-file nil)
;; (setq gnus-refer-article-method (quote (current (nnir "nnimap:Local") (nntp "LocalNews" (nntp-address "localhost") (nntp-port-number 9119)) (nntp "Gmane" (nntp-address "news.gmane.org")) (nntp "Eternal September" (nntp-address "news.eternal-september.org") (nntp-authinfo-user "jwiegley")))))
 (setq gnus-refer-thread-use-nnir t)
 (setq gnus-registry-ignored-groups (quote (("nntp" t) ("^INBOX" t))))
 (setq gnus-save-killed-list nil)
 (setq gnus-save-newsrc-file nil)
 (setq gnus-score-default-duration (quote p))
 (setq gnus-score-expiry-days 30)
 (setq gnus-select-group-hook (quote (gnus-group-set-timestamp)))
;; (setq gnus-select-method (quote (nnimap "Local" (nnimap-stream shell) (nnimap-shell-program "/usr/local/libexec/dovecot/imap"))))
;; (setq gnus-sieve-crosspost nil)
;; (setq gnus-sieve-file "~/Messages/dovecot.sieve")
;; (setq gnus-sieve-select-method "nnimap:Local")
 (setq gnus-signature-separator (quote ("^-- $" "^-- *$" "^_____+$")))

(setq gnus-simplify-subject-functions (quote (gnus-simplify-subject-fuzzy)))
;; (setq gnus-sort-gathered-threads-function (quote gnus-thread-sort-by-date) t)


(setq gnus-sort-gathered-threads-function (quote gnus-thread-sort-by-date) )

;; (setq gnus-split-methods (quote ((gnus-save-site-lisp-file) (gnus-article-archive-name) (gnus-article-nndoc-name))))
 (setq gnus-started-hook (quote ((lambda nil (run-hooks (quote gnus-after-getting-new-news-hook))))))
 (setq gnus-subscribe-newsgroup-method (quote gnus-subscribe-topics))
 (setq gnus-sum-thread-tree-single-indent "  ")
 (setq gnus-summary-display-while-building 25)
 (setq gnus-summary-expunge-below -100)
;; gnus-summary-expunge-below 0

 (setq gnus-summary-mark-below -100)
 (setq gnus-summary-pick-line-format "%U%R %uS %ur %(%*%-14,14f  %B%s%)
")


 (setq gnus-summary-prepared-hook (quote (gnus-summary-hide-all-threads)))
 (setq gnus-summary-save-parts-default-mime ".*")
 (setq gnus-suspend-gnus-hook (quote (gnus-group-save-newsrc)))
 (setq gnus-thread-expunge-below -1000)
 (setq gnus-thread-hide-subtree t)
;; gnus-thread-hide-subtree nil
 (setq gnus-thread-sort-functions (quote (gnus-thread-sort-by-most-recent-number gnus-thread-sort-by-score)))

;; ;; sort summary
;;  (setq 
;;   gnus-thread-sort-functions '(gnus-thread-sort-by-number
;;                                (not gnus-thread-sort-by-date))
;;   )



(setq gnus-topic-display-empty-topics nil)
 (setq gnus-topic-line-format "%i[ %A: %(%{%n%}%) ]%v
")

 (setq gnus-treat-date-lapsed (quote head))


(setq gnus-treat-hide-citation-maybe t)
 (setq gnus-treat-strip-cr t)
 (setq gnus-treat-strip-leading-blank-lines t)
 (setq gnus-treat-strip-multiple-blank-lines t)

;;  gnus-treat-strip-multiple-blank-lines 'last
;; ;; gnus-fetch-old-headers nil


(setq gnus-treat-strip-trailing-blank-lines t)
 (setq gnus-treat-unsplit-urls t)
 (setq gnus-tree-minimize-window nil)
 (setq gnus-uncacheable-groups "^nnml")
 (setq gnus-use-adaptive-scoring (quote (line)))

;; gnus-use-adaptive-scoring nil

(setq gnus-use-cache t)
 (setq gnus-verbose 4)

;;(setq gnus-verbose 9)

 (setq mail-envelope-from (quote header))
 (setq mail-host-address "vinylisland.org")
 (setq mail-setup-with-from nil)
 (setq mail-source-delete-incoming t)

;;(setq mail-source-delete-incoming nil)

 (setq mail-source-delete-old-incoming-confirm nil)
 (setq mail-source-report-new-mail-interval 15)
;; (setq mail-sources (quote ((file :path "/var/mail/johnw"))))
 (setq mail-specify-envelope-from t)
 (setq mail-user-agent (quote gnus-user-agent))
 (setq message-alternative-emails "\\(dhaley\\|vinylisl\\)@\\(hushmail\\|ssl\\-mail\\).com\\|\\(dkh@member\\.fsf\\|news@vinylisland\\)\\.org\\|damon\\.haley@colorado\\.edu")
 (setq message-fill-column 78)
 (setq message-interactive t)
 (setq message-mail-alias-type nil)
 (setq message-mode-hook (quote (abbrev-mode footnote-mode turn-on-auto-fill turn-on-flyspell turn-on-orgstruct (lambda nil (set-fill-column 78)))))
 (setq message-send-mail-function (quote message-send-mail-with-sendmail))
;; no limit to attachment size
  (setq message-send-mail-partially-limit nil)
 (setq message-sendmail-envelope-from (quote header))
 (setq message-sent-hook (quote (my-gnus-score-followup)))
 (setq message-setup-hook (quote (gnus-alias-determine-identity gnus-harvest-set-from message-check-recipients (lambda nil (bbdb-mail-aliases t)))))
 (setq message-signature-separator "^-- *$")
 (setq message-subscribed-address-functions (quote (gnus-find-subscribed-addresses)))

;; turn this on once harvest is working
;; (setq message-x-completion-alist (quote (("\\([rR]esent-\\|[rR]eply-\\)?[tT]o:\\|[bB]?[cC][cC]:" . gnus-harvest-find-address) ((if (boundp (quote message-newgroups-header-regexp)) message-newgroups-header-regexp message-newsgroups-header-regexp) . message-expand-group))))
 (setq mm-attachment-override-types (quote ("text/x-vcard" "application/pkcs7-mime" "application/x-pkcs7-mime" "application/pkcs7-signature" "application/x-pkcs7-signature" "image/.*")))
 (setq mm-decrypt-option (quote always))
 (setq mm-discouraged-alternatives (quote ("application/msword" "text/richtext")))

;; ;; Set the default value of mm-discouraged-alternatives.
;; (eval-after-load "gnus-sum"
;;   '(add-to-list
;;     'gnus-newsgroup-variables
;;     '(mm-discouraged-alternatives
;;       . '("text/html" "image/.*" "text/richtext")))
;;   )



(setq mm-inline-text-html-with-images t)
 (setq mm-text-html-renderer (quote w3m))
 (setq mm-verify-option (quote always))
 (setq mm-w3m-safe-url-regexp nil)
 (setq nnir-imap-default-search-key "imap")
 (setq nnmail-crosspost nil)
 (setq nnmail-expiry-wait 30)
 (setq nnmail-extra-headers (quote (To Cc Newsgroups)))
 (setq nnmail-scan-directory-mail-source-once t)
 (setq sc-citation-leader "")
 (setq sc-confirm-always-p nil)
 (setq sc-default-attribution "")
 (setq sc-default-cite-frame (quote ((begin (progn (sc-fill-if-different) (setq sc-tmp-nested-regexp (sc-cite-regexp "") sc-tmp-nonnested-regexp (sc-cite-regexp) sc-tmp-dumb-regexp (concat "\\(" (sc-cite-regexp "") "\\)" (sc-cite-regexp sc-citation-nonnested-root-regexp))))) ("^[ 	]*$" (if sc-cite-blank-lines-p (sc-cite-line) (sc-fill-if-different ""))) ((and (looking-at "^-- ?$") (not (save-excursion (goto-char (match-end 0)) (re-search-forward "^-- ?$" nil t)))) (sc-fill-if-different "")) (sc-reference-tag-string (if (string= sc-reference-tag-string "") (list (quote continue)) nil)) (sc-tmp-dumb-regexp (sc-cite-coerce-dumb-citer)) (sc-tmp-nested-regexp (sc-add-citation-level)) (sc-tmp-nonnested-regexp (sc-cite-coerce-cited-line)) (sc-nested-citation-p (sc-add-citation-level)) (t (sc-cite-line)) (end (sc-fill-if-different "")))))
 (setq sc-preferred-attribution-list nil)
 (setq sc-use-only-preference-p t)
 (setq send-mail-function (quote sendmail-send-it))
 (setq smtpmail-default-smtp-server "smtp.colorado.edu")
;; (setq smtpmail-queue-dir "~/Messages/Gnus/Mail/queue/")
 (setq smtpmail-smtp-server "smtp.colorado.edu")
 (setq smtpmail-smtp-service 587)
;; (setq smtpmail-smtp-user "daha1836@colorado.edu")
;;  (setq smtpmail-starttls-credentials (quote ( ("smtp.colorado.com" 587
;;  nil nil) jwiegley@gmail.com("mail.johnwiegley.com" 587 nil nil))))
;; (setq smtpmail-stream-type (quote starttls)))


(setq gnus-home-directory "~/git/gnus")
(setq nnml-directory "~/git/gnus/Mail")
(setq message-directory "~/git/gnus/Mail")
(setq gnus-article-save-directory "~/git/gnus/News")
(setq gnus-cache-directory "~/git/gnus/News/cache")
(setq gnus-cache-active-file "~/git/gnus/News/cache/active")
(setq gnus-kill-files-directory "~/git/gnus/.gnuskillfiled")
(setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\(\\|$\\)\\|^[\”]\”[#’()]")

(setq gnus-startup-file "~/git/gnus/.newsrc")
(setq gnus-directory "~/git/gnus/News")
(setq gnus-dribble-directory "~/git/gnus/")

(setq nntp-marks-directory "~/git/gnus/News/")
(setq nndraft-directory "~/git/gnus/News/drafts/")
;;     (setq nndraft-current-directory "~/git/gnus/News/drafts/")
(setq mail-default-directory "~/git/gnus/Mail")
(setq gnus-default-directory "~/git/gnus")
(setq nnmail-message-id-cache-file "~/git/gnus/nnmail_cache")


(setq gnus-summary-save-parts-last-directory "~/Downloads")


#+end_src 

*** Keep threads collapsed


> I have threaded on, but I like threads to start out collapsed in my
> summary buffer. However, whenever I enter a group, it always expands
> the very first thread -- the one point is on. I find myself often
> hitting "T H" to re-collapse this.

> I've searched, but not found any configuration option to control this.
> Is there something that will keep all threads collapsed until
> I actually start reading?

- Do not enter the group with SPC, but with RET instead.

- Or use this setting :

#+begin_src emacs-lisp 

  (setq gnus-auto-select-first nil)


#+end_src 

*** General

[[http://wikemacs.org/wiki/Gnus][Some nice tips on using gnus]]

#+begin_src emacs-lisp 

(require 'gnus)
(require 'starttls)
(require 'nnmairix)
(require 'message)
(require 'bbdb-gnus)

;;(gnus-compile)
(gnus-delay-initialize)
;;(bbdb-insinuate-gnus)

(defvar switch-to-gnus-unplugged nil)
(defvar switch-to-gnus-run nil)

(defun switch-to-gnus (&optional arg)
  (interactive "P")
  (let* ((alist '("\\`\\*unsent" "\\`\\*Article"
                  "\\`\\*Summary" "\\`\\*Group"))
         (candidate
          (catch 'found
            (dolist (regexp alist)
              (dolist (buf (buffer-list))
                (if (string-match regexp (buffer-name buf))
                    (throw 'found buf)))))))
    (if (and switch-to-gnus-run candidate)
        (progn
          (if (featurep 'ido)
              (ido-visit-buffer candidate ido-default-buffer-method)
            (switch-to-buffer candidate))
          (if (string-match "Group" (buffer-name candidate))
              (gnus-group-get-new-news)))
      (let ((switch-to-gnus-unplugged arg))
        (gnus)
        (gnus-group-list-groups gnus-activate-level)
        (setq switch-to-gnus-run t)))))
#+end_src 

*** fetchmail

#+begin_src emacs-lisp :tangle no
        
(use-package fetchmail-ctl
  :init
  (progn
    (defun maybe-start-fetchmail-and-news ()
      (interactive)
      (when (and (not switch-to-gnus-unplugged)
                 (quickping "imap.gmail.com"))
        (do-applescript "tell application \"Notify\" to run")
        (switch-to-fetchmail)))

    (add-hook 'gnus-startup-hook 'maybe-start-fetchmail-and-news)))

#+end_src 

*** Mo jweigley

#+begin_src emacs-lisp 
    

(add-hook 'gnus-summary-mode-hook 'hl-line-mode)

#+end_src 

*** set up message

#+begin_src emacs-lisp :tangle no

(defun my-message-header-setup-hook ()
  (message-remove-header "From")
  (let ((gcc (message-field-value "Gcc")))
   (when (or (null gcc)
             (string-match "nnfolder\\+archive:" gcc))
     (message-remove-header "Gcc")
     (message-add-header
      (format "Gcc: %s"
              (if (string-match "\\`list\\." (or gnus-newsgroup-name ""))
                  "mail.sent"
                "INBOX"))))))

(add-hook 'message-header-setup-hook 'my-message-header-setup-hook)

(defadvice gnus-summary-resend-message-edit (after call-my-mhs-hook activate)
  (my-message-header-setup-hook))

#+end_src 

#+begin_src emacs-lisp 
  
(defun my-gnus-summary-save-parts (&optional arg)
  (interactive "P")
  (let ((directory "~/Downloads"))
    (message "Saving all MIME parts to %s..." directory)
    (gnus-summary-save-parts ".*" directory arg)
    (message "Saving all MIME parts to %s...done" directory)))

(bind-key "X m" 'my-gnus-summary-save-parts gnus-summary-mode-map)

#+end_src 

#+begin_src emacs-lisp

(defun queue-message-if-not-connected ()
  (set (make-local-variable 'gnus-agent-queue-mail)
       (if (quickping "smtp.colorado.edu") t 'always)))

(add-hook 'message-send-hook 'queue-message-if-not-connected)

#+end_src 

#+begin_src emacs-lisp :tangle no

(defun kick-postfix-if-needed ()
  (if (and (quickping "imap.gmail.com")
           (= 0 (call-process "/usr/bin/sudo" nil nil nil
                              "/opt/local/libexec/postfix/master" "-t")))
      (start-process "postfix" nil "/usr/bin/sudo"
                     "/opt/local/libexec/postfix/master" "-e" "60")))

(add-hook 'message-sent-hook 'kick-postfix-if-needed)

#+end_src 

*** exit gnus

#+begin_src emacs-lisp 

(defun exit-gnus-on-exit ()
  (if (and (fboundp 'gnus-group-exit)
           (gnus-alive-p))
      (with-current-buffer (get-buffer "*Group*")
        (let (gnus-interactive-exit)
          (gnus-group-exit)))))

(add-hook 'kill-emacs-hook 'exit-gnus-on-exit)

#+end_src 

*** Bodacious need to get spam reporting working for me

#+begin_src emacs-lisp :tangle no

(defun gmail-report-spam ()
  "Report the current or marked mails as spam.
This moves them into the Spam folder."
  (interactive)
  (gnus-summary-move-article nil "mail.spam"))

(defun my-gnus-trash-article (arg)
  (interactive "P")
  (if (string-match "\\(drafts\\|queue\\|delayed\\)" gnus-newsgroup-name)
      (gnus-summary-delete-article arg)
    (gnus-summary-move-article arg "mail.trash")))

#+end_src 

#+begin_src emacs-lisp 

(define-key gnus-summary-mode-map [(meta ?q)] 'gnus-article-fill-long-lines)
;;(define-key gnus-summary-mode-map [?$] 'gmail-report-spam)
(define-key gnus-summary-mode-map [?B delete] 'gnus-summary-delete-article)
;;(define-key gnus-summary-mode-map [?B backspace] 'my-gnus-trash-article)

(define-key gnus-article-mode-map [(meta ?q)] 'gnus-article-fill-long-lines)

(defface gnus-summary-expirable-face
  '((((class color) (background dark))
     (:foreground "grey50" :italic t :strike-through t))
    (((class color) (background light))
     (:foreground "grey55" :italic t :strike-through t)))
  "Face used to highlight articles marked as expirable."
  :group 'gnus-summary-visual)

 (push '((eq mark gnus-expirable-mark) . gnus-summary-expirable-face)
      gnus-summary-highlight
)

#+end_src       

*** gnus summary thread

#+begin_src emacs-lisp 

(if window-system
    (setq
     gnus-sum-thread-tree-false-root      ""
     gnus-sum-thread-tree-single-indent   ""
     gnus-sum-thread-tree-root            ""
     gnus-sum-thread-tree-vertical        "|"
     gnus-sum-thread-tree-leaf-with-other "+-> "
     gnus-sum-thread-tree-single-leaf     "\\-> "
     gnus-sum-thread-tree-indent          " "))

#+end_src      

#+begin_src emacs-lisp :tangle no

(setq gnus-sum-thread-tree-single-indent "  ")

#+end_src 

#+begin_src emacs-lisp 
(defsubst dot-gnus-tos (time)
  "Convert TIME to a floating point number."
  (+ (* (car time) 65536.0)
     (cadr time)
     (/ (or (car (cdr (cdr time))) 0) 1000000.0)))

(defun gnus-user-format-function-S (header)
  "Return how much time it's been since something was sent."
  (condition-case err
      (let ((date (mail-header-date header)))
        (if (> (length date) 0)
            (let*
                ((then (dot-gnus-tos
                        (apply 'encode-time (parse-time-string date))))
                 (now (dot-gnus-tos (current-time)))
                 (diff (- now then))
                 (str
                  (cond
                   ((>= diff (* 86400.0 7.0 52.0))
                    (if (>= diff (* 86400.0 7.0 52.0 10.0))
                        (format "%3dY" (floor (/ diff (* 86400.0 7.0 52.0))))
                      (format "%3.1fY" (/ diff (* 86400.0 7.0 52.0)))))
                   ((>= diff (* 86400.0 30.0))
                    (if (>= diff (* 86400.0 30.0 10.0))
                        (format "%3dM" (floor (/ diff (* 86400.0 30.0))))
                      (format "%3.1fM" (/ diff (* 86400.0 30.0)))))
                   ((>= diff (* 86400.0 7.0))
                    (if (>= diff (* 86400.0 7.0 10.0))
                        (format "%3dw" (floor (/ diff (* 86400.0 7.0))))
                      (format "%3.1fw" (/ diff (* 86400.0 7.0)))))
                   ((>= diff 86400.0)
                    (if (>= diff (* 86400.0 10.0))
                        (format "%3dd" (floor (/ diff 86400.0)))
                      (format "%3.1fd" (/ diff 86400.0))))
                   ((>= diff 3600.0)
                    (if (>= diff (* 3600.0 10.0))
                        (format "%3dh" (floor (/ diff 3600.0)))
                      (format "%3.1fh" (/ diff 3600.0))))
                   ((>= diff 60.0)
                    (if (>= diff (* 60.0 10.0))
                        (format "%3dm" (floor (/ diff 60.0)))
                      (format "%3.1fm" (/ diff 60.0))))
                   (t
                    (format "%3ds" (floor diff)))))
                 (stripped
                  (replace-regexp-in-string "\\.0" "" str)))
              (concat (cond
                       ((= 2 (length stripped)) "  ")
                       ((= 3 (length stripped)) " ")
                       (t ""))
                      stripped))))
    (error "    ")))

(defvar gnus-count-recipients-threshold 5
  "*Number of recipients to consider as large.")

(defun gnus-user-format-function-r (header)
  "Given a Gnus message header, returns priority mark.
Here are the meanings:

The first column represent my relationship to the To: field.  It can be:

         I didn't appear (and the letter had one recipient)
   :     I didn't appear (and the letter had more than one recipient)
   <     I was the sole recipient
   +     I was among a few recipients
   *     There were many recipients

The second column represents the Cc: field:

    .    I wasn't mentioned, but one other was
    :    I wasn't mentioned, but others were
    ^    I was the only Cc mentioned
    &    I was among a few Cc recipients
    %    I was among many Cc recipients

These can combine in some ways to tell you at a glance how visible the message
is:

   >.    Someone wrote to me and one other
    &    I was copied along with several other people
   *:    Mail to lots of people in both the To and Cc!"
  (let* ((to (or (cdr (assoc 'To (mail-header-extra header))) ""))
         (cc (or (cdr (assoc 'Cc (mail-header-extra header))) ""))
         (to-len (length (split-string to "\\s-*,\\s-*")))
         (cc-len (length (split-string cc "\\s-*,\\s-*")))
         (to-char (cond )))
    (cond ((string-match gnus-ignored-from-addresses to)
           (cond ((= to-len 1)
                  (cond ((string= cc "") "< ")
                        ((= cc-len 1) "<.")
                        (t "<:")))
                 ((< to-len gnus-count-recipients-threshold)
                  (cond ((string= cc "") "+ ")
                        ((= cc-len 1) "+.")
                        (t "+:")))
                 (t
                  (cond ((string= cc "") "* ")
                        ((= cc-len 1) "*.")
                        (t "*:")))))

          ((string-match gnus-ignored-from-addresses cc)
           (cond ((= cc-len 1)
                  (cond ((= to-len 1) " ^")
                        (t ":^")))
                 ((< cc-len gnus-count-recipients-threshold)
                  (cond ((= to-len 1) " &")
                        (t ":&")))
                 (t
                  (cond ((= to-len 1) " %")
                        (t ":%")))))
          (t "  "))))

#+end_src

*** gnus-dired

#+begin_src emacs-lisp 

(use-package gnus-dired
  :commands gnus-dired-mode
  :init
  (add-hook 'dired-mode-hook 'gnus-dired-mode))

#+end_src 
  
**** gnus scoring

#+begin_src emacs-lisp 

(use-package my-gnus-score
  :init
  (progn
    (defun gnus-group-get-all-new-news ()
      (interactive)
      (gnus-group-get-new-news 5)
      (gnus-group-list-groups 4)
      (my-gnus-score-groups)
      (gnus-group-list-groups 4))

    (define-key gnus-group-mode-map [?v ?g] 'gnus-group-get-all-new-news)))

#+end_src     

**** gnus daemon

#+begin_src emacs-lisp :tangle no

(use-package gnus-demon
  :init
  (progn
    (defun gnus-demon-scan-news-2 ()
      (when gnus-plugged
        (let ((win (current-window-configuration))
              (gnus-read-active-file nil)
              (gnus-check-new-newsgroups nil)
              (gnus-verbose 2)
              (gnus-verbose-backends 5))
          (unwind-protect
              (save-window-excursion
                (when (gnus-alive-p)
                  (with-current-buffer gnus-group-buffer
                    (gnus-group-get-new-news gnus-activate-level))))
            (set-window-configuration win)))))

    (gnus-demon-add-handler 'gnus-demon-scan-news-2 5 2)

#+end_src

#+begin_src emacs-lisp :tangle no

    (defun save-gnus-newsrc ()
      (if (and (fboundp 'gnus-group-exit)
               (gnus-alive-p))
          (with-current-buffer (get-buffer "*Group*")
            (gnus-save-newsrc-file))))

    (gnus-demon-add-handler 'save-gnus-newsrc nil 1)))

#+end_src     

#+begin_src emacs-lisp :tangle no

(use-package nnir
  :init
  (progn
    (defun activate-gnus ()
      (unless (get-buffer "*Group*") (gnus)))

    (defun gnus-goto-article (message-id)
      (activate-gnus)
      (gnus-summary-read-group "INBOX" 15 t)
      (gnus-summary-refer-article message-id))

    (defvar gnus-query-history nil)

    (defun gnus-query (query &optional arg)
      (interactive
       (list (read-string (format "IMAP Query %s: "
                                  (if current-prefix-arg "All" "Mail"))
                          (format-time-string "SENTSINCE %d-%b-%Y "
                                              (time-subtract (current-time)
                                                             (days-to-time 90)))
                          'gnus-query-history)
             current-prefix-arg))
      (activate-gnus)
      (let ((nnir-imap-default-search-key "imap")
            (nnir-ignored-newsgroups
             (if arg
                 (concat "\\`" (regexp-opt
                                '("archive"
                                  "archive.emacs"
                                  "list"
;;                                  "list.bahai"
;;                                  "list.boost"
;;                                  "list.clang"
                                  "list.emacs"
;;                                  "list.isocpp"
;;                                  "list.ledger"
;;                                  "list.llvm"
;;                                  "list.wg21"
                                  "mail"
                                  "mail.save"
                                  "Drafts"
                                  "Sent Messages"))
                         "\\'")
               "\\`\\(\\(list\\|archive\\)\\.\\|mail\\.\\(spam\\|save\\)\\)")))
        (gnus-group-make-nnir-group
         nil `((query    . ,query)
               (criteria . "")
               (server   . "nnimap:Local")))))

    (define-key global-map [(alt meta ?f)] 'gnus-query)))

#+end_src     

**** Gnus harvest - eventually use this

#+begin_src emacs-lisp :tangle no

(use-package gnus-harvest
  :init
  (if (featurep 'message-x)
      (gnus-harvest-install 'message-x)
    (gnus-harvest-install)))

#+end_src 

#+begin_src emacs-lisp 

(use-package gnus-alias
  :commands (gnus-alias-determine-identity
             gnus-alias-message-x-completion
             gnus-alias-select-identity)
  :init
  (progn
    (add-hook 'message-setup-hook 'gnus-alias-determine-identity)

    (if (featurep 'message-x)
        (add-hook 'message-x-after-completion-functions
                  'gnus-alias-message-x-completion))

    (define-key message-mode-map "\C-c\C-f\C-p" 'gnus-alias-select-identity)))

(use-package rs-gnus-summary
  :init
  (progn
    (defalias 'gnus-user-format-function-size
      'rs-gnus-summary-line-message-size)

    (setq gnus-balloon-face-0 'rs-gnus-balloon-0)
    (setq gnus-balloon-face-1 'rs-gnus-balloon-1)))

(use-package supercite
  :commands sc-cite-original
  :init
  (add-hook 'mail-citation-hook 'sc-cite-original)
  :config
  (defun sc-fill-if-different (&optional prefix)
    "Fill the region bounded by `sc-fill-begin' and point.
Only fill if optional PREFIX is different than
`sc-fill-line-prefix'.  If `sc-auto-fill-region-p' is nil, do not
fill region.  If PREFIX is not supplied, initialize fill
variables.  This is useful for a regi `begin' frame-entry."
    (if (not prefix)
        (setq sc-fill-line-prefix ""
              sc-fill-begin (line-beginning-position))
      (if (and sc-auto-fill-region-p
               (not (string= prefix sc-fill-line-prefix)))
          (let ((fill-prefix sc-fill-line-prefix))
            (unless (or (string= fill-prefix "")
                        (save-excursion
                          (goto-char sc-fill-begin)
                          (or (looking-at ">+  +")
                              (< (length
                                  (buffer-substring (point)
                                                    (line-end-position)))
                                 65))))
              (fill-region sc-fill-begin (line-beginning-position)))
            (setq sc-fill-line-prefix prefix
                  sc-fill-begin (line-beginning-position)))))
    nil))

(use-package browse-url
  :commands browse-url
  :init
  (progn
    (defun gnus-article-get-urls-region (min max)
      "Return a list of urls found in the region between MIN and MAX"
      (let (url-list)
        (save-excursion
          (save-restriction
            (narrow-to-region min max)
            (goto-char (point-min))
            (while (re-search-forward gnus-button-url-regexp nil t)
              (let ((match-string (match-string-no-properties 0)))
                (if (and (not (equal (substring match-string 0 4) "file"))
                         (not (member match-string url-list)))
                    (setq url-list (cons match-string url-list)))))))
        url-list))

    (defun gnus-article-get-current-urls ()
      "Return a list of the urls found in the current `gnus-article-buffer'"
      (let (url-list)
        (with-current-buffer gnus-article-buffer
          (setq url-list
                (gnus-article-get-urls-region (point-min) (point-max))))
        url-list))

    (defun gnus-article-browse-urls ()
      "Visit a URL from the `gnus-article-buffer' by showing a
buffer with the list of URLs found with the `gnus-button-url-regexp'."
      (interactive)
      (gnus-configure-windows 'article)
      (gnus-summary-select-article nil nil 'pseudo)
      (let ((temp-buffer (generate-new-buffer " *Article URLS*"))
            (urls (gnus-article-get-current-urls))
            (this-window (selected-window))
            (browse-window (get-buffer-window gnus-article-buffer))
            (count 0))
        (save-excursion
          (save-window-excursion
            (with-current-buffer temp-buffer
              (mapc (lambda (string)
                      (insert (format "\t%d: %s\n" count string))
                      (setq count (1+ count))) urls)
              (not-modified)
              (pop-to-buffer temp-buffer)
              (setq count
                    (string-to-number
                     (char-to-string (if (fboundp
                                          'read-char-exclusive)
                                         (read-char-exclusive)
                                       (read-char)))))
              (kill-buffer temp-buffer)))
          (if browse-window
              (progn (select-window browse-window)
                     (browse-url (nth count urls)))))
        (select-window this-window)))

    (define-key gnus-summary-mode-map [(control ?c) (control ?o)]
      'gnus-article-browse-urls)
    (define-key gnus-article-mode-map [(control ?c) (control ?o)]
      'gnus-article-browse-urls)))

#+end_src       

*** saving mail locally & settings

#+begin_src emacs-lisp 

;; (use-package dot-gnus
;;   :bind (("M-G"   . switch-to-gnus)
;;          ("C-x m" . compose-mail))
;;   :init
;;   (progn
;;     (setq gnus-init-file (expand-file-name "dkh-gnus" user-emacs-directory)
;;           gnus-home-directory "~/git/gnus")))

;;   :bind (("M-G"   . switch-to-gnus)
;;          ("C-x m" . compose-mail))

(global-set-key (kbd "C-x m") 'compose-mail)


#+end_src 

I put all of my settings relating to:

**** getting mail
**** sending mail
**** gnus select method

in my gnu init file (see below)

*** More attractive Summary View

#+begin_src emacs-lisp :tangle no

       (starter-kit-load "gnus" "pretty-summary")

#+end_src


#+begin_src emacs-lisp 

(add-hook 'message-sent-hook 'gnus-score-followup-article)
(add-hook 'message-sent-hook 'gnus-score-followup-thread)



(defun my-gnus ()
  "Start a new Gnus, or locate the existing buffer *Group*."
  (interactive)
  (if (buffer-live-p    (get-buffer "*Group*"))
      (switch-to-buffer (get-buffer "*Group*"))
    (gnus)))

#+end_src 


*** Main Gnus IMAP config

#+begin_src emacs-lisp 

(setq auth-sources (quote ((:source "~/.emacs.d/.authinfo.gpg"
                                    :host t :protocol t))))

(copy-face 'default 'my-gnus-face)
(copy-face 'my-gnus-face 'my-subject-face)

(copy-face 'my-gnus-face 'my-group-face)
(set-face-attribute 'my-group-face nil :inherit 'my-gnus-face)

(copy-face 'my-group-face 'my-group-face-unread)
(set-face-attribute 'my-group-face-unread nil :inherit 'my-group-face)

(copy-face 'my-group-face 'my-group-server-face)
(copy-face 'my-group-server-face 'my-group-server-face-unread)
(set-face-attribute 'my-group-server-face-unread nil :inherit 'my-group-server-face)

(copy-face 'my-group-face 'my-unread-count-face)
(copy-face 'my-unread-count-face 'my-unread-count-face-unread)
(set-face-attribute 'my-unread-count-face-unread nil :inherit 'my-unread-count-face)

(copy-face 'my-group-face 'my-inbox-icon-face)
(copy-face 'my-inbox-icon-face 'my-inbox-icon-face-unread)
(set-face-attribute 'my-inbox-icon-face-unread nil :inherit 'my-inbox-icon-face)

(copy-face 'my-gnus-face 'my-topic-empty-face)
(copy-face 'my-gnus-face 'my-topic-face)


(setq nntp-marks-is-evil t)


;; (require 'gnushush)

;;           (require 'miniedit)

(defun store-gnus-outgoing-message-group ()
  (cond ((and gnus-newsgroup-name
              (not (message-news-p))
              (stringp gnus-newsgroup-name))
         gnus-newsgroup-name)
        (t ted-default-gcc-group)))

(setq gnus-outgoing-message-group nil
      gnus-level-subscribed 5)



(defun dkh/unread-face (f)
  (intern (if (> (string-to-number gnus-tmp-number-of-unread) 0) (concat f "-unread") f)))

;; this corresponds to a topic line format of "%n %A"
(defun gnus-user-format-function-topic-line (dummy)
  (let ((topic-face (if (zerop total-number-of-articles)
                        'my-topic-empty-face
                      'my-topic-face)))
    (propertize
     (format "%s %d" name total-number-of-articles)
     'face topic-face)))

(defun gnus-user-format-function-s (header)
  (propertize (mail-header-subject header) 'face 'my-subject-face 'gnus-face t))

;; dkh commented out all this stuff
(defun gnus-user-format-function-g (headers) ;; gnus-group-line-format use %ug to call this func! e.g  "%M%S%p%P%(%-40,40ug%)%-5uy %ud\n"
  split full group protocol-server:group into three parts.
  (message "format function g for group %s" gnus-tmp-group)
  (string-match "\\(^.*\\)\\+\\(.*\\):\\(.*\\)" gnus-tmp-group)
  map the first two letters of the server name to a more friendly and cuddly display name
  (let*  ((match-ok (match-string 2 gnus-tmp-group))
          (server-key (if (null match-ok) nil (upcase(substring match-ok 0 2)))))
    (if (zerop (length server-key))
        gnus-tmp-group
      ;; construct new group format line with a small envelope taking the place of any INBOX
      (concat
       (propertize
        (format "%-8s" (cdr (assoc server-key dkh/server-name-maps)))
        'face (dkh/unread-face "my-group-server-face") 'face (dkh/unread-face (concat "my-group-server-face-" server-key)) 'gnus-face t)
       " - "
       (if (or (string-match "mail.misc" (match-string 3 gnus-tmp-group) )(string-match "INBOX" (match-string 3 gnus-tmp-group) ))
           (propertize "\x2709" 'face (dkh/unread-face "my-inbox-icon-face") 'gnus-face t)
         (propertize (match-string 3 gnus-tmp-group) 'face (dkh/unread-face "my-group-face") 'gnus-face t) )))))


(defun gnus-user-format-function-j (headers)
  ;; prefix each post depending on whether to, cc or Bcc to
  (let ((to (gnus-extra-header 'To headers)))
    (if (string-match dkh-mails to)
        (if (string-match "," to) "~" "»")
      (if (or (string-match dkh-mails
                            (gnus-extra-header 'Cc headers))
              (string-match dkh-mails                                        
                            (gnus-extra-header 'BCc headers)))
          "~"
        " "))))

(defun gnus-user-format-function-y (headers)
  "return string representation for unread articles"
  (concat
   (propertize  (if (= (string-to-number  gnus-tmp-number-of-unread) 0) "" "\x2709") 'face (dkh/unread-face "my-inbox-icon-face") 'gnus-face t)
   (propertize  (if (= (string-to-number  gnus-tmp-number-of-unread) 0) ""
                  (concat "   (" gnus-tmp-number-of-unread ")")) 'face (dkh/unread-face "my-unread-count-face") 'gnus-face t)))



(setq  gnus-user-date-format-alist
       ;; Format the date so we can see today/tomorrow quickly.
       ;; See http://emacs.wordpress.com/category/gnus/ for the original.
       '(
         ((gnus-seconds-today) . "Today, %H:%M")
         ((+ 86400 (gnus-seconds-today)) . "Yesterday, %H:%M")
         (604800 . "%A %H:%M") ;;that's one week
         ((gnus-seconds-month) . "%A %d")
         ((gnus-seconds-year) . "%B %d")
         (t . "%B %d '%y"))) ;;this one is used when no other does match


(defun gnus-group-read-group-no-prompt ()
  "Read news in this newsgroup and don't prompt.
                                Use the value of `gnus-large-newsgroup'."
  (interactive)
  (gnus-group-read-group gnus-large-newsgroup))

(defun gnus-article-sort-by-chars (h1 h2)
  "Sort articles by size."
  (< (mail-header-chars h1)
     (mail-header-chars h2)))

;;             (add-to-list 'message-syntax-checks '(existing-newsgroups . disabled))







;;F6 killfiles a poster, F7 ignores a thread
;;   (define-key gnus-summary-mode-map (kbd "<f6>") "LA")
;;   (define-key gnus-summary-mode-map (kbd "<f7>") 'gnus-summary-kill-thread)
(define-key gnus-summary-mode-map (kbd "<deletechar>") (lambda ()(interactive)(gnus-summary-delete-article)(next-line)))

;; some comfort keys to scroll article in other window when in summary window
(define-key gnus-summary-mode-map [(meta up)] (lambda() (interactive) (scroll-other-window -1)))
(define-key gnus-summary-mode-map [(meta down)] (lambda() (interactive) (scroll-other-window 1)))
;; thread navigation
(define-key gnus-summary-mode-map [(control down)] 'gnus-summary-next-thread)
(define-key gnus-summary-mode-map [(control up)] 'gnus-summary-prev-thread)


(define-key gnus-summary-mode-map (kbd ">") 'gnus-summary-show-thread)
(define-key gnus-summary-mode-map (kbd "<") 'gnus-summary-hide-thread)


;; some trickery to show the newsread people are using and colour code depending on type
;; in this case highlight users of any outlook type dross :-;
(setq  gnus-header-face-alist nil)
(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*") ;; other
       nil font-lock-comment-face))

(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*Outlook.*")
       nil 'gnus-emphasis-highlight-words))

;; And show any real men who use Gnus!
(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*Gnus.*")
       nil 'gnus-server-opened))

;; Format RSS feed titles nicely
(add-hook 'gnus-summary-mode-hook
          (lambda ()
            (if (string-match "^nnrss:.*" gnus-newsgroup-name)
                (progn
                  (make-local-variable 'gnus-show-threads)
                  (make-local-variable 'gnus-article-sort-functions)
                  (make-local-variable 'gnus-use-adaptive-scoring)
                  (make-local-variable 'gnus-use-scoring)
                  (make-local-variable 'gnus-score-find-score-files-function)
                  (setq gnus-show-threads nil)
                  (setq gnus-article-sort-functions 'gnus-article-sort-by-date)
                  (setq gnus-use-adaptive-scoring nil)
                  (setq gnus-use-scoring t)
                  ;;                  (setq gnus-score-find-score-files-function 'gnus-score-find-single)
                  ))))


(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)

(defun gnus-user-format-function-d (headers)
  (let ((time (gnus-group-timestamp gnus-tmp-group)))
    (if time
        (format-time-string "%b %d  %H:%M" time)
      ""
      )
    )
  )

(define-key mode-specific-map [?m] (lambda()(interactive) (gnus-agent-toggle-plugged t)(gnus 1)))





(setq gnus-suppress-duplicates t
      gnus-save-duplicate-list t
      gnus-duplicate-list-length 100000)

(remove-hook 'gnus-article-prepare-hook 'bbdb-mua-display-sender)




(gnus-add-configuration
 '(article
   (horizontal 1.0
               (group 0.25)
               (vertical 1.0
                         (summary 0.16 point)
                         (article 1.0)
                         ("*BBDB*" 6))
               )))

(add-hook 'gnus-summary-exit-hook
          (lambda ()
            (when (every (lambda (buffer) (member buffer (gnus-buffers)))
                         (mapcar 'window-buffer (window-list)))
              (delete-other-windows)))
          t nil)

;; Set the window title
                                        ;(modify-frame-parameters nil '((title . "Gnus")))

;; indexing in mail groups supported by dovecot on the server side.
(require 'nnir)

(define-key gnus-group-mode-map (kbd "<H-f1>") 'gnus-group-make-nnir-group)
;; (define-key gnus-group-mode-map (kbd "<C-f3>") 'gnus-group-make-nnir-group)
;;  (define-key gnus-summary-mode-map (kbd "G G") 'command gnus-group-make-nnir-group)

                                        ; (setq nnir-search-engine 'imap)

(defcustom dkh/authinfo-file (expand-file-name(concat user-emacs-directory ".authinfo.gpg"))
  "regexp for searching blogger"
  :group 'dkh/gnus
  :type 'string)

(global-set-key (kbd "C-c x") '(lambda()(interactive)(save-buffers-kill-emacs)))
;; Mark gcc'ed (archive) as read:

#+end_src 


*** Gnus init file

I put personal stuff like my splitting rules here

If things do not go smoothly at startup, you have to twiddle some
variables in your `~/.gnus.el' file. This file is similar to
`~/.emacs', but is read when Gnus starts.

#+begin_src emacs-lisp 

;; put everything in ~/.emacs.d
(setq
 gnus-init-file "~/git/.emacs.d/dkh-gnus.el"
 message-signatrue-directory "~/git/.emacs.d/sig/"
 )

#+end_src 


*** Second part




#+begin_src emacs-lisp 

;; (require 'info)
  (if (featurep 'xemacs)
      (add-to-list 'Info-directory-list "~/.emacs.d/el-get/nognus/texi/")
    (add-to-list 'Info-default-directory-list "~/.emacs.d/el-get/nognus/texi/"))

(defcustom gnus-summary-save-parts-exclude-article nil                                                                                                                                                                     
          "If non-nil don't save article along with attachments."                                                                                                                                                                  
          :group 'gnus-article-mime                                                                                                                                                                                                
          :type 'boolean)                                                                                                                                                                                                          
                                                                                                                                                                                                                                   
        (defun gnus-summary-save-parts-1 (type dir handle reverse)                                                                                                                                                                 
          (if (stringp (car handle))                                                                                                                                                                                               
(mapcar (lambda (h) (gnus-summary-save-parts-1 type dir h reverse))                                                                                                                                                  
    (cdr handle))                                                                                                                                                                                                    
            (when (if reverse                                                                                                                                                                                                      
                  (not (string-match type (mm-handle-media-type handle)))                                                                                                                                                          
                (string-match type (mm-handle-media-type handle)))                                                                                                                                                                 
              (let* ((name (or                                                                                                                                                                                                     
                            (mm-handle-filename handle)                                                                                                                                                                            
                            (unless gnus-summary-save-parts-exclude-article                                                                                                                                                        
                              (format "%s.%d.%d" gnus-newsgroup-name                                                                                                                                                               
                                      (cdr gnus-article-current)                                                                                                                                                                   
                                      gnus-summary-save-parts-counter))))                                                                                                                                                          
                     (file (when name                                                                                                                                                                                              
                             (expand-file-name                                                                                                                                                                                     
                              (gnus-map-function                                                                                                                                                                                   
                               mm-file-name-rewrite-functions                                                                                                                                                                      
                               (file-name-nondirectory                                                                                                                                                                             
                                name))                                                                                                                                                                                             
                              dir))))                                                                                                                                                                                              
                (when file                                                                                                                                                                                                         
                  (incf gnus-summary-save-parts-counter)                                                                                                                                                                           
                  (unless (file-exists-p file)                                                                                                                                                                                     
                    (mm-save-part-to-file handle file)))))))

(setq message-cite-prefix-regexp
"\\([ ]*[-_.#[:word:]]+>+\\|[ ]*[]>|}]\\)+")


#+end_src 


*** Gnus pop

#+begin_src emacs-lisp :tangle no

(require 'secrets)
(setq mail-sources
  `(
   (file :path "/var/mail/user")
   (pop :server "mail.host.org"
        :user "user@host.org"
        :password ,(rest (assoc :nightmarehost password-alist)))
   (pop
    :server "127.0.0.1"
    :port 1235
    :user "user"
    :password ,(rest (assoc :freehost password-alist))
    :prescript "ssh -f -L 1235:mail.freehost.org:110 user@mail.freehost.org sleep 60 &")))

#+end_src 



*** Display chars

#+begin_src emacs-lisp 

(setq gnus-score-over-mark ?\u2191          ; \u2191 \u2600
      gnus-score-below-mark ?\u2193         ; \u2193 \u2602
      gnus-ticked-mark ?\u2691
      gnus-dormant-mark ?\u2690
      gnus-expirable-mark ?\u267b
      gnus-read-mark ?\u2713
      gnus-del-mark ?\u2717
      gnus-killed-mark ?\u2620
      gnus-replied-mark ?\u27f2
      gnus-forwarded-mark ?\u2933
      gnus-cached-mark ?\u260d
      gnus-recent-mark ?\u2605
      gnus-unseen-mark ?\u2729
      gnus-unread-mark ?\u2709
)

(setq gnus-summary-line-format "%«%U%R %uS %ur %»%(%*%-14,14f   %1«%B%s%»%)
 ")

;;       gnus-summary-line-format (concat "%{|%}"
;;                                        "%U%R%z"
;;                                        "%{|%}"
;;                                        "%(%-18,18f"
;;                                        "%{|%}"
;;                                        "%*%{%B%} %s%)"
;;                                        "\n"))


#+end_src                                        

*** New settings

#+begin_src emacs-lisp 

(setq message-kill-buffer-on-exit t)
(setq gnus-fetch-old-headers 'some)



;; Unbind this key; it's annoying!
(define-key gnus-summary-mode-map "o" (lambda () (interactive)))
(setq gnus-article-banner-alist '((iphone . "\\(^Sent from my iPhone$\\)")))


#+end_src 



*** Remaining settings

#+begin_src emacs-lisp 

(setq gnus-novice-user nil)




(setq
 epa-file-cache-passphrase-for-symmetric-encryption t
 user-full-name "Damon Haley"
 user-mail-address "damon.haley@colorado.edu"
 )


 (setq
;;  display-time-mail-file "/var/mail/vinylisland"
 ;;
 ;; Personal headers
 ;;
 message-default-headers (concat
                          "X-Face: \"'PJ-yb+fYF0]%?,#==_(s>`~Hw_iwG![Cc+Sq$k>S|QbU)>?}Y51$4)\\9OEt:NL.@kZIqy <UnVZ*!XnGGV:iDO$YDhK7i~$.fs%r^0LJdztkb\\6=DI6by:GdO>.L<,Nd[nsMwrN3b]os1UqBw\n"
                          "X-Accept-Language: en-us\n"
                          "X-Operating-System: Debian GNU/Linux\n"
                          )
 gnus-treat-display-smileys t
 ;; How gnus gets address from the from header.
 gnus-extract-address-components 'mail-extract-address-components
 ;; Buttonize the different parts, please
 gnus-buttonized-mime-types  '("multipart/alternative" "multipart/signed"  "multipart/encrypted")
 ;; But keep buttons for multiple parts
 gnus-inhibit-mime-unbuttonizing t
 gnus-article-skip-boring t
 gnus-expert-user t

 gnus-indent-thread-level 1
 gnus-build-sparse-threads nil

 gnus-use-nocem t
 gnus-use-full-window nil     ;; do not destroy other windows

 )



(setq
 gnus-no-groups-message "No Gnus for Daemon."
 
 mail-imenu-generic-expression '(("Subject"  "^Subject: *\\(.*\\)" 1)
                                 ("Cc"     "^C[Cc]: *\\(.*\\)" 1)
                                 ("To"     "^To: *\\(.*\\)" 1)
                                 ("From"  "^From: *\\(.*\\)" 1))
 ;; whether gnus bothers with faces. It should!
  
 message-forward-ignored-headers "^Content-Transfer-Encoding:\\|^X-Gnus:\\|^To:\\|^Cc:\\|^From"
 message-make-forward-subject-function (quote message-forward-subject-fwd)
 gnus-visual t

 ;; SachaChua
 gnus-message-archive-group
 '((lambda (x)
     (cond
      ;; Store personal mail messages in the same group I started out in
      ((string-match "mail.*" group) group)
      ;; Store personal mail messages in the same group I started out in
      ((string-match "INBOX.*" group) group)
      ;; I receive a copy of all messages I send to a list, so there's no need to archive
      ((string-match "list.*" group) nil)
      ;; Store everything else in mail.2011 until I can sort it out
      (t (concat "mail." (format-time-string "%Y")))
      )
     )
   )
 gnus-update-message-archive-method t
 gnus-message-archive-method gnus-select-method ;; this line is important
 )



;;       gnus-permanently-visible-groups "\\.*"
;; all mails should be always displayed in the mailbox

(setq 
 gnus-visible-headers (quote ("^From:" "^Newsgroups:" "^Subject:" "^Date:" "^Followup-To:" "^Reply-To:" "^Organization:" "^Summary:" "^Keywords:" "^To:" "^[BGF]?Cc:" "^Posted-To:" "^Mail-Copies-To:" "^Mail-Followup-To:" "^Apparently-To:" "^Gnus-Warning:" "^Resent-From:" "^X-Sent:" "^User-Agent:"))

 ;; from http://nijino.homelinux.net/emacs/.gnus.el
 gnus-signature-limit 8.0

 
 )

(setq
 gnushush-sender-header (quote none)
 gnushush-user-agent-header (quote none)

 
 
 )

;; From pop sources
(setq nnmail-split-methods 'nnmail-split-fancy)

;; (info "gnus")
;; See (info "(gnus) Splitting in IMAP"), and search for `fancy'
;; there.  The variable is nnimap-split-rule for me.

(setq nnimap-split-methods 'nnmail-split-fancy)

(setq nnmail-split-abbrev-alist
      '((any . "from\\|to\\|cc\\|sender\\|apparently-to\\|resent-from\\|resent-to\\|resent-cc")
        (mail . "mailer-daemon\\|postmaster\\|uucp")
        (to . "to\\|cc\\|apparently-to\\|resent-to\\|resent-cc")
        (from . "from\\|sender\\|resent-from")
        (daemon-errors . "Cron daemon\\|mailer-daemon")
        (list . "list-id\\|x-mailing-list\\|to\\|cc\\|sender")))

(setq

                                        ;      when replying we dont want to include peoples signatures.
 message-cite-function 'message-cite-original-without-signature
 ;;       message-required-news-headers (remove' Message-ID message-required-news-headers)
 ;;       message-required-mail-headers (remove' Message-ID message-required-mail-headers)
 ;; Use emacs-w3m to render html mails and display images
 gnus-mime-display-multipart-related-as-mixed t

 mm-inline-large-images t
 

 mm-external-terminal-program (quote urxvt)

 w3m-w3mkey-binding 'info
 w3m-safe-url-regexp nil
 
 )





;; ---------------------------------------------------------------------

(defun message-check-news-syntax ()
  "Check the syntax of the message and prompt the user to be sure he wants to send."
  (and
   (save-excursion
     (save-restriction
       (widen)
       (and
        ;; We narrow to the headers and check them first.
        (save-excursion
          (save-restriction
            (message-narrow-to-headers)
            (message-check-news-header-syntax)))
        ;; Check the body.
        (message-check-news-body-syntax))))
                                        ; sm: this last line is my addition
   (y-or-n-p "Post the message? ")
   ))

#+end_src 



**** ;; from making gnus more like pine

#+begin_src emacs-lisp 

(defvar my-message-attachment-regexp
  "attach\\|\Wfiles?\W\\|enclose\\|\Wdraft\\|\Wversion")
(defun check-mail ()
  "ask for confirmation before sending a mail. Scan for possible attachment"
  (save-excursion
    (message-goto-body)
    (let ((warning ""))
      (when (and (search-forward-regexp my-message-attachment-regexp nil t nil)
                 (not (search-forward "<#part" nil t nil)))
        (setq warning "No attachment.\n"))
      (goto-char (point-min))
      (unless (message-y-or-n-p (concat warning "Send the message ? ") nil nil)
        (error "Message not sent")))))
(add-hook 'message-send-hook 'check-mail)

#+end_src

#+begin_src emacs-lisp 

(define-key gnus-article-mode-map (kbd "<deletechar>") 'gnus-article-goto-prev-page)




(eval-after-load 'gnus-art
  '(progn
     (add-to-list 'gnus-picon-databases "/usr/share/picons")
     ))

(setq gnus-picon-style 'right)



(setq gnus-treat-from-picon 'head)
(setq gnus-treat-display-x-face 'head)




(defun gnus-goto-last-link ()
  "A lot of articles just have one link to goto"
  (interactive)
  (gnus-summary-show-article)
  (gnus-summary-select-article-buffer)
  (goto-char (point-max))
  (forward-line -2)
  (rgr/browse-url)
  (let ((cur (wg-name (wg-current-workgroup)))
        (prev (wg-name (wg-previous-workgroup))))
  (if (string-equal prev "gnus")
    (wg-switch-to-index-1)))
  (gnus-article-show-summary)
  (gnus-summary-mark-as-read-forward 1)
  )
  
  
;; from Peter Munster


(defun my-alter-summary-map ()
  (local-set-key (kbd "<f4>") '(lambda () (interactive)
                                 (gnus-goto-last-link)
                                 ))
    (local-set-key (kbd "z") '(lambda () (interactive)
                                   (gnus-summary-mark-as-read-forward)))
  (local-set-key ":" 'bbdb-mua-display-records)
  (local-set-key "d" [?M ?M ?e ?e down]))

(defun my-alter-article-map ()
  (local-set-key "1" 'delete-other-windows)
  (local-set-key "q" '(lambda () (interactive)
                        (gnus-article-show-summary)
                        (delete-other-windows)))
  (local-set-key "n" "hnh1")
  (local-set-key "N" "hNh1")
  (local-set-key "d" "hMMeenh1")
  )

(add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
(add-hook 'gnus-article-mode-hook 'my-alter-article-map)


(add-to-list 'message-syntax-checks '(existing-newsgroups . disabled))








#+end_src 


** Erc

*** ERC settings

**** orig settings

#+begin_src emacs-lisp 

;;(setq erc-user-full-name (quote user-full-name))

(setq erc-user-full-name user-full-name)

#+end_src 


**** jwiegley settings

#+begin_src emacs-lisp 

(custom-set-variables
 '(erc-auto-query (quote window-noselect))
 ;; '(erc-autoaway-message "I'm away (after %i seconds of idle-time)")
 '(erc-autoaway-message "I'm at the cappuccino bar(after %i seconds of idle-time)")
 '(erc-fools (quote ("JordiGH")))
 '(erc-generate-log-file-name-function (quote erc-generate-log-file-name-short))
 '(erc-header-line-format nil)
 '(erc-hide-list (quote ("JOIN" "NICK" "PART" "QUIT" "MODE")))
 '(erc-ignore-list (quote ("rudybot!.*")))
 '(erc-log-channels-directory "~/git/.emacs.d/.erc/logs/")
 '(erc-log-write-after-send t)
 '(erc-modules (quote (autojoin button completion dcc fill identd irccontrols list log match menu move-to-prompt netsplit networks noncommands readonly replace ring scrolltobottom services smiley stamp spelling track highlight-nicknames)))
 '(erc-nick "dkh")
 '(erc-port 6667)
 '(erc-priority-people-regexp "\\`[^#].+")
 '(erc-prompt-for-nickserv-password nil)
 '(erc-replace-alist (quote (("</?FONT>" . ""))))
 '(erc-server "asimov.freenode.net")
 '(erc-services-mode t)
 ;; '(erc-text-matched-hook (quote (erc-log-matches erc-hide-fools my-erc-hook)))
 '(erc-text-matched-hook (quote (erc-log-matches erc-hide-fools)))
 '(erc-track-enable-keybindings t)
 '(erc-track-exclude-types (quote ("JOIN" "KICK" "NICK" "PART" "QUIT" "MODE" "333" "353")))
 '(erc-track-faces-priority-list (quote (erc-error-face (erc-nick-default-face erc-current-nick-face) erc-current-nick-face erc-keyword-face (erc-nick-default-face erc-pal-face) erc-pal-face erc-nick-msg-face erc-direct-msg-face))))

#+end_src  

***** autojoin

#+begin_src emacs-lisp :tangle no

(setq erc-autojoin-channels-alist
(quote (("localhost" "&bitlbee")
        (".*\\.freenode.net" "#emacs" "#conkeror" "#org-mode")
        ("irc.debian.org" "#freedombox"))))

(erc-autojoin-mode t)

;; (setq erc-autojoin-channels-alist
;;   '((".*\\.freenode.net" "#drupal-colorado" "#emacs" 
;;   "#fsf-members" "#erc" "#conkeror" "#org-mode")
;;      (".*\\.debian.org" "#freedombox")
;; ;;     (".*\\.gimp.org" "#unix" "#gtk+")
;; ;;     (".*\\.gnome.org" "#sparklehorse" "#gtk+")
;; ))

#+end_src 

***** erc keywords

#+begin_src emacs-lisp 

(setq erc-keywords '("\scu\s" "\stor\s" "boulder" "colorado" "Damon" "university"
   "academic" "organic groups" "relation module" "contextual filter" "gmane" "gwene"
   "usenet" "proxy" "privacy" "\ssocks\s"
   "gnus" "workgroups" "wireshark" "chaos tools" "hushmail" 
 "Stallman" "\sog\s" "compiz" "page manager" "super cookie" "[^\.]php"
   "nxhtml" "nxml" "erc\-keywords" "libnotify" "emacs 24" "org\W?mode"
   "\sunity\s" "starter\W?kit" "rate module" "conkeror" "jabber"
   "noscript" "https\-everywhere" "\wfsf\w" "\seff\s" "Log4j" "\sperl\s"
   "python" "generic-mode" "rainbow-mode" "SQLi" "sql-mode"
   "references module" "flag module" "org2blog" "nodeone" "Johan Falk"
   "singularity" "Lanier" "\serc\s" "mdb2" "\spear\s" "html5" "jquery"
   "naquadah" "mumamo" "el\-get" "zenburn" "solarized" "gunnars"
   "speedbar" "cedet" "ecb" "hook_menu_alter" "theme engine" "auto complete"
   "auto completion" "bbdb" "hippy" "\svariant\s" "json" "magit" "w3m"
   "dired" "bitcoin" ) )

;;(erc-match-enable)
(erc-match-mode 1)


#+end_src    


***** logging

#+begin_src emacs-lisp 

  (if (not (file-exists-p erc-log-channels-directory))
      (mkdir erc-log-channels-directory t))

#+end_src 

**** technomancy settings


#+begin_src emacs-lisp 

(setq erc-prompt ">")
(setq erc-autojoin-timing :ident)
(setq erc-fill-column 75)

(setq erc-track-priority-faces-only t
      erc-flood-protect nil)

(delete 'erc-fool-face 'erc-track-faces-priority-list)
(delete '(erc-nick-default-face erc-fool-face) 'erc-track-faces-priority-list)

(eval-after-load 'erc
  '(progn
     (when (not (package-installed-p 'erc-hl-nicks))
       (package-install 'erc-hl-nicks))
     (require 'erc-notify)
     (require 'erc-spelling)
     (require 'erc-truncate)
     (require 'erc-hl-nicks)
     (ignore-errors
       ;; DO NOT use the version from marmalade
       (erc-nick-notify-mode t))
     (add-to-list 'erc-modules 'hl-nicks)
     (add-to-list 'erc-modules 'spelling)
     (set-face-foreground 'erc-input-face "dim gray")
     (set-face-foreground 'erc-my-nick-face "blue")))

;; thanks to leathekd
(defvar twitter-url-pattern
  (concat "\\(https?://\\)\\(?:.*\\)?\\(twitter.com/\\)"
          "\\(?:#!\\)?\\([[:alnum:][:punct:]]+\\)")
  "Matches regular twitter urls, including those with hashbangs,
but not mobile urls.")

(defun browse-mobile-twitter (url)
  "When given a twitter url, browse to the mobile version instead"
  (string-match twitter-url-pattern url)
  (let ((protocol (match-string 1 url))
        (u (match-string 2 url))
        (path (match-string 3 url)))
    (browse-url (format "%smobile.%s%s" protocol u path) t)))

;; Need to append otherwise the urls will be picked up by
;; erc-button-url-regexp. Not sure why that is the case.
(eval-after-load 'erc-button
  '(add-to-list 'erc-button-alist
                '(twitter-url-pattern 0 t browse-mobile-twitter 0) t))


#+end_src 

*** ERC initialization

#+begin_src emacs-lisp 

(use-package erc
  ;; :commands erc
;;  :if running-alternate-emacs
  :init
  (progn
    (defun irc ()
      (interactive)
      (erc-tls :server "asimov.freenode.net"
               :port 6697
               :nick "dkh"
               :password (funcall
                          (plist-get
                           (car (auth-source-search :host "asimov.freenode.net"
                                                    :user "dkh"
                                                    :type 'netrc
                                                    :port 6667))
                           :secret))))

    (defun im ()
      (interactive)
      (erc :server "localhost"
           :port 6667
           :nick "dkh"
           :password (funcall
                      (plist-get
                       (car (auth-source-search :host "bitlbee"
                                                :user "dkh"
                                                :type 'netrc
                                                :port 6667))
                       :secret)))))

  :config
  (progn
    (erc-track-minor-mode 1)
    (erc-track-mode 1)

;;    (use-package erc-alert)
    (use-package erc-highlight-nicknames)
    (use-package erc-patch)

    (use-package erc-yank
      :init
      (bind-key "C-y" 'erc-yank erc-mode-map))

    (use-package wtf
      :commands wtf-is
      :init
      (defun erc-cmd-WTF (term &rest ignore)
        "Look up definition for TERM."
        (let ((def (wtf-is term)))
          (if def
              (let ((msg (concat "{Term} " (upcase term) " is " def)))
                (with-temp-buffer
                  (insert msg)
                  (kill-ring-save (point-min) (point-max)))
                (message msg))
            (message (concat "No definition found for " (upcase term)))))))

    (defun switch-to-bitlbee ()
      (interactive)
      (switch-to-buffer-other-window "&bitlbee")
      (call-interactively 'erc-channel-names)
      (goto-char (point-max)))

    (bind-key "C-c b" 'switch-to-bitlbee)

    (defun erc-cmd-SHOW (&rest form)
      "Eval FORM and send the result and the original form as:
FORM => (eval FORM)."
      (let* ((form-string (mapconcat 'identity form " "))
             (result
              (condition-case err
                  (eval (read-from-whole-string form-string))
                (error
                 (format "Error: %s" err)))))
        (erc-send-message (format "%s => %S" form-string result))))

    (defun erc-cmd-INFO (&rest ignore)
      "Send current info node."
      (unless (get-buffer "*info*")
        (error "No *info* buffer"))
      (let (output)
        (with-current-buffer "*info*"
          (let* ((file (file-name-nondirectory Info-current-file))
                 (node Info-current-node))
            (setq output (format "(info \"(%s)%s\") <-- hit C-x C-e to evaluate"
                                 file node))))
        (erc-send-message output)))

    (eval-when-compile
      (defvar erc-fools))

    (defun erc-cmd-FOOL (term &rest ignore)
      (add-to-list 'erc-fools term))

    (defun erc-cmd-UNFOOL (term &rest ignore)
      (setq erc-fools (delete term erc-fools)))

    (defun erc-cmd-OPME ()
      "Request chanserv to op me."
      (erc-message "PRIVMSG"
                   (format "chanserv op %s %s"
                           (erc-default-target)
                           (erc-current-nick)) nil))

    (defun erc-cmd-DEOPME ()
      "Deop myself from current channel."
      (erc-cmd-DEOP (format "%s" (erc-current-nick))))))

#+end_src       


** Download utils

#+begin_src emacs-lisp 

(require 'url)

(defun download-file (&optional url download-dir download-name)
  (interactive)
  (let ((url (or url
                 (read-string "Enter download URL: "))))
    (let ((download-buffer (url-retrieve-synchronously url)))
      (save-excursion
        (set-buffer download-buffer)
        ;; we may have to trim the http response
        (goto-char (point-min))
        (re-search-forward "^$" nil 'move)
        (forward-char)
        (delete-region (point-min) (point))
        (write-file (concat (or download-dir
                                "~/downloads/")
                            (or download-name
                                (car (last (split-string url "/" t))))))))))

#+end_src 

** Calendar
Embed location maps, with directions from home
*** General Settings
#+begin_src emacs-lisp 

  (setq calendar-latitude 40)
  (setq calendar-longitude -105)
  (setq calendar-location-name "Boulder, CO")

(setq calendar-intermonth-text
      '(propertize
        (format "%2d"
                (car
                 (calendar-iso-from-absolute
                  (calendar-absolute-from-gregorian (list month day year)))))
        'font-lock-face 'font-lock-function-name-face))

(require 'calendar)                                                                                                                                             
(defun display-a-month (day month year)                                                                                                                         
  (insert (format "%s\n" (calendar-date-string (list  month day year))))                                                                                        
  (if (< day 30)                                                                                                                                                
    (display-a-month (+ day 1) month year)))

#+end_src 

*** Calfw - A calendar framework for Emacs

#+begin_src emacs-lisp 

(require 'calfw)

(require 'calfw-org)

#+end_src 

** LDAP and bbdb

#+begin_src emacs-lisp 

(setq
 eudc-ldap-bbdb-conversion-alist (quote ((name . displayName) (net . mail) (address eudc-bbdbify-address Postaladdress "Office") (phone (eudc-bbdbify-phone telephoneNumber "Office")) (notes . title)))
 eudc-protocol (quote ldap)
 eudc-query-form-attributes (quote (name firstname email phone
 cuedupersonuuid Postaladdress)))

(setq eudc-server "directory.colorado.edu"
 ldap-host-parameters-alist
 '(("directory.colorado.edu" base "dc=colorado,dc=edu")))



(setq eudc-default-return-attributes nil
 eudc-strict-return-matches nil
 ldap-ldapsearch-args (quote ("-tt" "-LLL" "-x")))

(setq eudc-options-file "~/git/.emacs.d/.eudc-options")

#+end_src 

*** EUDC

#+begin_src emacs-lisp

(require 'ldap)
(require 'eudc)
(require 'imap)


(eudc-protocol-set 'eudc-inline-query-format
                   '((firstname)
                     (lastname)
                     (firstname lastname)
                     (net))
                    'bbdb)

(eudc-protocol-set 'eudc-inline-expansion-format
                   '("%s %s <%s>" firstname lastname net)
                   'bbdb)

(eudc-protocol-set 'eudc-inline-query-format
                   '(
                     (cn)
                     (cn cn)
                     (cn cn cn)
                     (Displayname)
                     (mail))
                   'ldap)


                   
(eudc-protocol-set 'eudc-inline-expansion-format
                   '("%s <%s>"  displayName mail)
                   'ldap)

(defun enz-eudc-expand-inline()
  (interactive)
  (move-end-of-line 1)
  (insert "*")
  (unless (condition-case nil
              (eudc-expand-inline)
            (error nil))
    (backward-delete-char-untabify 1))
  )

;; Adds some hooks

(eval-after-load "message"
  '(define-key message-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
(eval-after-load "sendmail"
  '(define-key mail-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
(eval-after-load "post"
  '(define-key post-mode-map (kbd "TAB") 'enz-eudc-expand-inline))

; Protocol local. A mapping between EUDC attribute names and corresponding
;; protocol specific names.  The following names are defined by EUDC and may be
;; included in that list: `name' , `firstname', `email', `phone'
(set eudc-protocol-attributes-translation-alist
     '(
       (fistname . Displayname)
       (name . cn)
       (email . mail)
       (phone . telephoneNumber)
       (title . title)
       )
     )

;; (provide 'dkh-directory)

#+end_src 

** Autoinstall

#+begin_src emacs-lisp :tangle no

(setq auto-install-update-emacswiki-package-name-when-startup nil
      auto-install-directory "~/.emacs.d/src/"
      auto-install-replace-confirm t
      auto-install-save-confirm t)

(require 'auto-install) ; auto update from wiki

#+end_src 

** bash completion

#+begin_src emacs-lisp 

(add-to-list 'load-path (expand-file-name "~/git/src/emacs-bash-completion"))

(require 'bash-completion)
(bash-completion-setup)

#+end_src 

** Macros

#+begin_src emacs-lisp 

(defun save-macro (name)                  
  "save a macro. Take a name as argument
   and save the last defined macro under 
   this name at the end of your .emacs"
   (interactive "SName of the macro :")  ; ask for the name of the macro    
   (kmacro-name-last-macro name)         ; use this name for the macro    
   (find-file (user-init-file))                   ; open ~/.emacs or other user init file 
   (goto-char (point-max))               ; go to the end of the .emacs
   (newline)                             ; insert a newline
   (insert-kbd-macro name)               ; copy the macro 
   (newline)                             ; insert a newline
   (switch-to-buffer nil))               ; return to the initial buffer

(defun init-macro-counter-default () "Set the initial counter to 1 and
  reset every time it's called.  To set to a different value call
  `kmacro-set-counter' interactively i.e M-x kmacro-set-counter."
  (interactive) (kmacro-set-counter 1))

(global-set-key (kbd "H-<f5>") 'init-macro-counter-default)
(global-set-key (kbd "M-<f5>") 'kmacro-insert-counter)

#+end_src 

** BBDB
#+begin_src emacs-lisp 

(setq bbdb-file "~/git/.emacs.d/.bbdb")           ;; keep ~/ clean; set before loading

(require 'bbdb-loaddefs "~/.emacs.d/src/bbdb/lisp/bbdb-loaddefs.el")

(require 'bbdb)

(bbdb-initialize 'gnus 'message)
(setq bbdb-accept-name-mismatch                 t
      bbdb-completion-display-record            nil
      bbdb-message-all-addresses                t
      bbdb-mua-update-interactive-p             '(create . query))


(defun message-read-from-minibuffer (prompt &optional initial-contents)
  "Read from the minibuffer while providing abbrev expansion."
  (bbdb-completing-read-mails prompt initial-contents))

(bbdb-mua-auto-update-init 'gnus 'message)

;; don't display a continuously-updating BBDB window while in GNUS
(setq bbdb-pop-up-layout  nil)

;;; turn on the electric mode (t) for popup behavior
;; be disposable with SPC
(setq bbdb-electric nil)

(setq
         bbdb-mail-avoid-redundancy  t ;; always use full name
    bbdb-accept-name-mismatch 2)       ;; show name-mismatches 2 secs

(setq    bbdb-completion-list t                 ;; complete on anything
    ;; allow cycling of email addresses while completing them
    bbdb-complete-mail-allow-cycling t  ;; cycle through matches
                                             ;; this only works partially (bbdb3)
)

(setq bbdb-use-alternate-names t)

(setq
       bbdb/gnus-header-prefer-real-names t
       bbdb-check-postcode t
       ;;; if non-nil, pop a database record of every mail sender when
       ;; message is viewed. If a record for a mail message does not exist,
       ;; use : to create a new one. display vbls control the popup format
       bbdb/gnus-split-nomatch-function 'nnmail-split-fancy ; change from nnimap-split-fancy - dky
       bbdb/gnus-split-myaddr-regexp 'gnus-ignored-from-addresses
       bbdb-phone-style nil
       bbdb-mail-user-agent 'gnus)  ;; (bbdb3)

#+end_src 


http://www.emacswiki.org/emacs/UpgradeBBDB

http://www.emacswiki.org/emacs/BbdbCanonicalizeAddresses

#+begin_src emacs-lisp :tangle no

(setq
       bbdb-canonicalize-mail-function
       '(lambda (net)
         (let ((buf (get-buffer gnus-article-buffer)))
           (if buf
               (save-excursion
                 (goto-char (point-min))
                 (if (and (string-match "@public.gmane.org" net)
                          (re-search-forward (format "[^:,]*<%s>" net) (point-max) t))
                     (let ((ad (mail-extract-address-components (match-string 0)))
                           realnet)
                       (message "Found `%S' in headers! Doing realname search!" ad)
                       (and (car ad)
                            (setq realnet (bbdb-search nil nil nil nil (car ad)))
                            (setq realnet (car (bbdb-record-mail realnet)))
                            (setq net realnet))))
                 net))
           net)))

;;(bbdb-records)

#+end_src 


#+begin_src emacs-lisp 


;;        (add-hook 'message-setup-hook 'bbdb-get-mail-aliases) ;; bbdb 3
(add-hook 'message-setup-hook 'bbdb-mail-aliases) ; BBDB 3.x

(require 'bbdb-message)


(defun dkh/bbdb-name ()
  "function to bbdb-search name word at point"
  (interactive)
   (let (myresult)
    (setq myresult (thing-at-point 'word))
    (bbdb-search-name myresult)
    ))

;; no default area code to use when prompting for a new phone number
(setq bbdb-default-area-code nil)

;; default country to use if none is specified
(setq bbdb-default-country "USA")

;; desired number of lines in a GNUS pop-up BBDB window
;;    (setq bbdb-pop-up-window-size  1)
    (setq bbdb-pop-up-window-size  0.5)

;; default display layout
(setq bbdb-layout 'multi-line)

;; automatically add some text to the notes field of the BBDB record
    (add-hook 'bbdb-notice-mail-hook 'bbdb-auto-notes)


(set `bbdb-auto-notes-rules
   `(
;;("From" ("@colorado" . "University of Colorado"))
("CC" ("tmr" . "OIT Managed Services"))
("To" ("-vm@" . "VM mailing list"))
    ("Subject" ("sprocket" . "mail about sprockets")
               ("you bonehead" . "called me a bonehead"))
))


;; will cause the text "VM mailing list" to be added to the notes field
;; of the records corresponding to anyone you get mail from via one of the VM
;; mailing lists.


    ;; capture auto-notes
    (setq bbdb-auto-notes-alist
          ;; organization
          `(("Organization" (".*" Organization 0))

            ;; mailer
            ("User-Agent" (".*" mailer 0 t))  ;; t = overwrite
            ("X-Mailer" (".*" mailer 0 t))
            ("X-Newsreader" (".*" mailer 0 t))

            ;; X-Face bitmaps of the people
            ("x-face" ,(list (concat "[ \t\n]*\\([^ \t\n]*\\)"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?")
                             'face
                             "\\1\\3\\5\\7"))))

(defun dkh/toggle-bbdb-mua-update-interactive-p ()
  "function to toggle bbdb-mua-update-interactive-p"
  (interactive)
(lambda ()
                (when (y-or-n-p "BBDB update interactive? ")
    (cdr bbdb-mua-update-interactive-p)
    (car bbdb-mua-update-interactive-p)
)))

(setq rs-bbdb-ignored-from-list '(
                               "@public.gmane.org"
                                "post <at> gwene.org"
                                "post@gwene.org"
                                "bozo@dev.null.invalid"
                                "no.?reply"
                                "DAEMON"
                                "daemon"
                                "facebookmail"
                                "twitter"
                                "do-not-reply"
                                "lists.math.uh.edu"
                                "emacs-orgmode-confirm"
                         "-confirm"
"gnulist"
"privacy-noreply"
"-request@kgnu.org"
"confirm-nomail"
"noreply"
"webappsec-return"
"vinylisl"
"MAILER-DAEMON"
"noreply"
"mailman-owner"
))


(setq bbdb-ignore-message-alist
      `(("From" . , (regexp-opt rs-bbdb-ignored-from-list))))


#+end_src 

* Custom functions
** Push to mark no activate

#+begin_src emacs-lisp 

(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))
(global-set-key (kbd "C-,") 'push-mark-no-activate)

#+end_src 

** Toggle Chrome

#+begin_src emacs-lisp 

(defun dkh/toggle-chrome ()
  "Show/hide toolbar and menubar."
  (interactive)
  (menu-bar-mode)
  (when (window-system)
    (tool-bar-mode)))

#+end_src

** Handle MS-Word

#+begin_src emacs-lisp 

;; this seems to enable MS-Word documents
 (defun mm-inline-msword (handle)
   (let (text)
     (with-temp-buffer
       (mm-insert-part handle)
       (call-process-region (point-min) (point-max) "antiword" t t nil "-")
       (setq text (buffer-string)))
     (mm-insert-inline handle text)))

#+end_src 
     
** Switch or start

#+begin_src emacs-lisp 

;; stolen from old starter-kit
(defun switch-or-start (function buffer)
  "If the buffer is current, bury it, otherwise invoke the function."
  (if (equal (buffer-name (current-buffer)) buffer)
      (bury-buffer)
    (if (get-buffer buffer)
        (switch-to-buffer buffer)
      (funcall function))))

#+end_src 

** Open with sudo if necessary

#+begin_src emacs-lisp 

(defun find-alternative-file-with-sudo ()
    "Open current buffer as root!"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))

(global-set-key (kbd "C-x C-t") 'find-alternative-file-with-sudo)

#+end_src 

** Opacity
#+begin_src emacs-lisp 

(defun djcb-opacity-modify (&optional dec)
  "modify the transparency of the emacs frame; if DEC is t,
    decrease the transparency, otherwise increase it in 10%-steps"
  (let* ((alpha-or-nil (frame-parameter nil 'alpha)) ; nil before setting
          (oldalpha (if alpha-or-nil alpha-or-nil 100))
          (newalpha (if dec (- oldalpha 10) (+ oldalpha 10))))
    (when (and (>= newalpha frame-alpha-lower-limit) (<= newalpha 100))
      (modify-frame-parameters nil (list (cons 'alpha newalpha))))))

 ;; C-8 will increase opacity (== decrease transparency)
 ;; C-9 will decrease opacity (== increase transparency
 ;; C-0 will returns the state to normal
(global-set-key (kbd "H-8") '(lambda()(interactive)(djcb-opacity-modify)))
(global-set-key (kbd "H-9") '(lambda()(interactive)(djcb-opacity-modify t)))
(global-set-key (kbd "H-0") '(lambda()(interactive)
                               (modify-frame-parameters nil `((alpha . 100)))))

#+end_src 

** Bracket functions

#+begin_src emacs-lisp 
(defun forward-open-bracket ()
  "Move cursor to the next occurrence of left bracket or quotation mark."
  (interactive)
  (forward-char 1)
  (search-forward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  (backward-char 1)
  )

(defun backward-open-bracket ()
  "Move cursor to the previous occurrence of left bracket or quotation mark.."
  (interactive)
  (search-backward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  )

(defun forward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (search-forward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
 )

(defun backward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (backward-char 1)
  (search-backward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
  (forward-char 1)
  )

#+end_src 
  
** Point functions

#+begin_src emacs-lisp 

(defun get-point (symbol &optional arg)
 "get the point"
 (funcall symbol arg)
 (point)
)

(defun copy-thing (begin-of-thing end-of-thing &optional arg)
  "copy thing between beg & end into kill ring"
   (save-excursion
     (let ((beg (get-point begin-of-thing 1))
        (end (get-point end-of-thing arg)))
       (copy-region-as-kill beg end)))
)

(defun paste-to-mark(&optional arg)
  "Paste things to mark, or to the prompt in shell-mode"
  (let ((pasteMe 
    (lambda()
      (if (string= "shell-mode" major-mode)
        (progn (comint-next-prompt 25535) (yank))
      (progn (goto-char (mark)) (yank) )))))
   (if arg
       (if (= arg 1)
       nil
         (funcall pasteMe))
     (funcall pasteMe))
   ))

(defun copy-word (&optional arg)
 "Copy words at point into kill-ring"
  (interactive "P")
  (copy-thing 'backward-word 'forward-word arg)
  ;;(paste-to-mark arg)
)

;; (transient-mark-mode 1)

(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

#+end_src 

** Full screen function

#+begin_src emacs-lisp 

(defun toggle-fullscreen (&optional f)
  (interactive)
  (let ((current-value (frame-parameter nil 'fullscreen)))
       (set-frame-parameter nil 'fullscreen
                            (if (equal 'fullboth current-value)
                                (if (boundp 'old-fullscreen) old-fullscreen nil)
                                (progn (setq old-fullscreen current-value)
                                       'fullboth)))))

#+end_src 

** Insert date function

#+begin_src emacs-lisp 

(defun insert-date ()
"Insert date at point."
(interactive)
(insert (format-time-string "%d.%m.%Y %H:%M")))

#+end_src 

** dos 2 unix function(s)

#+begin_src emacs-lisp 

(defun dos-to-unix ()
  "Cut all visible ^M from the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\r" nil t)
      (replace-match ""))))

(defun unix-to-dos ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\n" nil t)
      (replace-match "\r\n"))))

#+end_src 

** rename file and buffer function

#+begin_src emacs-lisp 

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

#+end_src 

** Other functions

#+begin_src emacs-lisp 

(defun remove-dupes (list)
  (let (tmp-list head)
    (while list
      (setq head (pop list))
      (unless (equal head (car list))
        (push head tmp-list)))
    (reverse tmp-list)))

(defun assoc-replace (seq values)
  "Replace an element within an association list where the cars match."
  (mapcar (lambda (elem)
            (let* ((key (car elem))
                   (val (assoc key values)))
              (if val (cadr val) elem))) seq))

(defun duplicate-current-line ()
  (interactive)
  (beginning-of-line nil)
  (let ((b (point)))
    (end-of-line nil)
    (copy-region-as-kill b (point)))
  (beginning-of-line 2)
  (open-line 1)
  (yank)
  (back-to-indentation))

(defun duplicate-current-line (&optional n)
“duplicate current line, make more than 1 copy given a numeric argument”
(interactive “p”)
(save-excursion
(let ((nb (or n 1))
(current-line (thing-at-point ‘line)))
;; when on last line, insert a newline first
(when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
(insert “\n”))

;; now insert as many time as requested
(while (> n 0)
(insert current-line)
(setq n (- n 1))))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)

(defun set-longlines-mode ()
  (interactive)
  (text-mode)
  (longlines-mode 1))

(defun regex-replace (regex string)
  (goto-char (point-min))
  (while (re-search-forward regex nil t)
    (replace-match string)))

(defun string-repeat (str n)
  (let ((retval ""))
    (dotimes (i n)
      (setq retval (concat retval str)))
    retval))

;;;###autoload

(defun grab-url-at-point-my ()
  (interactive)
  (kill-new (thing-at-point 'url)))

;;;###autoload

(defun grab-email-my ()
  "Grab the next email in the buffer
  First posted by François Fleuret <francois.fleuret@inria.fr>..
improved by many.."
  (interactive)
  (re-search-forward "[^ \t\n]+@[^ \t\n]+")
  (copy-region-as-kill (match-beginning 0) (match-end 0))
  )

(defun duplicate-line-or-region (&optional n)
  "Duplicate current line, or region if active.
With argument N, make N copies.
With negative N, comment out original line and use the absolute value."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (save-excursion
      (let ((text (if use-region        ;Get region if active, otherwise line
                      (buffer-substring (region-beginning) (region-end))
                    (prog1 (thing-at-point 'line)
                      (end-of-line)
                      (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                          (newline))))))
        (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
          (insert text))))
    (if use-region nil                  ;Only if we're working with a line (not a region)
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (if (> 0 n)                             ;Comment out original with negative arg
            (comment-region (line-beginning-position) (line-end-position)))
        (forward-line 1)
        (forward-char pos)))))

(defun increment (n) (interactive "p")
 ;; Increment the number after point.  With an argument, add that much.
 (let (val)
   (delete-region
    (point)
    (progn
      (setq val (read (current-buffer)))
      (if (not (numberp val)) (error "Not in front of a number"))
      (point)))
   (insert (int-to-string (+ val n)))))
(global-set-key "\C-c+" 'increment)

;; Macro way
;; from insert-kbd-macro
(fset 'ucase_between_quotes
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([18 34 67108896 19 34 19 24 21] 0 "%d")) arg)))

;;;  Create a thing type for double-quote delimited "string"
(put 'string 'bounds-of-thing-at-point
     (lambda () (thing-at-point-bounds-of-delimited-thing-at-point "\"")))

(defun dkh/select_q_string_region ()
  "Select the region of string at point"
  (interactive)
  (thing-region "string"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Get IP Address
;; http://emacs-fu.blogspot.com/2009/05/getting-your-ip-address.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun get-ip-address (&optional dev)
  "get the IP-address for device DEV (default: eth0)"
  (interactive)
  (let ((dev (if dev dev "eth0")))
    (format-network-address (car (network-interface-info dev)) t)))

;; http://snipplr.com/view.php?codeview&id=34032

(defun get-ip-addresses ()
  "Returns the current system IPv4 addresses as a list of
strings"
  (let* ((start 0)
; (match-positions ())
(ip-re "[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?")
;; The rest of these variables try to make this platform agnostic.
;; Add more on to the cond statements if you need
(ipconfig (cond ((eq system-type 'windows-nt)
"ipconfig")
((eq system-type 'gnu/linux)
"/sbin/ifconfig")
((eq system-type 'darwin)
"/sbin/ifconfig")
(t (error "Don't know how to get-ip-address for %s"
system-type))))
(line-re (cond ((eq system-type 'windows-nt)
"IPv4 Address.*")
((eq system-type 'gnu/linux)
(concat "inet addr:" ip-re))
((eq system-type 'darwin)
(concat "inet " ip-re))
(t (error "Don't know how regex out ip line for %s"
system-type))))
;; I lied, not all of the rest of the variables are to make it
;; platform agnostic. This is where we grab the output
(output (shell-command-to-string ipconfig)))

    ;; The inner loop is a bit funky since I can't seem to get it to behave
    ;; exactly like Common Lisp
    (loop for pos in
(loop named inner
with match-positions = ()
do (let ((ret (string-match line-re output start)))
(if ret
(setq start (1+ ret))
(return-from inner match-positions))
(setq match-positions
(append match-positions (list ret)))))
collect (progn
(string-match ip-re output pos)
(match-string 0 output)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Reload current file with position saved
;; http://www.thekidder.net/2008/10/21/emacs-reload-file/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun reload-file ()
  (interactive)
  (let ((curr-scroll (window-vscroll)))
    (find-file (buffer-name))
    (set-window-vscroll nil curr-scroll)
    (message "Reloaded file")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Edit files as root
;; http://nflath.com/2009/08/tramp/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sudo-edit (&optional arg)
  (interactive "p")
  (if arg
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(defun sudo-edit-current-file ()
  (interactive)
  (let ((pos (point)))
    (find-alternate-file
     (concat "/sudo:root@localhost:" (buffer-file-name (current-buffer))))
    (goto-char pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rename a file and the buffer it's in at the same time
;; Via yeggeconf http://sites.google.com/site/steveyegge2/my-dot-emacs-file
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file name new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Abort minibuffer when mousing
;; http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun stop-using-minibuffer ()
  "kill the minibuffer"
  (when (>= (recursion-depth) 1)
    (abort-recursive-edit)))

(add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Random crap
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; http://www.emacswiki.org/emacs/ElispCookbook
(defun qdot/filter (condp lst)
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

;; http://stackoverflow.com/questions/2238418/emacs-lisp-how-to-get-buffer-major-mode
(defun qdot/buffer-mode (buffer-or-string)
  "Returns the major mode associated with a buffer."
  (save-excursion
     (set-buffer buffer-or-string)
     major-mode))

(defun qdot/open-in-browser()
  (interactive)
  (let ((filename (buffer-file-name)))
    (browse-url (concat "file://" filename))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun shell-current-directory ()
  "Opens a shell in the current directory"
  (interactive)
  (shell (concat "shell-" default-directory "-shell" )))

;; http://blog.tuxicity.se/elisp/emacs/2010/11/16/delete-file-and-buffer-in-emacs.html
(defun delete-this-buffer-and-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; http://www.reddit.com/r/emacs/comments/jfrqm/what_does_your_tab_key_do/
(defun smart-tab ()
  "If mark is active, indents region. Else if point is at the end of a symbol,
expands it. Else indents the current line. Acts as normal in minibuffer."
  (interactive)
  (cond (mark-active (indent-region (region-beginning) (region-end)))
        ((and (looking-at "\\_>") (not (looking-at "end")))
         (hippie-expand nil))
        (t (indent-for-tab-command))))

(defun dkh-shell-with-name (name)
  (interactive "sName: ")
  "Creates a shell with name given by the first argument, and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*eshell-" (wg-name (wg-current-workgroup)) "-" name "*")))
       (localdir name))
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (eshell)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*eshell-" (wg-name (wg-current-workgroup)) "-" name "*")))))))


(defun dkh-eshell-macs ()
  (interactive)
  "Creates a tool config shell and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*eshell-" (wg-name (wg-current-workgroup)) "-tool-config*")))
        (default-directory "~/git/ewax"))
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (eshell t)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*eshell-" (wg-name (wg-current-workgroup)) "-tool-config*")))))))

(message (concat "0 " (buffer-name) "... Done"))

(defun cat-command ()
  "A command for cats."
  (interactive)
  (require 'animate)
  (let ((mouse "
           ___00
        ~~/____'>
          \"  \"")
        (h-pos (floor (/ (window-height) 2)))
        (contents (buffer-string))
        (mouse-buffer (generate-new-buffer "*mouse*")))
    (save-excursion
      (switch-to-buffer mouse-buffer)
      (insert contents)
      (setq truncate-lines t)
      (animate-string mouse h-pos 0)
      (dotimes (_ (window-width))
        (sit-for 0.01)
        (dotimes (n 3)
          (goto-line (+ h-pos n 2))
          (move-to-column 0)
          (insert " "))))
    (kill-buffer mouse-buffer)))

#+end_src 

** toggle line spacing function

#+begin_src emacs-lisp 

(defun toggle-line-spacing ()
  "Toggle line spacing between no extra space to extra half line height."
  (interactive)
  (if (eq line-spacing nil)
      (setq-default line-spacing 0.5) ; add 0.5 height between lines
    (setq-default line-spacing nil)   ; no extra heigh between lines
    )
  (redraw-display))

#+end_src 

** Insert filename function

#+begin_src emacs-lisp 

(defun my-insert-file-name (filename &optional args)
  "Insert name of file FILENAME into buffer after point.

Prefixed with \\[universal-argument], expand the file name to
its fully canocalized path.  See `expand-file-name'.

Prefixed with \\[negative-argument], use relative path to file
name from current directory, `default-directory'.  See
`file-relative-name'.

The default with no prefix is to insert the file name exactly as
it appears in the minibuffer prompt."
  ;; Based on insert-file in Emacs -- ashawley 20080926
  (interactive "*fInsert file name: \nP")
  (cond ((eq '- args)
         (insert (file-relative-name filename)))
        ((not (null args))
         (insert (expand-file-name filename)))
        (t
         (insert filename))))

(global-set-key (kbd "C-H-f") 'my-insert-file-name)

(autoload 'ffap-guesser "ffap")
(autoload 'ffap-read-file-or-url "ffap")

(defun my-replace-file-at-point (currfile newfile)
  "Replace CURRFILE at point with NEWFILE.

When interactive, CURRFILE will need to be confirmed by user
and will need to exist on the file system to be recognized,
unless it is a URL.

NEWFILE does not need to exist.  However, Emacs's minibuffer
completion can help if it needs to be.

Based on `ffap'."
  (interactive
   (let ((currfile (ffap-read-file-or-url "Replace filename: "
                                          (ffap-guesser))))
     (list currfile
           (ffap-read-file-or-url (format "Replace `%s' with: "
                                          currfile) currfile))))
  (save-match-data
    (if (or (looking-at (regexp-quote currfile))
            (let ((filelen (length currfile))
                  (opoint (point))
                  (limit (+ (point) (length currfile))))
              (save-excursion
                (goto-char (1- filelen))
                (and (search-forward currfile limit
                                     'noerror)
                     (< (match-beginning 0) opoint))
                     (>= (match-end 0) opoint))))
        (replace-match newfile)
      (error "No file at point to replace"))))

(global-set-key (kbd "C-H-v") 'my-replace-file-at-point)

(message "0 dkh-insert-filename... Done")

(defun get-relative-line-content (num)
  "Return the string content of line `num' relative to the current line"
  (save-excursion
    (forward-line num)
    (buffer-substring-no-properties
     (line-beginning-position) (line-end-position))))

(defun insert-line-same ()
  "Insert the content up to the first difference of the previous two lines."
  (interactive)
  (let* ((line1 (get-relative-line-content -2))
    (line2 (get-relative-line-content -1))
      (beg (current-column))
      (end (compare-strings line1 beg nil line2 beg nil)))
    (insert-string
     (substring line1 beg
            (if (integerp end)
                (+ beg (- (abs end) 1))
              (length line1))))))

#+end_src

** jwiegley functions
#+begin_src emacs-lisp 

(defun system-idle-time ()
  (with-temp-buffer
    (call-process "ioreg" nil (current-buffer) nil
                  "-c" "IOHIDSystem" "-d" "4" "-S")
    (goto-char (point-min))
    (and (re-search-forward "\"HIDIdleTime\" = \\([0-9]+\\)" nil t)
         (/ (float (string-to-number (match-string 1)))
            1000000000.0))))

(defun quickping (host)
  (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))

(defun collapse-or-expand ()
  (interactive)
  (if (> (length (window-list)) 1)
      (delete-other-windows)
    (bury-buffer)))

(bind-key "C-H-z" 'collapse-or-expand)

(defun align-code (beg end &optional arg)
  (interactive "rP")
  (if (null arg)
      (align beg end)
    (let ((end-mark (copy-marker end)))
      (indent-region beg end-mark nil)
      (align beg end-mark))))

(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))

(defun mark-line (&optional arg)
  (interactive "p")
  (beginning-of-line)
  (let ((here (point)))
    (dotimes (i arg)
      (end-of-line))
    (set-mark (point))
    (goto-char here)))

(defun mark-sentence (&optional arg)
  (interactive "P")
  (backward-sentence)
  (mark-end-of-sentence arg))

(defun isearch-backward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-backward))

(defun isearch-forward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-forward))

(defun duplicate-line ()
  "Duplicate the line containing point."
  (interactive)
  (save-excursion
    (let (line-text)
      (goto-char (line-beginning-position))
      (let ((beg (point)))
        (goto-char (line-end-position))
        (setq line-text (buffer-substring beg (point))))
      (if (eobp)
          (insert ?\n)
        (forward-line))
      (open-line 1)
      (insert line-text))))

(defun refill-paragraph (arg)
  (interactive "*P")
  (let ((fun (if (memq major-mode '(c-mode c++-mode))
                 'c-fill-paragraph
               (or fill-paragraph-function
                   'fill-paragraph)))
        (width (if (numberp arg) arg))
        prefix beg end)
    (forward-paragraph 1)
    (setq end (copy-marker (- (point) 2)))
    (forward-line -1)
    (let ((b (point)))
      (skip-chars-forward "^A-Za-z0-9`'\"(")
      (setq prefix (buffer-substring-no-properties b (point))))
    (backward-paragraph 1)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (delete-horizontal-space)
    (while (< (point) end)
      (delete-indentation 1)
      (end-of-line))
    (let ((fill-column (or width fill-column))
          (fill-prefix prefix))
      (if prefix
          (setq fill-column
                (- fill-column (* 2 (length prefix)))))
      (funcall fun nil)
      (goto-char beg)
      (insert prefix)
      (funcall fun nil))
    (goto-char (+ end 2))))


(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))

(defun do-eval-buffer ()
  (interactive)
  (call-interactively 'eval-buffer)
  (message "Buffer has been evaluated"))

(defun find-which (name)
  (interactive "sCommand name: ")
  (find-file-other-window
   (substring (shell-command-to-string (format "which %s" name)) 0 -1)))


(defun my-describe-symbol  (symbol &optional mode)
  (interactive
   (info-lookup-interactive-arguments 'symbol current-prefix-arg))
  (let (info-buf find-buf desc-buf cust-buf)
    (save-window-excursion
      (ignore-errors
        (info-lookup-symbol symbol mode)
        (setq info-buf (get-buffer "*info*")))
      (let ((sym (intern-soft symbol)))
        (when sym
          (if (functionp sym)
              (progn
                (find-function sym)
                (setq find-buf (current-buffer))
                (describe-function sym)
                (setq desc-buf (get-buffer "*Help*")))
            (find-variable sym)
            (setq find-buf (current-buffer))
            (describe-variable sym)
            (setq desc-buf (get-buffer "*Help*"))
            ;;(customize-variable sym)
            ;;(setq cust-buf (current-buffer))
            ))))

    (delete-other-windows)

    (flet ((switch-in-other-buffer
            (buf)
            (when buf
              (split-window-vertically)
              (switch-to-buffer-other-window buf))))
      (switch-to-buffer find-buf)
      (switch-in-other-buffer desc-buf)
      (switch-in-other-buffer info-buf)
      ;;(switch-in-other-buffer cust-buf)
      (balance-windows))))

(defun scratch ()
  (interactive)
  (let ((current-mode major-mode))
    (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
    (goto-char (point-min))
    (when (looking-at ";")
      (forward-line 4)
      (delete-region (point-min) (point)))
    (goto-char (point-max))
    (if (eq current-mode 'emacs-lisp-mode)
        (funcall current-mode))))


#+end_src 

** copy rectangle text to clipboard
#+begin_src emacs-lisp 


(defun copy-rectangle-to-clipboard (p1 p2)
  "Copy region as column (rectangle) to operating system's clipboard.
This command will also put the text in register 0. (see: `copy-to-register')"
  (interactive "r")
  (let ((x-select-enable-clipboard t))
    (copy-rectangle-to-register ?0 p1 p2)
    (kill-new
     (with-temp-buffer
       (insert-register ?0)
       (buffer-string) )) ) )

#+end_src 
* Value added packages
** Abbrev
I like abbrev cause it saves typing

#+begin_src emacs-lisp 

(setq abbrev-file-name "~/git/.emacs.d/.abbrev_defs")
(read-abbrev-file abbrev-file-name t)
(setq dabbrev-case-replace nil)  ; Preserve case when expanding

;;(setq abbrev-mode t)
;;(setq-default abbrev-mode t)

#+end_src 


#+begin_src emacs-lisp 

(use-package abbrev
  :commands abbrev-mode
  :diminish abbrev-mode
  :init
  (hook-into-modes #'abbrev-mode '(text-mode-hook))

  :config
  (progn
   (if (file-exists-p abbrev-file-name)
       (quietly-read-abbrev-file))

   (add-hook 'expand-load-hook
             (lambda ()
               (add-hook 'expand-expand-hook 'indent-according-to-mode)
               (add-hook 'expand-jump-hook 'indent-according-to-mode)))))

#+end_src

** Ace-Jump
#+begin_src emacs-lisp 

(use-package ace-jump-mode
  :bind ("H-<return>" . ace-jump-mode))


#+end_src 

** allout

#+begin_src emacs-lisp

(use-package allout
  :diminish allout-mode
  :commands allout-mode
  :config
  (progn
    (defvar allout-unprefixed-keybindings nil)

    (defun my-allout-mode-hook ()
      (dolist (mapping '((?b . allout-hide-bodies)
                         (?c . allout-hide-current-entry)
                         (?l . allout-hide-current-leaves)
                         (?i . allout-show-current-branches)
                         (?e . allout-show-entry)
                         (?o . allout-show-to-offshoot)))
        (bind-key (concat (format-kbd-macro allout-command-prefix)
                          " " (char-to-string (car mapping)))
                  (cdr mapping)
                  allout-mode-map))

      (if (memq major-mode '(emacs-lisp-mode lisp-interaction-mode))
          (unbind-key "C-k" allout-mode-map)))

    (add-hook 'allout-mode-hook 'my-allout-mode-hook)))

#+end_src 
    
** ascii

#+begin_src emacs-lisp :tangle no

(use-package ascii
  :commands ascii-on
  :init
  (progn
    (defun ascii-toggle ()
      (interactive)
      (if ascii-display
          (ascii-off)
        (ascii-on)))

    (bind-key "C-c e A" 'ascii-toggle)))

#+end_src     

** archive-region

#+begin_src emacs-lisp :tangle no

(use-package archive-region
  :commands kill-region-or-archive-region
  :bind ("C-w" . kill-region-or-archive-region))

#+end_src 

** auctex

#+begin_src emacs-lisp

(use-package tex-site
  :load-path "site-lisp/auctex/preview/"
  :defines (latex-help-cmd-alist
            latex-help-file)
  ;; jww (2012-06-15): Do I want to use AucTeX for texinfo-mode?
  :mode ("\\.tex\\'" . latex-mode)
  :config
  (progn
    (defun latex-help-get-cmd-alist () ;corrected version:
      "Scoop up the commands in the index of the latex info manual.
   The values are saved in `latex-help-cmd-alist' for speed."
      ;; mm, does it contain any cached entries
      (if (not (assoc "\\begin" latex-help-cmd-alist))
          (save-window-excursion
            (setq latex-help-cmd-alist nil)
            (Info-goto-node (concat latex-help-file "Command Index"))
            (goto-char (point-max))
            (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
              (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                    (value (buffer-substring (match-beginning 2)
                                             (match-end 2))))
                (add-to-list 'latex-help-cmd-alist (cons key value))))))
      latex-help-cmd-alist)

    (use-package latex-mode
      :defer t
      :config
      (info-lookup-add-help :mode 'latex-mode
                            :regexp ".*"
                            :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                            :doc-spec '(("(latex2e)Concept Index" )
                                        ("(latex2e)Command Index"))))))

#+end_src 

** auto-complete

#+begin_src emacs-lisp 

(use-package auto-complete-config
  :commands auto-complete-mode
  :diminish auto-complete-mode
  :config
  (progn
    (ac-set-trigger-key "TAB")
    (setq ac-use-menu-map t)))

#+end_src     

** Autorevert

whenever an external process changes a file underneath emacs, and
there was no unsaved changes in the corresponding buffer, just revert
its content to reflect what's on-disk.

#+begin_src emacs-lisp 

(use-package autorevert
  :commands auto-revert-mode
  :diminish auto-revert-mode
  :init
  (add-hook 'find-file-hook
            #'(lambda ()
                (auto-revert-mode 1))))

#+end_src 

** backup-each-save

#+begin_src emacs-lisp :tangle no

(use-package backup-each-save
  :defer t
  :init
  (progn
    (autoload 'backup-each-save "backup-each-save")
    (add-hook 'after-save-hook 'backup-each-save))

  :config
  (progn
    (defun backup-each-save-filter (filename)
      (not (string-match
            (concat "\\(^/tmp\\|\\.emacs\\.d/data\\(-alt\\)?/"
                    "\\|\\.newsrc\\(\\.eld\\)?\\)")
            filename)))

    (setq backup-each-save-filter-function 'backup-each-save-filter)

    (defun my-dont-backup-files-p (filename)
      (unless (string-match filename "/\\(archive/sent/\\|recentf$\\)")
        (normal-backup-enable-predicate filename)))

    (setq backup-enable-predicate 'my-dont-backup-files-p)))

#+end_src 

** bookmarks

#+begin_src emacs-lisp 

(setq bm-repository-file "~/git/.emacs.d/.bm-repository")


;; (setq bm-restore-repository-on-load t)
;; 
;; ;; make bookmarks persistent as default
;; (setq-default bm-buffer-persistence t)
;;  
;; ;; Loading the repository from file when on start up.
;; (add-hook' after-init-hook 'bm-repository-load)
;;  
;; ;; Restoring bookmarks when on file find.
;; (add-hook 'find-file-hooks 'bm-buffer-restore)
;;  
;; ;; Saving bookmark data on killing a buffer
;; (add-hook 'kill-buffer-hook 'bm-buffer-save)
;;  
;; ;; Saving the repository to file when on exit.
;; ;; kill-buffer-hook is not called when emacs is killed, so we
;; ;; must save all bookmarks first.
;; (add-hook 'kill-emacs-hook '(lambda nil
;;                               (bm-buffer-save-all)
;;                               (bm-repository-save)))

(use-package bm
  :pre-init
  (progn
    (defvar ctl-period-breadcrumb-map)
    (define-prefix-command 'ctl-period-breadcrumb-map)
    (bind-key "C-. b" 'ctl-period-breadcrumb-map))

  :bind (("C-. b b" . bm-last-in-previous-buffer)
         ("C-. b f" . bm-first-in-next-buffer)
         ("C-. b g" . bm-previous)
         ("C-. b l" . bm-show-all)
         ("C-. b m" . bm-toggle)
         ("C-. b n" . bm-next)
         ("C-. b p" . bm-previous)))

#+end_src 

** Bittlebee


[[http://emacs-fu.blogspot.com/2012/03/social-networking-with-bitlbee-and-erc.html][social networking with bitlbee and erc]]

#+begin_src emacs-lisp :tangle no

(defun i-wanna-be-social ()
  "Connect to IM networks using bitlbee."
  (interactive)
  (erc :server "localhost" :port 6667 :nick "dkh")
)

(defun bitlbee-identify ()
    (require 'bitlbee-secrets "~/git/.emacs.d/.secret/bitlbee-secrets.el.gpg")
  (when (and (string= "localhost" erc-session-server)
          (string= "&bitlbee" (buffer-name)))
        (erc-message "PRIVMSG" (format "%s identify dkh secretpassword"
                             (erc-default-target)
                             dkh-bitlbee-password))))

#+end_src 



*** The ICQ white pages

Ever wondered what this 938748324 person is that sends messages to
you. AFAIK bitlbee has no builtin support to query the white pages of
ICQ, therefore i quickly hacked up this one:

#+begin_src emacs-lisp 

(defun erc-cmd-ICQWHOIS (uin)
  "Queries icq-user with UIN `uin', and returns the result."
  (let* ((result (myerc-query-icq-user uin))
         (fname (cdr (assoc 'fname result)))
         (lname (cdr (assoc 'lname result)))
         (nick (cdr (assoc 'nick result))))
    (erc-display-message nil 'notice (current-buffer) (format "%s (%s %s)" nick fname lname))))

#+end_src 

** Bookmarks
*** Bookmark locations

#+begin_src emacs-lisp 

(setq bookmark-default-file "~/git/.emacs.d/.emacs.bmk")

(setq bmkp-last-as-first-bookmark-file "~/git/.emacs.d/.emacs.bmk")

(setq bmkp-bmenu-state-file "~/git/.emacs.d/.emacs-bmk-bmenu-state.el")

#+end_src 

*** Bookmark+

#+begin_src emacs-lisp 

(use-package bookmark
;;  :disabled t
  :defer t
  :config
  (progn
    (use-package bookmark+)

    (defun my-bookmark-set ()
      (interactive)
      (flet ((bmkp-completing-read-lax
              (prompt &optional default alist pred hist)
              (completing-read prompt alist pred nil nil hist default)))
        (call-interactively #'bookmark-set)))

    (bind-key "C-x r m" 'my-bookmark-set)))

#+end_src


** browse-kill-ring+

#+begin_src emacs-lisp 

(use-package browse-kill-ring+)

#+end_src                               

** color-moccur

#+begin_src emacs-lisp 


(let ((ad-redefinition-action 'accept))
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind ("M-s O" . moccur)
    :init
    (progn
      (bind-key "M-o" 'isearch-moccur isearch-mode-map)
      (bind-key "M-O" 'isearch-moccur-all isearch-mode-map))

    :config
    (use-package moccur-edit)))

#+end_src

** crosshairs

#+begin_src emacs-lisp :tangle no

(use-package crosshairs
  :bind ("M-o c" . crosshairs-mode))

#+end_src 

** css-mode

#+begin_src emacs-lisp 

(use-package css-mode
  :mode ("\\.css\\'" . css-mode))

#+end_src

#+begin_src emacs-lisp 

(add-hook 'css-mode-hook 'rainbow-mode)

#+end_src 

** debbugs

#+begin_src emacs-lisp :tangle no

(use-package debbugs
  :commands (debbugs-gnu debbugs-gnu-search))

#+end_src 

** dedicated

#+begin_src emacs-lisp :tangle no

(use-package dedicated
  :bind ("C-. d" . dedicated-mode))

#+end_src 

** Dictem

#+begin_src emacs-lisp 

(setq dictem-server "localhost")
(require 'dictem)

;;  http://www.myrkr.in-berlin.de/dictionary/

; SEARCH = MATCH + DEFINE
; Ask for word, database and search strategy
; and show definitions found

; SHOW DB
; Show a list of databases provided by DICT server
(global-set-key "\C-c\M-b" 'dictem-run-show-databases)

(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)
(define-key dictem-mode-map [return] 'dictem-run-search)

(dictem-initialize)

(defun my-dictem-run-search ()
  "Look up definitions for word at point."
  (interactive)
  (dictem-run 'dictem-base-search "*" (thing-at-point 'word) ".")
  (other-window 1))

;;;###autoload

(defun rgr/synonyms()
 (interactive)
 (let* ((default (thing-at-point 'symbol))
        (term (read-string (format "Synonyms for (%s): "
                                   default) default)))
   (dictem-run
    'dictem-base-search
    "moby-thes" term "exact")))

(define-key mode-specific-map [?S] 'rgr/synonyms)

(dictem-initialize)

;; junk

;; moby-thes is not a valid database, use -D for a list
;; No matches found for "junk"

    ;; For creating hyperlinks on database names and found matches.
    ;; Click on them with `mouse-2'
(add-hook 'dictem-postprocess-match-hook
         'dictem-postprocess-match)

    ;; For highlighting the separator between the definitions found.
    ;; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-separator)

    ;; For creating hyperlinks in dictem buffer that contains definitions.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-hyperlinks)

    ;; For creating hyperlinks in dictem buffer that contains information
    ;; about a database.
(add-hook 'dictem-postprocess-show-info-hook
         'dictem-postprocess-definition-hyperlinks)

(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-each-definition)



(define-key flyspell-mode-map (kbd "C-+") 'flyspell-check-previous-highlighted-word)
(define-key flyspell-mode-map (kbd "C-#") 'flyspell-auto-correct-previous-word)
(define-key flyspell-mode-map (kbd "S-<f2>") 'ispell-word)
(define-key flyspell-mode-map (kbd "C-<f2>") 'flyspell-auto-correct-previous-word)

(setq synonyms-file "~/.emacs.d/thesaurus/mthesaur.txt")
(setq synonyms-cache-file "~/.emacs.d/thesaurus/syn.cache")
(setq synonyms-match-more-flag nil)

(require 'synonyms)
(define-key mode-specific-map [?S] 'synonyms)

(define-key mode-specific-map [?s] 'dictem-run-search)


(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)

; For creating hyperlinks on database names
                                      ; and found matches.
                                      ; Click on them with mouse-2
(add-hook 'dictem-postprocess-match-hook
        'dictem-postprocess-match)

        ; For highlighting the separator between the definitions found.
        ; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook 
        'dictem-postprocess-definition-separator)

        ; For creating hyperlinks in dictem buffer
                                      ; that contains definitions.
(add-hook 'dictem-postprocess-definition-hook 
        'dictem-postprocess-definition-hyperlinks)

        ; For creating hyperlinks in dictem buffer
        ; that contains information about a database.
(add-hook 'dictem-postprocess-show-info-hook
        'dictem-postprocess-definition-hyperlinks)


#+end_src 

** diff-mode

#+begin_src emacs-lisp 

(use-package diff-mode
  :commands diff-mode
  :config
  (use-package diff-mode-))

#+end_src 

** dired

#+begin_src emacs-lisp 

(use-package dired
  :defer t
  :config
  (progn
    (defun dired-package-initialize ()
      (unless (featurep 'dired-async)
        (use-package dired-x)
;;        (use-package dired-async)
        (use-package dired-sort-map)
        (use-package runner)

        (setq dired-use-ls-dired t)

        (bind-key "l" 'dired-up-directory dired-mode-map)

        (defun my-dired-switch-window ()
          (interactive)
          (if (eq major-mode 'sr-mode)
              (call-interactively #'sr-change-window)
            (call-interactively #'other-window)))

        (bind-key "<tab>" 'my-dired-switch-window dired-mode-map)

        (bind-key "M-!" 'async-shell-command dired-mode-map)
        (unbind-key "M-G" dired-mode-map)
        (unbind-key "M-s f" dired-mode-map)

        (defadvice dired-omit-startup (after diminish-dired-omit activate)
          "Make sure to remove \"Omit\" from the modeline."
          (diminish 'dired-omit-mode) dired-mode-map)

        (defadvice dired-next-line (around dired-next-line+ activate)
          "Replace current buffer if file is a directory."
          ad-do-it
          (while (and  (not  (eobp)) (not ad-return-value))
            (forward-line)
            (setq ad-return-value(dired-move-to-filename)))
          (when (eobp)
            (forward-line -1)
            (setq ad-return-value(dired-move-to-filename))))

        (defadvice dired-previous-line (around dired-previous-line+ activate)
          "Replace current buffer if file is a directory."
          ad-do-it
          (while (and  (not  (bobp)) (not ad-return-value))
            (forward-line -1)
            (setq ad-return-value(dired-move-to-filename)))
          (when (bobp)
            (call-interactively 'dired-next-line)))

        (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))

        ;; Omit files that Git would ignore
        (defun dired-omit-regexp ()
          (let ((file (expand-file-name ".git"))
                parent-dir)
            (while (and (not (file-exists-p file))
                        (progn
                          (setq parent-dir
                                (file-name-directory
                                 (directory-file-name
                                  (file-name-directory file))))
                          ;; Give up if we are already at the root dir.
                          (not (string= (file-name-directory file)
                                        parent-dir))))
              ;; Move up to the parent dir and try again.
              (setq file (expand-file-name ".git" parent-dir)))
            ;; If we found a change log in a parent, use that.
            (if (file-exists-p file)
                (let ((regexp (funcall dired-omit-regexp-orig))
                      (omitted-files
                       (shell-command-to-string "git clean -d -x -n")))
                  (if (= 0 (length omitted-files))
                      regexp
                    (concat
                     regexp
                     (if (> (length regexp) 0)
                         "\\|" "")
                     "\\("
                     (mapconcat
                      #'(lambda (str)
                          (concat
                           "^"
                           (regexp-quote
                            (substring str 13
                                       (if (= ?/ (aref str (1- (length str))))
                                           (1- (length str))
                                         nil)))
                           "$"))
                      (split-string omitted-files "\n" t)
                      "\\|")
                     "\\)")))
              (funcall dired-omit-regexp-orig))))))

    (add-hook 'dired-mode-hook 'dired-package-initialize)

    (defun dired-double-jump (first-dir second-dir)
      (interactive
       (list (ido-read-directory-name "First directory: "
                                      (expand-file-name "~")
                                      nil nil "dl/")
             (ido-read-directory-name "Second directory: "
                                      (expand-file-name "~")
                                      nil nil "Archives/")))
      (dired first-dir)
      (dired-other-window second-dir))

    (bind-key "C-c J" 'dired-double-jump)))

#+end_src

** doxymacs

#+begin_src emacs-lisp :tangle no

(use-package doxymacs
  :disabled t
  :load-path "site-lisp/doxymacs/lisp/")

#+end_src 

** ediff

#+begin_src emacs-lisp 

(use-package ediff
  :defer t
  :config
  (progn
    (defun ediff-keep-both ()
      (interactive)
      (with-current-buffer ediff-buffer-C
        (beginning-of-line)
        (assert (or (looking-at "<<<<<<")
                    (re-search-backward "^<<<<<<" nil t)
                    (re-search-forward "^<<<<<<" nil t)))
        (beginning-of-line)
        (let ((beg (point)))
          (forward-line)
          (delete-region beg (point))
          (re-search-forward "^>>>>>>>")
          (beginning-of-line)
          (setq beg (point))
          (forward-line)
          (delete-region beg (point))
          (re-search-forward "^#######")
          (beginning-of-line)
          (setq beg (point))
          (re-search-forward "^=======")
          (beginning-of-line)
          (forward-line)
          (delete-region beg (point)))))

    (add-hook 'ediff-keymap-setup-hook
              #'(lambda ()
                  (bind-key "c" 'ediff-keep-both ediff-mode-map)))

    (defun keep-mine ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (goto-char (match-beginning 0))
      (let ((beg (point))
            (hashes (re-search-forward "^#######" (+ (point) 10000) t)))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward (if hashes "^>>>>>>>" "^======="))
        (setq beg (match-beginning 0))
        (re-search-forward (if hashes "^=======" "^>>>>>>>"))
        (forward-line)
        (delete-region beg (point))))

    (defun keep-theirs ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (goto-char (match-beginning 0))
      (let ((beg (point))
            (hashes (re-search-forward "^#######" (+ (point) 10000) t)))
        (re-search-forward (if hashes "^>>>>>>>" "^======="))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward (if hashes "^#######" "^>>>>>>>"))
        (beginning-of-line)
        (setq beg (point))
        (when hashes
          (re-search-forward "^=======")
          (beginning-of-line))
        (forward-line)
        (delete-region beg (point))))

    (defun keep-both ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (beginning-of-line)
      (let ((beg (point)))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward "^>>>>>>>")
        (beginning-of-line)
        (setq beg (point))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward "^#######")
        (beginning-of-line)
        (setq beg (point))
        (re-search-forward "^=======")
        (beginning-of-line)
        (forward-line)
        (delete-region beg (point))))))

#+end_src

** edit-server

#+begin_src emacs-lisp 

(use-package edit-server
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive))
  :init
  (progn
    (add-hook 'after-init-hook 'server-start t)
    (add-hook 'after-init-hook 'edit-server-start t)))

#+end_src 
    
** emms

#+begin_src emacs-lisp :tangle no

(use-package emms-setup
  :load-path "site-lisp/emms/lisp"
  :defines emms-info-functions
  :commands (emms-all emms-devel)
  :init
  (progn
    (defvar emms-initialized nil)

    (defun my-emms ()
      (interactive)
      (unless emms-initialized
        (emms-devel)
        (emms-default-players)
        (require 'emms-info-libtag)
        (setq emms-info-functions '(emms-info-libtag))
        (setq emms-initialized t))
      (call-interactively #'emms-smart-browse))

    (bind-key "C-. M" 'my-emms))

  :config
  (progn
    (bind-key "S-<f7>" 'emms-previous)
    (bind-key "S-<f8>" 'emms-pause)
    (bind-key "S-<f9>" 'emms-next)

    (defun emms-player-mplayer-volume-up ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume 1\n"))

    (defun emms-player-mplayer-volume-down ()
      "Depends on mplayer’s -slave mode."
      (interactive)
      (process-send-string
       emms-player-simple-process-name "volume -1\n"))

    (bind-key "C-. C--" 'emms-player-mplayer-volume-down)
    (bind-key "C-. C-=" 'emms-player-mplayer-volume-up)))

#+end_src 

** eshell

#+begin_src emacs-lisp

(use-package eshell
  :defer t
  :init
  (progn
    (defun eshell-initialize ()
      (defun eshell-spawn-external-command (beg end)
        "Parse and expand any history references in current input."
        (save-excursion
          (goto-char end)
          (when (looking-back "&!" beg)
            (delete-region (match-beginning 0) (match-end 0))
            (goto-char beg)
            (insert "spawn "))))

      (add-hook 'eshell-expand-input-functions 'eshell-spawn-external-command)

      (defun ss (server)
        (interactive "sServer: ")
        (call-process "spawn" nil nil nil "ss" server))

      (eval-after-load "em-unix"
        '(unintern 'eshell/rm)))

    (add-hook 'eshell-first-time-mode-hook 'eshell-initialize)))

(use-package esh-toggle
  :requires eshell
  :bind ("C-x C-z" . eshell-toggle))

#+end_src 

** ess

#+begin_src emacs-lisp :tangle no

(use-package ess-site
  :disabled t
  :load-path "site-lisp/ess/lisp/"
  :commands R)

;;;_ , eval-expr

(use-package eval-expr
  :bind ("M-:" . eval-expr)
  :config
  (progn
    (setq eval-expr-print-function 'pp
          eval-expr-print-level 20
          eval-expr-print-length 100)

    (defun eval-expr-minibuffer-setup ()
      (set-syntax-table emacs-lisp-mode-syntax-table)
      (paredit-mode))))
#+end_src 

** flyspell

It seems like this is needed for about everything
#+begin_src emacs-lisp 

(setq flyspell-use-meta-tab nil)

#+end_src 

** Ispell

#+begin_src emacs-lisp 

(setq ispell-personal-dictionary "~/git/.emacs.d/.aspell.US.pws")

#+end_src 


#+begin_src emacs-lisp 


(use-package ispell
  :bind (("C-c i c" . ispell-comments-and-strings)
         ("C-c i d" . ispell-change-dictionary)
         ("C-c i k" . ispell-kill-ispell)
         ("C-c i m" . ispell-message)
         ("C-c i r" . ispell-region)))

(use-package flyspell
  :bind (("C-c i b" . flyspell-buffer)
         ("C-c i f" . flyspell-mode))
  :config
  (define-key flyspell-mode-map [(control ?.)] nil))

  #+end_src 

** fold-dwim

#+begin_src emacs-lisp 

(use-package fold-dwim
  :bind (("<H-f10>" . fold-dwim-toggle)
         ("<H-f11>" . fold-dwim-hide-all)
         ("<H-f12>" . fold-dwim-show-all)))

#+end_src 
         
** gist

#+begin_src emacs-lisp 

(use-package gist
  :bind ("C-c G" . gist-region-or-buffer))

#+end_src 
          
** grep

#+begin_src emacs-lisp 

(use-package grep
  :bind (("M-s d" . find-grep-dired)
         ("M-s f" . find-grep)
         ("M-s g" . grep))
  :init
  (progn
    (defun find-grep-in-project (command-args)
      (interactive
       (let ((default (thing-at-point 'symbol)))
         (list (read-shell-command "Run find (like this): "
                                   (cons (concat "git --no-pager grep -n "
                                                 default)
                                         (+ 24 (length default)))
                                   'grep-find-history))))
      (when command-args
        (let ((null-device nil))        ; see grep
          (grep command-args))))

    (bind-key "M-s p" 'find-grep-in-project))

  :config
  (progn
    (grep-apply-setting 'grep-command "egrep -nH -e ")
    (grep-apply-setting
     'grep-find-command
     '("find . -type f -print0 | xargs -P4 -0 egrep -nH -e " . 52))))

#+end_src      

** helm

#+begin_src emacs-lisp 

(use-package helm-config
;;  :if (not running-alternate-emacs)
  :init
  (progn
    (bind-key "C-c M-x" 'helm-M-x)
    (bind-key "C-h a" 'helm-c-apropos)
    (bind-key "M-s a" 'helm-do-grep)

    (defun my-helm-occur ()
      (interactive)
      (require 'helm-regexp)
      (helm-other-buffer 'helm-c-source-occur "*Helm Occur*"))

    (bind-key "M-s b" 'my-helm-occur)
    (bind-key "M-s F" 'helm-for-files)

    (defun my-helm-apropos ()
      (interactive)
      (require 'helm-elisp)
      (require 'helm-misc)
      (let ((default (thing-at-point 'symbol)))
        (helm
         :prompt "Info about: "
         :candidate-number-limit 15
         :sources
         (append (mapcar (lambda (func)
                           (funcall func default))
                         '(helm-c-source-emacs-commands
                           helm-c-source-emacs-functions
                           helm-c-source-emacs-variables
                           helm-c-source-emacs-faces
                           helm-c-source-helm-attributes))
                 '(helm-c-source-info-emacs
                   helm-c-source-info-elisp
                   helm-c-source-info-gnus
                   helm-c-source-info-org
                   helm-c-source-info-cl
                   helm-c-source-emacs-source-defun)))))

    (bind-key "C-h e a" 'my-helm-apropos)

    (defun helm-c-source-git-files-init ()
      "Build `helm-candidate-buffer' of Git files."
      (with-current-buffer (helm-candidate-buffer 'local)
        (mapcar
         (lambda (item)
           (insert (expand-file-name item) ?\n))
         (split-string (shell-command-to-string "git ls-files") "\n"))))

    (defun helm-find-git-file ()
      (interactive)
      (helm :sources 'helm-c-source-git-files
            :input ""
            :prompt "Find file: "
            :buffer "*Helm git file*"))

    (bind-key "C-x f" 'helm-find-git-file)
    (bind-key "M-g g" 'helm-find-git-file)
    (bind-key "C-h b" 'helm-descbinds))

  :config
  (progn
    (helm-match-plugin-mode t)

    (use-package helm-descbinds
      :commands helm-descbinds
      :init
      (fset 'describe-bindings 'helm-descbinds))

    (defvar helm-c-source-git-files
      '((name . "Files under Git version control")
        (init . helm-c-source-git-files-init)
        (candidates-in-buffer)
        (type . file))
      "Search for files in the current Git project.")

    (eval-after-load "helm-files"
      '(add-to-list 'helm-for-files-prefered-list
                    'helm-c-source-git-files))))

#+end_src 

** hi-lock

#+begin_src emacs-lisp 

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))

#+end_src 

** hilit-chg

#+begin_src emacs-lisp 

(use-package hilit-chg
  :bind ("M-o C" . highlight-changes-mode))

#+end_src

** hl-line

#+begin_src emacs-lisp 

(use-package hl-line
  :bind ("M-o h" . hl-line-mode)
  :config
  (use-package hl-line+))

#+end_src 

** ibuffer

#+begin_src emacs-lisp :tangle no

(use-package ibuffer
  :bind ("C-x C-b" . ibuffer))

#+end_src 

** Identi.ca mode

#+begin_src emacs-lisp 

(require 'identica-mode)

(global-set-key "\C-cip" 'identica-update-status-interactive)
;; Add this to send direct messages
(global-set-key "\C-cid" 'identica-direct-message-interactive)

#+end_src 

** ido

#+begin_src emacs-lisp 

(use-package ido
  :defines (ido-cur-item
            ido-require-match
            ido-selected
            ido-final-text
            ido-show-confirm-message)
  :init
  (ido-mode 'buffer)

  :config
  (progn
    (use-package ido-hacks
      :init
      (ido-hacks-mode 1))

    (defun ido-smart-select-text ()
      "Select the current completed item.  Do NOT descend into directories."
      (interactive)
      (when (and (or (not ido-require-match)
                     (if (memq ido-require-match
                               '(confirm confirm-after-completion))
                         (if (or (eq ido-cur-item 'dir)
                                 (eq last-command this-command))
                             t
                           (setq ido-show-confirm-message t)
                           nil))
                     (ido-existing-item-p))
                 (not ido-incomplete-regexp))
        (when ido-current-directory
          (setq ido-exit 'takeprompt)
          (unless (and ido-text (= 0 (length ido-text)))
            (let ((match (ido-name (car ido-matches))))
              (throw 'ido
                     (setq ido-selected
                           (if match
                               (replace-regexp-in-string "/\\'" "" match)
                             ido-text)
                           ido-text ido-selected
                           ido-final-text ido-text)))))
        (exit-minibuffer)))

    (add-hook 'ido-minibuffer-setup-hook
              #'(lambda ()
                  (bind-key "<return>" 'ido-smart-select-text
                            ido-file-completion-map)))

    (defun ido-switch-buffer-tiny-frame (buffer)
      (interactive (list (ido-read-buffer "Buffer: " nil t)))
      (with-selected-frame
          (make-frame '((width                . 80)
                        (height               . 22)
                        (left-fringe          . 0)
                        (right-fringe         . 0)
                        (vertical-scroll-bars . nil)
                        (unsplittable         . t)
                        (has-modeline-p       . nil)
                        ;;(background-color     . "grey80")
                        (minibuffer           . nil)))
        (switch-to-buffer buffer)
        (set (make-local-variable 'mode-line-format) nil)))

    (bind-key "C-x 5 t" 'ido-switch-buffer-tiny-frame)))

#+end_src 

** image-file

#+begin_src emacs-lisp 

(use-package image-file
  :disabled t
  :init
  (auto-image-file-mode 1))

#+end_src 

** Info

#+begin_src emacs-lisp 

(use-package info
  :bind ("C-h C-i" . info-lookup-symbol)
  :init
  (remove-hook 'menu-bar-update-hook 'mac-setup-help-topics)

  :config
  (progn
    (defadvice info-setup (after load-info+ activate)
      (use-package info+))

    (defadvice Info-exit (after remove-info-window activate)
      "When info mode is quit, remove the window."
      (if (> (length (window-list)) 1)
          (delete-window)))))

(use-package info-look
  :commadns info-lookup-add-help)

#+end_src 

** indirect

#+begin_src emacs-lisp 

(use-package indirect
  :bind ("C-c C" . indirect-region))

#+end_src 

** initsplit

#+begin_src emacs-lisp 

(eval-after-load "cus-edit"
  '(use-package initsplit))

#+end_src 

** ipa

#+begin_src emacs-lisp 

(use-package ipa
  :commands ipa-insert
  :init
  (progn
    (autoload 'ipa-load-annotations-into-buffer "ipa")
    (add-hook 'find-file-hook 'ipa-load-annotations-into-buffer)))

#+end_src 

** js2-mode

#+begin_src emacs-lisp 

(use-package js2-mode
  :mode ("\\.js\\'" . js2-mode))

#+end_src 

** ledger

#+begin_src emacs-lisp 

(use-package "ldg-new"
  :commands ledger-mode
  :init
  (progn
    (defun my-ledger-start-entry (&optional arg)
      (interactive "p")
      (find-file-other-window "~/Documents/Accounts/ledger.dat")
      (goto-char (point-max))
      (skip-syntax-backward " ")
      (if (looking-at "\n\n")
          (goto-char (point-max))
        (delete-region (point) (point-max))
        (insert ?\n)
        (insert ?\n))
      (insert (format-time-string "%Y/%m/%d ")))

    (bind-key "C-c L" 'my-ledger-start-entry)

    (defun ledger-matchup ()
      (interactive)
      (while (re-search-forward "\\(\\S-+Unknown\\)\\s-+\\$\\([-,0-9.]+\\)"
                                nil t)
        (let ((account-beg (match-beginning 1))
              (account-end (match-end 1))
              (amount (match-string 2))
              account answer)
          (goto-char account-beg)
          (set-window-point (get-buffer-window) (point))
          (recenter)
          (redraw-display)
          (with-current-buffer (get-buffer "nrl-mastercard-old.dat")
            (goto-char (point-min))
            (when (re-search-forward (concat "\\(\\S-+\\)\\s-+\\$" amount)
                                     nil t)
              (setq account (match-string 1))
              (goto-char (match-beginning 1))
              (set-window-point (get-buffer-window) (point))
              (recenter)
              (redraw-display)
              (setq answer
                    (read-char (format "Is this a match for %s (y/n)? "
                                       account)))))
          (when (eq answer ?y)
            (goto-char account-beg)
            (delete-region account-beg account-end)
            (insert account))
          (forward-line))))))

#+end_src 

** lisp-mode

#+begin_src emacs-lisp 

;; Utilities every Emacs Lisp coders should master:
;;
;;   paredit          Let's you manipulate sexps with ease
;;   redshank         Think: Lisp refactoring
;;   edebug           Knowing the traditional debugger is good too
;;   eldoc
;;   cldoc
;;   elint
;;   elp
;;   ert

(use-package lisp-mode
  ;; :load-path "site-lisp/slime/contrib/"
  :init
  (progn
    (defface esk-paren-face
      '((((class color) (background dark))
         (:foreground "grey50"))
        (((class color) (background light))
         (:foreground "grey55")))
      "Face used to dim parentheses."
      :group 'starter-kit-faces)

    ;; Change lambda to an actual lambda symbol
    (mapc (lambda (major-mode)
            (font-lock-add-keywords
             major-mode
             `(("(\\(lambda\\)\\>"
                (0 (ignore
                    (compose-region (match-beginning 1)
                                    (match-end 1) ?λ))))
               ("(\\|)" . 'esk-paren-face))))
          '(emacs-lisp-mode
            inferior-emacs-lisp-mode
            lisp-mode
            inferior-lisp-mode
            slime-repl-mode))

    (defvar slime-mode nil)
    (defvar lisp-mode-initialized nil)

    (defun initialize-lisp-mode ()
      (unless lisp-mode-initialized
        (setq lisp-mode-initialized t)

        (use-package redshank
          :diminish redshank-mode)

        (use-package edebug)

        (use-package eldoc
          :diminish eldoc-mode
          :defer t
          :init
          (use-package eldoc-extension
            :disabled t
            :defer t
            :init
            (progn
              (add-hook 'emacs-lisp-mode-hook
                        #'(lambda () (require 'eldoc-extension)) t)

              (eldoc-add-command 'paredit-backward-delete
                                 'paredit-close-round))))

        (use-package cldoc
          :diminish cldoc-mode)

        (use-package ert
          :commands ert-run-tests-interactively
          :bind ("C-c e t" . ert-run-tests-interactively))

        (use-package elint
          :commands 'elint-initialize
          :init
          (defun elint-current-buffer ()
            (interactive)
            (elint-initialize)
            (elint-current-buffer))

          :config
          (progn
            (add-to-list 'elint-standard-variables 'current-prefix-arg)
            (add-to-list 'elint-standard-variables 'command-line-args-left)
            (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
            (add-to-list 'elint-standard-variables 'emacs-major-version)
            (add-to-list 'elint-standard-variables 'window-system)))

        (use-package highlight-cl
          :init
          (progn
            (add-hook 'emacs-lisp-mode-hook
                      'highlight-cl-add-font-lock-keywords)
            (add-hook 'lisp-interaction-mode-hook
                      'highlight-cl-add-font-lock-keywords)))

        (defun my-elisp-indent-or-complete (&optional arg)
          (interactive "p")
          (call-interactively 'lisp-indent-line)
          (unless (or (looking-back "^\\s-*")
                      (bolp)
                      (not (looking-back "[-A-Za-z0-9_*+/=<>!?]+")))
            (call-interactively 'lisp-complete-symbol)))

        (defun my-lisp-indent-or-complete (&optional arg)
          (interactive "p")
          (if (or (looking-back "^\\s-*") (bolp))
              (call-interactively 'lisp-indent-line)
            (call-interactively 'slime-indent-and-complete-symbol)))

        (defun my-byte-recompile-file ()
          (save-excursion
            (byte-recompile-file buffer-file-name)))

        ;; Register Info manuals related to Lisp
        (use-package info-lookmore
          :init
          (progn
            (info-lookmore-elisp-cl)
            (info-lookmore-elisp-userlast)
            (info-lookmore-elisp-gnus)
            (info-lookmore-apropos-elisp)))

        (mapc (lambda (mode)
                (info-lookup-add-help
                 :mode mode
                 :regexp "[^][()'\" \t\n]+"
                 :ignore-case t
                 :doc-spec '(("(ansicl)Symbol Index" nil nil nil))))
              '(lisp-mode slime-mode slime-repl-mode
                          inferior-slime-mode))))

    (defun my-lisp-mode-hook ()
      (initialize-lisp-mode)

      (auto-fill-mode 1)
      (paredit-mode 1)
      (redshank-mode 1)

      (bind-key ")" 'paredit-close-round-and-newline paredit-mode-map)
      (bind-key "M-)" 'paredit-close-round paredit-mode-map)

      (bind-key "M-k" 'paredit-raise-sexp paredit-mode-map)
      (bind-key "M-h" 'mark-containing-sexp paredit-mode-map)
      (bind-key "M-I" 'paredit-splice-sexp paredit-mode-map)

      (unbind-key "M-r" paredit-mode-map)
      (unbind-key "M-s" paredit-mode-map)

      (bind-key "C-. d" 'paredit-forward-down paredit-mode-map)
      (bind-key "C-. B" 'paredit-splice-sexp-killing-backward paredit-mode-map)
      (bind-key "C-. F" 'paredit-splice-sexp-killing-forward paredit-mode-map)

      (if (eq major-mode 'emacs-lisp-mode)
          (progn
            (bind-key "<M-return>" 'outline-insert-heading emacs-lisp-mode-map)
            (bind-key "<tab>" 'my-elisp-indent-or-complete emacs-lisp-mode-map))
        (turn-on-cldoc-mode)

        (bind-key "<tab>" 'my-lisp-indent-or-complete lisp-mode-map)
        (bind-key "M-q" 'slime-reindent-defun lisp-mode-map)
        (bind-key "M-l" 'slime-selector lisp-mode-map)))

    (hook-into-modes #'my-lisp-mode-hook
                     '(lisp-mode-hook
                       inferior-lisp-mode-hook
                       slime-repl-mode-hook))

    (hook-into-modes #'my-lisp-mode-hook
                     '(emacs-lisp-mode-hook))))

#+end_src 

** llvm-mode

#+begin_src emacs-lisp :tangle no

(use-package llvm-mode
  :mode ("\\.ll\\'" . llvm-mode))

#+end_src 

** log4j-mode

#+begin_src emacs-lisp 

(use-package log4j-mode
  :disabled t
  :mode ("\\.log\\'" . log4j-mode))

#+end_src 

** Lorem Ipsum

Somtimes I just need some filler text. And it’s silly typing it out
myself when I’m using a thermonuclear text editor.

Via EmacsWiki, I discover lorem-ipsum.el. I toss it into my elisp
folder and set up some autoloads so that it will be loaded when
needed.

#+begin_src emacs-lisp 

(autoload 'Lorem-ipsum-insert-paragraphs "lorem-ipsum" "" t)
(autoload 'Lorem-ipsum-insert-sentences "lorem-ipsum" "" t)
(autoload 'Lorem-ipsum-insert-list "lorem-ipsum" "" t)

#+end_src 

** Magit

#+begin_src emacs-lisp :tangle no

(use-package magit
  :bind ("C-x g" . magit-status)
  :config
  (progn
    (setenv "GIT_PAGER" "")

    (add-hook 'magit-log-edit-mode-hook
              #'(lambda ()
                  (set-fill-column 72)
                  (flyspell-mode)))

    (require 'magit-topgit)
    (require 'rebase-mode)

    (defun start-git-monitor ()
      (interactive)
      (start-process "git-monitor" (current-buffer) "~/bin/git-monitor"))

    ;;(add-hook 'magit-status-mode-hook 'start-git-monitor)
    ))

#+end_src     
    
** markdown-mode
#+begin_src emacs-lisp 

(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :init
  (progn
    (defun markdown-preview-file ()
      "run Marked on the current file and revert the buffer"
      (interactive)
      (shell-command
       (format "open -a /Applications/Marked.app %s"
               (shell-quote-argument (buffer-file-name)))))

    (bind-key "C-x M" 'markdown-preview-file)))

#+end_src 
    
** Use pastebin.com

#+begin_src emacs-lisp 

(require 'pastebin)

#+end_src 

** paredit

#+begin_src emacs-lisp 

(use-package paredit
  :commands paredit-mode
  :diminish paredit-mode
  :init
  (progn
    (defun mark-containing-sexp ()
      (interactive)
      (paredit-backward-up)
      (mark-sexp))

    (defun paredit-barf-all-the-way-backward ()
      (interactive)
      (paredit-split-sexp)
      (paredit-backward-down)
      (paredit-splice-sexp))

    (defun paredit-barf-all-the-way-forward ()
      (interactive)
      (paredit-split-sexp)
      (paredit-forward-down)
      (paredit-splice-sexp)
      (if (eolp) (delete-horizontal-space)))

    (defun paredit-slurp-all-the-way-backward ()
      (interactive)
      (catch 'done
        (while (not (bobp))
          (save-excursion
            (paredit-backward-up)
            (if (eq (char-before) ?\()
                (throw 'done t)))
          (paredit-backward-slurp-sexp))))

    (defun paredit-slurp-all-the-way-forward ()
      (interactive)
      (catch 'done
        (while (not (eobp))
          (save-excursion
            (paredit-forward-up)
            (if (eq (char-after) ?\))
                (throw 'done t)))
          (paredit-forward-slurp-sexp)))))

  :config
  (progn
    (nconc paredit-commands
           '("Extreme Barfage & Slurpage"
             (("C-M-)")
              paredit-slurp-all-the-way-forward
              ("(foo (bar |baz) quux zot)"
               "(foo (bar |baz quux zot))")
              ("(a b ((c| d)) e f)"
               "(a b ((c| d)) e f)"))
             (("C-M-}")
              paredit-barf-all-the-way-forward
              ("(foo (bar |baz quux) zot)"
               "(foo (bar|) baz quux zot)"))
             (("C-M-(")
              paredit-slurp-all-the-way-backward
              ("(foo bar (baz| quux) zot)"
               "((foo bar baz| quux) zot)")
              ("(a b ((c| d)) e f)"
               "(a b ((c| d)) e f)"))
             (("C-M-{")
              paredit-barf-all-the-way-backward
              ("(foo (bar baz |quux) zot)"
               "(foo bar baz (|quux) zot)"))))

    (paredit-define-keys)
    (paredit-annotate-mode-with-examples)
    (paredit-annotate-functions-with-examples)

    (add-hook 'allout-mode-hook
              #'(lambda ()
                  (bind-key "M-k" 'paredit-raise-sexp allout-mode-map)
                  (bind-key "M-h" 'mark-containing-sexp allout-mode-map)))))

#+end_src                   

** paren

#+begin_src emacs-lisp 

(use-package paren
  :init
  (show-paren-mode 1))

#+end_src 

** per-window-point

#+begin_src emacs-lisp 

(use-package per-window-point
  :init
  (pwp-mode 1))

#+end_src 

** persistent-scratch

#+begin_src emacs-lisp :tangle no

(use-package persistent-scratch
  :if (and window-system (not running-alternate-emacs)
           (not noninteractive)))

#+end_src 
           
** popup-ruler

#+begin_src emacs-lisp 

(use-package popup-ruler
  :bind (("C-. r" . popup-ruler)
         ("C-. R" . popup-ruler-vertical)))

#+end_src 
         
** pp-c-l

#+begin_src emacs-lisp :tangle no

(use-package pp-c-l
  :init
  (hook-into-modes 'pretty-control-l-mode '(prog-mode-hook)))

#+end_src 
  
** ps-print

#+begin_src emacs-lisp 

(use-package ps-print
  :defer t
  :config
  (progn
    (defun ps-spool-to-pdf (beg end &rest ignore)
      (interactive "r")
      (let ((temp-file (concat (make-temp-name "ps2pdf") ".pdf")))
        (call-process-region beg end (executable-find "ps2pdf")
                             nil nil nil "-" temp-file)
        (call-process (executable-find "open") nil nil nil temp-file)))

    (setq ps-print-region-function 'ps-spool-to-pdf)))

#+end_src

** puppet-mode

#+begin_src emacs-lisp 

(use-package puppet-mode
  :mode ("\\.pp\\'" . puppet-mode))

#+end_src 
** recentf

#+begin_src emacs-lisp 

(use-package recentf
  :if (not noninteractive)
  :init
  (progn
    (recentf-mode 1)

    (defun recentf-add-dired-directory ()
      (if (file-directory-p dired-directory)
          (recentf-add-file (file-name-nondirectory dired-directory))))

    (add-hook 'dired-mode-hook 'recentf-add-dired-directory)))
#+end_src 

;;;_ , selectkey

(use-package selectkey
  :bind ("C-. s" . selectkey-select-prefix-map))

** Sauron
*** Settings

#+begin_src emacs-lisp 

(setq sauron-max-line-length 120)

 ;; note, you add (setq sauron-debug t) to get errors which can debug if
 ;; there's something wrong; normally, we catch such errors, since e.g an error
 ;; in one of the hooks may cause ERC to fail (i.e., the message won't come
 ;; trough).

  ;; uncomment to show sauron in the current frame
  ;; sauron-separate-frame nil

  (setq sauron-hide-mode-line t)

#+end_src 

*** Init

#+begin_src emacs-lisp 


(use-package sauron
:bind (("C-. s" . sauron-toggle-hide-show)
       ("C-. R" . sauron-clear)))

#+end_src 


*** some sound/light effects for certain events

#+begin_src emacs-lisp :tangle no

(add-hook 'sauron-event-added-functions
  (lambda (origin prio msg &optional props)
    (if (string-match "ping" msg)
      (sauron-fx-sox "/usr/share/sounds/ping.wav"))
    (cond
      ((= prio 3) (sauron-fx-sox "/usr/share/sounds/pling.wav"))
      ((= prio 4) (sauron-fx-sox "/usr/share/sounds/plong.wav"))
      ((= prio 5)
	(sauron-fx-sox "/usr/share/sounds/alarm.wav")
	(sauron-fx-gnome-osd(format "%S: %s" origin msg) 5)))))

#+end_src 

*** events to ignore

#+begin_src emacs-lisp 


(add-hook 'sauron-event-block-functions
  (lambda (origin prio msg &optional props)
    (or
      (string-match "^*** Users" msg)))) ;; filter out IRC spam

#+end_src 


      
** Session save config

#+begin_src emacs-lisp 

(setq session-save-file "~/.emacs.d/.session")

#+end_src 


#+begin_src emacs-lisp 

(use-package session
  :if (not noninteractive)
  :load-path "site-lisp/session/lisp/"
  :init
  (progn
    (session-initialize)

    (defun remove-session-use-package-from-settings ()
      (when (string= (buffer-file-name)
                     (expand-file-name "settings.el"
                                       user-emacs-directory))
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^ '(session-use-package " nil t)
            (delete-region (line-beginning-position)
                           (1+ (line-end-position)))))))

    (add-hook 'before-save-hook 'remove-session-use-package-from-settings)

    ;; expanded folded secitons as required
    (defun le::maybe-reveal ()
      (when (and (or (memq major-mode  '(org-mode outline-mode))
                     (and (boundp 'outline-minor-mode)
                          outline-minor-mode))
                 (outline-invisible-p))
        (if (eq major-mode 'org-mode)
            (org-reveal)
          (show-subtree))))

    (add-hook 'session-after-jump-to-last-change-hook
              'le::maybe-reveal)

    (defun save-information ()
      (message "Saving Emacs information...")
      (dolist (func kill-emacs-hook)
        (unless (memq func '(exit-gnus-on-exit server-force-stop))
          (funcall func)))
      (unless (or running-alternate-emacs
                  (eq 'listen (process-status server-process)))
        (server-start))
      (clean-buffer-list))

    (run-with-idle-timer 300 t 'save-information)

    (if window-system
        (add-hook 'after-init-hook 'session-initialize t))))

#+end_src 
        
** sh-script

#+begin_src emacs-lisp :tangle no

(use-package sh-script
  :defer t
  :config
  (progn
    (defvar sh-script-initialized nil)
    (defun initialize-sh-script ()
      (unless sh-script-initialized
        (setq sh-script-initialized t)
        (info-lookup-add-help :mode 'shell-script-mode
                              :regexp ".*"
                              :doc-spec
                              '(("(bash)Index")))))

    (add-hook 'shell-mode-hook 'initialize-sh-script)))

#+end_src

** sh-toggle

#+begin_src emacs-lisp :tangle no

(use-package sh-toggle
  :bind ("C-x M-z" . shell-toggle))

#+end_src 

** smart-compile

#+begin_src emacs-lisp :tangle no

(use-package smart-compile
  :commands smart-compile
  :bind (("C-c c" . smart-compile)
         ("A-n"   . next-error)
         ("A-p"   . previous-error))
  :init
  (progn
    (defun show-compilation ()
      (interactive)
      (let ((compile-buf
             (catch 'found
               (dolist (buf (buffer-list))
                 (if (string-match "\\*compilation\\*" (buffer-name buf))
                     (throw 'found buf))))))
        (if compile-buf
            (switch-to-buffer-other-window compile-buf)
          (call-interactively 'compile))))

    (bind-key "M-O" 'show-compilation)))

#+end_src 
    
** springboard

#+begin_src emacs-lisp :tangle no

(use-package springboard
  :bind ("C-. c" . springboard))

#+end_src 

** stopwatch

#+begin_src emacs-lisp :tangle no

(use-package stopwatch
  :bind ("<f8>" . stopwatch))

#+end_src 

** texinfo

#+begin_src emacs-lisp 

(use-package texinfo
  :defines texinfo-section-list
  :mode ("\\.texi\\'" . texinfo-mode)
  :config
  (progn
    (defun my-texinfo-mode-hook ()
      (dolist (mapping '((?b . "emph")
                         (?c . "code")
                         (?s . "samp")
                         (?d . "dfn")
                         (?o . "option")
                         (?x . "pxref")))
        (local-set-key (vector (list 'alt (car mapping)))
                       `(lambda () (interactive)
                          (TeX-insert-macro ,(cdr mapping))))))

    (add-hook 'texinfo-mode-hook 'my-texinfo-mode-hook)

    (defun texinfo-outline-level ()
      ;; Calculate level of current texinfo outline heading.
      (require 'texinfo)
      (save-excursion
        (if (bobp)
            0
          (forward-char 1)
          (let* ((word (buffer-substring-no-properties
                        (point) (progn (forward-word 1) (point))))
                 (entry (assoc word texinfo-section-list)))
            (if entry
                (nth 1 entry)
              5)))))))

#+end_src               

** W3m

#+begin_src emacs-lisp 

(use-package w3m
  :commands w3m-browse-url
  :init
  (progn
;;    (setq w3m-command "/opt/local/bin/w3m")

    (autoload 'w3m-session-crash-recovery-remove "w3m-session")

    (defun wikipedia-query (term)
      (interactive (list (read-string "Wikipedia search: " (word-at-point))))
      (require 'w3m-search)
      (w3m-search "en.wikipedia" term))

    (eval-when-compile
      (autoload 'w3m-search-escape-query-string "w3m-search"))

    (defun wolfram-alpha-query (term)
      (interactive (list (read-string "Ask Wolfram Alpha: " (word-at-point))))
      (require 'w3m-search)
      (w3m-browse-url (format "http://m.wolframalpha.com/input/?i=%s"
                              (w3m-search-escape-query-string term))))

    (defun goto-emacswiki ()
      (interactive)
      (w3m-browse-url "http://www.emacswiki.org"))

    (bind-key "H-M-e" 'goto-emacswiki)
    (bind-key "H-M-g" 'w3m-search)
    (bind-key "H-M-h" 'wolfram-alpha-query)
    (bind-key "H-M-w" 'wikipedia-query))

  :config
  (let (proxy-host proxy-port)
    (with-temp-buffer
      (shell-command "scutil --proxy" (current-buffer))

      (when (re-search-forward "HTTPPort : \\([0-9]+\\)" nil t)
        (setq proxy-port (match-string 1)))
      (when (re-search-forward "HTTPProxy : \\(\\S-+\\)" nil t)
        (setq proxy-host (match-string 1))))

    (if (and proxy-host proxy-port)
        (setq w3m-command-arguments
              (nconc w3m-command-arguments
                     (list "-o" (format "http_proxy=http://%s:%s/"
                                        proxy-host proxy-port)))))

    (use-package w3m-type-ahead
      :requires w3m
      :init
      (add-hook 'w3m-mode-hook 'w3m-type-ahead-mode))

    (bind-key "<return>" 'w3m-view-url-with-external-browser
              w3m-minor-mode-map)))

#+end_src 

*** For Gnus
#+begin_src emacs-lisp 

;;(define-key gnus-article-mode-map (kbd "M-w") 'org-w3m-copy-for-org-mode)
(define-key gnus-article-mode-map (kbd "C-c C-x M-w") 'org-w3m-copy-for-org-mode)

#+end_src 



#+begin_src emacs-lisp 

(setq apropos-url-alist
      '(("^gw?:? +\\(.*\\)" . ;; Google Web 
         "http://www.google.com/search?q=\\1")

        ("^g!:? +\\(.*\\)" . ;; Google Lucky
         "http://www.google.com/search?btnI=I%27m+Feeling+Lucky&q=\\1")
        
        ("^gl:? +\\(.*\\)" .  ;; Google Linux 
         "http://www.google.com/linux?q=\\1")
        
        ("^gi:? +\\(.*\\)" . ;; Google Images
         "http://images.google.com/images?sa=N&tab=wi&q=\\1")

        ("^gg:? +\\(.*\\)" . ;; Google Groups
         "http://groups.google.com/groups?q=\\1")

        ("^gd:? +\\(.*\\)" . ;; Google Directory
         "http://www.google.com/search?&sa=N&cat=gwd/Top&tab=gd&q=\\1")

        ("^gn:? +\\(.*\\)" . ;; Google News
         "http://news.google.com/news?sa=N&tab=dn&q=\\1")

        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(\\w+://.*\\)" . ;; Google Translate URL
         "http://translate.google.com/translate?langpair=\\1|\\2&u=\\3")
        
        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . ;; Google Translate Text
         "http://translate.google.com/translate_t?langpair=\\1|\\2&text=\\3")

        ("^/\\.$" . ;; Slashdot 
         "http://www.slashdot.org")

        ("^/\\.:? +\\(.*\\)" . ;; Slashdot search
         "http://www.osdn.com/osdnsearch.pl?site=Slashdot&query=\\1")        
        
        ("^fm$" . ;; Freshmeat
         "http://www.freshmeat.net")

        ("^ewiki:? +\\(.*\\)" . ;; Emacs Wiki Search
         "http://www.emacswiki.org/cgi-bin/wiki?search=\\1")
 
        ("^ewiki$" . ;; Emacs Wiki 
         "http://www.emacswiki.org")

        ("^arda$" . ;; The Encyclopedia of Arda 
         "http://www.glyphweb.com/arda/")
         
         ))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))

(add-to-list 'apropos-url-alist '("^dpi:? +\\(.*\\)" . "http://api.drupal.org/api/search/7/\\1")) ;; Drupal API default to 7, api number if specified

(defun browse-apropos-url (text &optional new-window)
  (interactive (browse-url-interactive-arg "Location: "))
  (let ((text (replace-regexp-in-string 
               "^ *\\| *$" "" 
               (replace-regexp-in-string "[ \t\n]+" " " text))))
    (let ((url (assoc-default 
                text apropos-url-alist 
                '(lambda (a b) (let () (setq __braplast a) (string-match a b)))
                text)))
      (browse-url (replace-regexp-in-string __braplast url text) new-window))))

(defun browse-apropos-url-on-region (min max text &optional new-window)
  (interactive "r \nsAppend region to location: \nP")
  (browse-apropos-url (concat text " " (buffer-substring min max)) new-window))

;;(require 'browse-apropos-url)
;; (provide 'browse-url)



(defun rgr/browse-url (arg &optional url)
  "Browse the URL passed. Use a prefix arg for external default browser else use default browser which is probably W3m"
  (interactive "P")
  (setq url (or url (w3m-url-valid (w3m-anchor))
  (browse-url-url-at-point) 
(thing-at-point 'word)
))
  (if arg
      (when url (browse-url-default-browser url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))


(defun rgr/google(term)
  "Call google search for the specified term. Do not call if string is zero length."
  (let ((url (if (zerop (length term)) "http://www.google.com " (concat "gw: " term))))
    (browse-apropos-url url)))

(defun rgr/google-search-prompt()
  (interactive)
  (rgr/google (read-string "Google the web for the following phrase :
  "
(thing-at-point 'word)
)))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))


(defun rgr/call-google-translate (langpair prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word) )
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat (if (string-match " " thing) (quote "gt")(quote "googledict")) " " langpair " " thing))))

(defun rgr/browse-apropos-url (prefix prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word))
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat prefix " " thing))))

;; Search Google at point:
(defun my-search-google (w)
  "Launch google on the Word at Point"
  (interactive
   (list (let* ((word (thing-at-point 'symbol))
                (input (read-string (format "Google%s: " 
                                (if (not word) "" (format " (default %s)" word))))))
           (if (string= input "") (if (not word) 
                       (error "No keyword to search given") word) input) ;sinon input
           )))
  (browse-url (format "http:/www.google.com/search?q=%s" w))
  )

;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.


(defun pm/region-or-word (prompt)
  "Read a string from the minibuffer, prompting with PROMPT.
If `transient-mark-mode' is non-nil and the mark is active,
it defaults to the current region, else to the word at or before
point. This function returns a list (string) for use in `interactive'."
  (list (read-string prompt (or (and transient-mark-mode mark-active
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end)))
                            (current-word))))) 
(defun pm/google (string)
  "Ask a WWW browser to google string.
Prompts for a string, defaulting to the active region or the current word at
or before point."
  (interactive (pm/region-or-word "Google: "))
  (browse-url (concat "http://google.com/search?num=100&q=" string)))


(setq w3m-use-cookies t)

(setq w3m-coding-system 'utf-8
      w3m-file-coding-system 'utf-8
      w3m-file-name-coding-system 'utf-8
      w3m-input-coding-system 'utf-8
      w3m-output-coding-system 'utf-8
      w3m-terminal-coding-system 'utf-8)

(require 'org-w3m)

(setq browse-url-new-window-flag t)

(setq browse-url-browser-function 'w3m-browse-url-other-workgroup)

(defun w3m-browse-url-other-workgroup (url &optional newwin)
  (let ((w3m-pop-up-windows t))
   (wg-switch-to-index-5)
    (w3m-browse-url url newwin)))

(setq browse-url-generic-program "conkeror")

(defun rgr/browse (url)
  "If prefix is specified use the system default browser else use the configured emacs one"
  (if current-prefix-arg
;;      (when url (browse-url-default-browser url))
      (when url (browse-url-generic url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))

(defun rgr/browse-url (&optional url)
  "browse the url passed in"
  (interactive)
  (setq url (or url (w3m-url-valid (w3m-anchor)) (browse-url-url-at-point) (region-or-word-at-point)))
  (setq url (read-string (format "Url \"%s\" :" url) url nil url))
  (rgr/browse url))

(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key (kbd "<f4>") 'rgr/browse-url)

(require 'webjump)

(global-set-key [H-f2] 'webjump)
(setq webjump-sites
(append '(
("Java API" .
[simple-query "www.google.com" "http://www.google.com/search?hl=en&as_sitesearch=http://java.sun.com/javase/6/docs/api/&q=" ""])
("Stack Overflow" . "www.stackoverlow.com")
("Pop's Site"   . "www.joebob-and-son.com/")

)
      webjump-sample-sites))

(setq
           w3m-session-file "~/.emacs.d/.w3m-session"
)

 (defun w3m-add-keys ()
   (define-key w3m-mode-map "S" 'w3m-session-save)
   (define-key w3m-mode-map "L" 'w3m-session-load))
 (add-hook 'w3m-mode-hook 'w3m-add-keys)

(defun my-w3m-rename-buffer (url)
  "Renames the current buffer to be the current URL"
  (rename-buffer url t))
(add-hook 'w3m-display-hook 'my-w3m-rename-buffer)

(setq w3m-default-directory "~/.emacs.d/.w3m")

(message "0 dkh-w3m... Done")

(defun sacha/toggle-w3m ()
  (interactive)
  (let ((list (buffer-list))
        found
        (from-w3m (equal major-mode 'w3m-mode)))
    (while list
      (when (with-current-buffer (car list)
              (if from-w3m
                  (not (equal major-mode 'w3m-mode))
                (equal major-mode 'w3m-mode)))
        (setq found (car list))
        (pop-to-buffer (car list))
        (setq list nil))
      (setq list (cdr list)))
    (unless (or from-w3m found)
      (call-interactively 'w3m))))

;; http://www.mit.edu/afs/sipb/contrib/emacs/packages/w3m_el-1.2.8/w3m-filter.el
(defun sacha/w3m-filter-google (url &rest ignore)
  "Add <LINK> tag to search results of www.google.com."
  (goto-char (point-max))
  (let ((next (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_next.gif"
                     nil t)
                (match-string 1)))
        (prev (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_previous.gif"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

(defun sacha/w3m-filter-clientcopia (url &rest ignore)
  "Add <LINK> tag to search results of www.clientcopia.com."
  (goto-char (point-max))
  (let* ((next (when (re-search-backward
                     "\\(quotes.php.id=[0-9]+\\).*NEXT"
                     nil t)
                (match-string 1)))
         (prev (when (re-search-backward
                     "<a href=\\(quotes.php.id=[0-9]+\\).*BACK"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

;; Guessed
(defun w3m-filter-find-relationships (url next previous)
  "Add <LINK> tags if they don't yet exist."
  (let ((case-fold-search t))
    (goto-char (point-max))
    (when (re-search-backward next nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-next-url (match-string 1))))
    (when (re-search-backward previous nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-previous-url (match-string 1))))))

(defun w3m-download-with-wget ()
  (interactive)
  (let ((url (or (w3m-anchor) (w3m-image))))
    (if url
        (let ((proc (start-process "wget" (format "*wget %s*" url)
                                   "wget" "-x" "--passive-ftp" "-nv"
                                   "-P" "/home/sacha/notebook/mirrors" url)))
          (with-current-buffer (process-buffer proc)
            (erase-buffer))
          (set-process-sentinel proc (lambda (proc str)
                                       (message "wget download done"))))
      (message "Nothing to get"))))

(defun sacha/w3m-setup-keymap ()
  "Use my heavily customized map."
  (interactive)
  ;; Undefine this key and use the advice instead so that my ido doesn't get
  ;; overridden
  (define-key w3m-mode-map (kbd "C-x b") nil)
  (define-key w3m-mode-map "C" 'w3m-print-this-url)
  (define-key w3m-mode-map "a" 'sacha/delicious-url)
  (define-key w3m-mode-map "A" 'w3m-bookmark-add-current-url)
  (define-key w3m-mode-map "w" 'w3m-download-with-wget)
  (define-key w3m-mode-map "d" 'w3m-download-with-wget)
  (define-key w3m-mode-map "D" 'w3m-download-this-url)
  ;; Do not override my ever so handy ERC binding
  (define-key w3m-mode-map (kbd "C-c C-SPC") nil)
  (define-key w3m-mode-map "m" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "M" 'sacha/w3m-mirror-link)
  ;; I use search much more often than the context history list, although
  ;; context is still cool. 
  (define-key w3m-mode-map "!" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "s" 'w3m-search)
  (define-key w3m-mode-map "h" 'w3m-history)
  (define-key w3m-mode-map "t" 'w3m-scroll-down-or-previous-url)
  (define-key w3m-mode-map "n" 'w3m-scroll-up-or-next-url)
  ;; I don't often w3m to edit pages, so I'm borrowing o and e (right
  ;; below , / . for tab navigation) for page navigation instead.
  (define-key w3m-mode-map "o" 'w3m-view-previous-page)
  (define-key w3m-mode-map "e" 'w3m-view-next-page)
  ;; i is a more useful mnemonic for toggling images
  (define-key w3m-mode-map "i" 'w3m-toggle-inline-image)
  (define-key w3m-mode-map "I" 'w3m-toggle-inline-images)
  ;; and X for closing the buffer
  (define-key w3m-mode-map "X" 'w3m-delete-buffer)
  (define-key w3m-mode-map "x" 'w3m-delete-buffer)
  (define-key w3m-mode-map "z" 'w3m-delete-buffer)
  ;; and b for bookmarks
  (define-key w3m-mode-map "b" 'w3m-bookmark-view)
  ;; I don't use the Qwerty keymap, so hjkl is useless for me
  ;; I'll use HTNS, though
  (define-key w3m-mode-map "H" 'backward-char)
  (define-key w3m-mode-map "T" 'previous-line)
  (define-key w3m-mode-map "N" 'next-line)
  (define-key w3m-mode-map "S" 'forward-char)
  ;; Browse in new sessions by default
  (define-key w3m-mode-map (kbd "RET") 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map [(shift return)] 'w3m-view-this-url)
  (define-key w3m-mode-map "g" 'w3m-goto-url)
  (define-key w3m-mode-map "G" 'w3m-goto-url-new-session)
  ;; f for forward? I want to be able to follow links without removing
  ;; most of my fingers from home row. My fingers are too short to hit
  ;; Enter.
  (define-key w3m-mode-map "f" 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map "F" 'w3m-view-this-url)
  ;; Use cursor keys to scroll
  (define-key w3m-mode-map [(left)] 'backward-char)
  (define-key w3m-mode-map [(right)] 'forward-char)
  (define-key w3m-mode-map [(shift left)] 'w3m-shift-right)
  (define-key w3m-mode-map [(shift right)] 'w3m-shift-left)
  ;; Which means I can now use , and . to switch pages
  (define-key w3m-mode-map "." 'w3m-next-buffer)
  (define-key w3m-mode-map "," 'w3m-previous-buffer)
  ;; IBM stuff
  (define-key w3m-mode-map "i" nil)
  (define-key w3m-mode-map "ib" 'sacha/ibm-blog)
  (define-key w3m-mode-map "id" 'sacha/dogear-url)
  (define-key w3m-mode-map "f" 'sacha/w3m-open-in-firefox)

  )

(setq w3m-keep-arrived-urls 5000)
(add-hook 'w3m-mode-hook 'sacha/w3m-setup-keymap)
;;(sacha/w3m-setup-keymap)

(defun sacha/w3m-open-in-firefox ()
  (interactive)
  (browse-url-firefox w3m-current-url))

(eval-after-load 'w3m
  '(progn
     (define-key w3m-mode-map "q" 'w3m-previous-buffer)
     (define-key w3m-mode-map "w" 'w3m-next-buffer)
     (define-key w3m-mode-map "x" 'w3m-close-window)))

#+end_src 

*** Sometimes need to re-wrap page

http://emacs-w3m.namazu.org/ml/msg10827.html

#+begin_src emacs-lisp 

(add-hook 'w3m-mode-hook
          (lambda ()
            (define-key w3m-mode-map "L" 'w3m-page-fill)))

(defun w3m-page-fill ()
  (interactive)
  (let ((w3m-fill-column (min (cond
                               ((boundp 'mew-summary-wrap-lines-column)
                                mew-summary-wrap-lines-column)
                               ((boundp 'message-fill-column)
                                message-fill-column)
                               (t
                                fill-column))
                              (- (window-width) 5))))
    (if (eq last-command this-command)
        (let ((pos (point-marker))
              (buffer-read-only nil)
              (inhibit-read-only t)
              (after-change-functions nil)
              (inhibit-point-motion-hooks t)
              beg)
          (save-excursion
            (goto-char (point-min))
            (when (memq 'w3m-header-line-location-title
                        (get-text-property (point) 'face))
              (forward-line 1))
            (if (fboundp 'mew-wrap-lines)
                (mew-wrap-lines (point) (point-max))
              (fill-region (point) (point-max))))
          (goto-char pos))
      (w3m-redisplay-this-page))))

#+end_src 

#+begin_src emacs-lisp :tangle no

(setq w3m-fill-column 120)

#+end_src 


*** jwiegley settings

#+begin_src emacs-lisp 

(setq w3m-cookie-accept-bad-cookies (quote ask))
(setq w3m-fill-column 80)



#+end_src 



** winner
A feature to preserve split pane configuration. Use 【Ctrl+c ←】 and
【Ctrl+c →】

#+begin_src emacs-lisp 

(use-package winner
  :diminish winner-mode
  :if (not noninteractive)
  :init
  (progn
    (winner-mode 1)

    (bind-key "M-N" 'winner-redo)
    (bind-key "M-P" 'winner-undo)))

#+end_src 
    
** workgroups

#+begin_src emacs-lisp

(use-package workgroups
  :diminish workgroups-mode
  :commands wg-switch-to-index-1
  :if (not noninteractive)
  :init
  (progn
    (defvar workgroups-preload-map)
    (define-prefix-command 'workgroups-preload-map)

    (bind-key "C-8" 'workgroups-preload-map)
    (bind-key "C-8" 'wg-switch-to-index-1 workgroups-preload-map)
    (bind-key "0" 'wg-switch-to-index-0 workgroups-preload-map)
    (bind-key " 1" 'wg-switch-to-index-1 workgroups-preload-map)
    (bind-key " 2" 'wg-switch-to-index-2 workgroups-preload-map)
    (bind-key " 3" 'wg-switch-to-index-3 workgroups-preload-map)
    (bind-key " 4" 'wg-switch-to-index-4 workgroups-preload-map)
    (bind-key " 5" 'wg-switch-to-index-5 workgroups-preload-map)
    (bind-key " 6" 'wg-switch-to-index-6 workgroups-preload-map)
    (bind-key " 7" 'wg-switch-to-index-7 workgroups-preload-map)
    (bind-key " 8" 'wg-switch-to-index-8 workgroups-preload-map)
    (bind-key " 9" 'wg-switch-to-index-9 workgroups-preload-map)
)

  :config
  (progn
    (workgroups-mode 1)


    (let ((workgroups-file (expand-file-name "workgroups" user-emacs-directory)))
      (if (file-readable-p workgroups-file)
          (wg-load workgroups-file)))

    (bind-key "C-\\" 'wg-switch-to-previous-workgroup wg-map)
    (bind-key "\\" 'toggle-input-method wg-map)))

#+end_src 


Very large terminal geometries (270x70 or higher) can also cause
very slow redisplay in xterm. Until I figure out the best way to
handle this, you should just see what works, and either set your
background color or turn off morphing with:

#+begin_src emacs-lisp
    
(setq wg-morph-on nil)

#+end_src 


** wrap-region

#+begin_src emacs-lisp 

(use-package wrap-region
  :commands wrap-region-mode
  :diminish wrap-region-mode
  :config
  (wrap-region-add-wrappers
   '(("$" "$")
     ("/" "/" nil ruby-mode)
     ("/* " " */" "#" (java-mode javascript-mode css-mode
                                 c-mode c++-mode))
     ("`" "`" nil (markdown-mode ruby-mode shell-script-mode)))))

#+end_src 

** yasnippet

#+begin_src emacs-lisp :tangle no

(use-package yasnippet
  :if (not noninteractive)
  :diminish yas/minor-mode
  :commands (yas/minor-mode yas/expand)
  :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
  :init
  (hook-into-modes #'(lambda () (yas/minor-mode 1))
                   '(prog-mode-hook
                     org-mode-hook
                     ruby-mode-hook
                     message-mode-hook
                     gud-mode-hook
                     erc-mode-hook))
  :config
  (progn
    (yas/initialize)
    (yas/load-directory (expand-file-name "snippets/" user-emacs-directory))

    (bind-key "<tab>" 'yas/next-field-or-maybe-expand yas/keymap)

    (defun yas/new-snippet (&optional choose-instead-of-guess)
      (interactive "P")
      (let ((guessed-directories (yas/guess-snippet-directories)))
        (switch-to-buffer "*new snippet*")
        (erase-buffer)
        (kill-all-local-variables)
        (snippet-mode)
        (set (make-local-variable 'yas/guessed-modes)
             (mapcar #'(lambda (d)
                         (intern (yas/table-name (car d))))
                     guessed-directories))
        (unless (and choose-instead-of-guess
                     (not (y-or-n-p "Insert a snippet with useful headers? ")))
          (yas/expand-snippet "\
# -*- mode: snippet -*-
# name: $1
# --
$0"))))

    (bind-key "C-c y TAB" 'yas/expand)
    (bind-key "C-c y n" 'yas/new-snippet)
    (bind-key "C-c y f" 'yas/find-snippets)
    (bind-key "C-c y r" 'yas/reload-all)
    (bind-key "C-c y v" 'yas/visit-snippet-file)))

#+end_src     

** zencoding-mode

#+begin_src emacs-lisp 

(use-package zencoding-mode
  :commands zencoding-mode
  :init
  (progn
    (add-hook 'nxml-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook
              #'(lambda ()
                (bind-key "<return>" 'newline-and-indent html-mode-map))))

  :config
  (progn
    (defvar zencoding-mode-keymap (make-sparse-keymap))
    (bind-key "C-c C-c" 'zencoding-expand-line zencoding-mode-keymap)))

#+end_src     

* Programming (IDE)
** Magit

#+begin_src emacs-lisp 

(require 'magit)

(setq magit-repo-dirs (quote
(
        "/home/user/git/project"
        "/home/user/git/project2"
        "/su:user@localhost:/home/www/project1"
)))

#+end_src 

** Comment Box

In a [[http://irreal.org/blog/?p%3D371#comment-1543][comment]] to my [[http://irreal.org/blog/?p%3D371][Emacs comment-box Revisited]] post, Aaron showed me a
nice way to deal with the boundaries of expanding regions. Recall that
in that post I wanted to pad the first line of a comment out to the
fill column so that comment-box would draw the box across the whole
width (more or less) of the window. The problem was that adding those
blanks increased the size of the region so the character number of the
end of the region was no longer correct. In my code that was easily
fixed because I could use (point-max) to locate the end of the region
since I had narrowed the buffer to the region.

Aaron’s way of handling this is nice because it feels less ad hoc and
because it works for any position in the buffer not just the beginning
or end. The idea is to use a marker to point at the end of the
region. Conceptually, a marker is just like a position (that is a
character index into the buffer) but it has the nice property that if
you change the size of the buffer, the marker is adjusted when
necessary. It’s as if you planted a flag at the position and the flag
moves as the buffer expands or contracts.

Here’s what the revised code looks like

#+begin_src emacs-lisp 
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

#+end_src 

** Compilation settings

#+begin_src emacs-lisp 

(setq compilation-scroll-output 1)

;;; Shut up compile saves
(setq compilation-ask-about-save nil)
;;; Don't save *anything*
(setq compilation-save-buffers-predicate '(lambda () nil))

#+end_src 



** camelCase

You can set emacs so that word moving commands will move cursor into
between CamelCaseWords. (word deletion behavior also changes
accordingly.)

To toggle it globally, call “global-subword-mode”. To set it for
current file only, call “subword-mode”. (subword mode is available in
Emacs 23.2)

To set it permanently, put one of the following in your emacs init
file:

#+begin_src emacs-lisp 

(subword-mode 1) ; 1 for on, 0 for off
(global-subword-mode 1) ; 1 for on, 0 for off

#+end_src 

** Whitespace

#+begin_src emacs-lisp 

(require 'whitespace)
(global-set-key (kbd "C-c w") 'whitespace-mode)
(global-set-key (kbd "C-c W") 'whitespace-toggle-options)
(setq whitespace-line-column 80
      whitespace-style '(tabs trailing lines-tail))
(set-face-attribute 'whitespace-line nil
                    :background "red1"
                    :foreground "yellow"
                    :weight 'bold)

;; face for Tabs
(set-face-attribute 'whitespace-tab nil
                    :background "red1"
                    :foreground "yellow"
                    :weight 'bold)
#+end_src 

** Programming languages

#+begin_src emacs-lisp 

(require 'js-mode-expansions)
(require 'html-mode-expansions)
(require 'css-mode-expansions)

#+end_src 

** Eclim
         
#+begin_src emacs-lisp :tangle no

(setq eclim-auto-save t) ;; very important (global-eclim-mode)

#+end_src 

** Eproject

(require 'eproject)
(require 'eproject-extras)

(define-project-type web (generic)
;;  (look-for "plan.org")
  (look-for "admin.php")
  :relevant-files ("\\.php$" "\\.js$" "\\.org$" "\\.sql$" "\\.css$" "authinfo" "vhost"))

(add-hook 'web-project-file-visit-hook '(lambda ()
                      (ignore-errors
                        (message "Web Project : %s" eproject-root)
                        )))

(define-project-type emacs-config (generic)
  (look-for "starter-kit.org")
  :relevant-files ("\\.el$" "\\.org$" "\\.gpg$"))

(add-hook 'emacs-config-project-file-visit-hook '(lambda ()
                           (ignore-errors
                             (message "Emacs Configuration")
                             )))

;;  (define-project-type php-web (generic)
;;    (look-for "plan.org")
;;    :relevant-files ("\\.php$" "\\.css$" "authinfo" "vhost"))

;;  (add-hook 'php-web-project-file-visit-hook '(lambda ()
;;    (ignore-errors
;;      (message "PHP-WEB")
;;      )))

(defmacro .emacs-curry (function &rest args)
  `(lambda () (interactive)
     (,function ,@args)))

(defmacro .emacs-eproject-key (key command)
  (cons 'progn
        (loop for (k . p) in (list (cons key 4) (cons (upcase key) 1))
              collect
              `(global-set-key
                (kbd ,(format "C-x p %s" k))
                (.emacs-curry ,command ,p)))))

(.emacs-eproject-key "k" eproject-kill-project-buffers)
(.emacs-eproject-key "v" eproject-revisit-project)
(.emacs-eproject-key "b" eproject-ibuffer)
(.emacs-eproject-key "o" eproject-open-all-project-files)

#+end_src 


** Etags

#+begin_src emacs-lisp 

(require 'etags-select)

;; list of file names of tags tables to search
(setq tags-table-list
      '(
"~/.emacs.d/TAGS"
        ))

#+end_src 

*** TODO Etags with IDO

#+begin_src emacs-lisp 

(defun ido-find-tag ()
  "Find a tag using ido"
  (interactive)
  (tags-completion-table)
  (let (tag-names)
    (mapc (lambda (x)
        (unless (integerp x)
          (push (prin1-to-string x t) tag-names)))
      tags-completion-table)
    (find-tag (ido-completing-read "Tag: " tag-names))))
 
(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))
 
(global-set-key [remap find-tag] 'ido-find-tag)
(global-set-key (kbd "H-.") 'ido-find-file-in-tag-files)

(defun pm/find-tags-file ()
  "Recursively searches each parent directory for a file named `TAGS'
   and returns the path to that file or nil if a tags file is not found.
   Returns nil if the buffer is not visiting a file.
   (from jds-find-tags-file in the emacs-wiki)"
  (labels ((find-tags-file-r
            (path)
            (let* ((parent (if path (file-name-directory path)
                             default-directory))
                   (possible-tags-file (concat parent "TAGS")))
              (cond
               ((file-exists-p possible-tags-file)
                (shell-command (concat "make -C" parent " TAGS"))
                (throw 'found-it possible-tags-file))
               ((string= "/TAGS" possible-tags-file)
                (error "no tags file found"))
               (t
                (find-tags-file-r (directory-file-name parent)))))))
    (catch 'found-it 
      (find-tags-file-r (buffer-file-name)))))

(defadvice find-tag (before pm/before-find-tag activate)
  (setq tags-file-name (pm/find-tags-file)))

#+end_src 

** Generic X (for Apache logs)

#+begin_src emacs-lisp 

(require 'generic-x)

(define-generic-mode 'htaccess-mode
  '(?#)
  '(;; core
    "AcceptPathInfo" "AccessFileName" "AddDefaultCharset" "AddOutputFilterByType"
    "AllowEncodedSlashes" "AllowOverride" "AuthName" "AuthType"
    "CGIMapExtension" "ContentDigest" "DefaultType" "DocumentRoot"
    "EnableMMAP" "EnableSendfile" "ErrorDocument" "ErrorLog"
    "FileETag" "ForceType" "HostnameLookups" "IdentityCheck"
    "Include" "KeepAlive" "KeepAliveTimeout" "LimitInternalRecursion"
    "LimitRequestBody" "LimitRequestFields" "LimitRequestFieldSize" "LimitRequestLine"
    "LimitXMLRequestBody" "LogLevel" "MaxKeepAliveRequests" "NameVirtualHost"
    "Options" "Require" "RLimitCPU" "RLimitMEM"
    "RLimitNPROC" "Satisfy" "ScriptInterpreterSource" "ServerAdmin"
    "ServerAlias" "ServerName" "ServerPath" "ServerRoot"
    "ServerSignature" "ServerTokens" "SetHandler" "SetInputFilter"
    "SetOutputFilter" "TimeOut" "UseCanonicalName"
    ;; .htaccess tutorial
    "AddHandler" "AuthUserFile" "AuthGroupFile"
    ;; mod_rewrite
    "RewriteBase" "RewriteCond" "RewriteEngine" "RewriteLock" "RewriteLog"
    "RewriteLogLevel" "RewriteMap" "RewriteOptions" "RewriteRule"
    ;; mod_alias
    "Alias" "AliasMatch" "Redirect" "RedirectMatch" "RedirectPermanent"
    "RedirectTemp" "ScriptAlias" "ScriptAliasMatch")
  '(("%{\\([A-Z_]+\\)}" 1 font-lock-variable-name-face)
    ("\\b[0-9][0-9][0-9]\\b" . font-lock-constant-face)
    ("\\[.*\\]" . font-lock-type-face))
  '(".htaccess\\'")
  nil
  "Generic mode for Apache .htaccess files.")

(add-to-list 'auto-mode-alist '("\\.htaccess\\'" . htaccess-mode))

#+end_src

** HTML MODE

#+begin_src emacs-lisp 

(defun my-html-mode-setup ()                                    
(auto-fill-mode -1))                                          
(add-hook 'html-mode-hook 'my-html-mode-setup)

(defun prettify-key-sequence (&optional omit-brackets)
    "Markup a key sequence for pretty display in HTML.
  If OMIT-BRACKETS is non-null then don't include the key sequence brackets."
    (interactive "P")
    (let* ((seq (thing-at-point 'symbol))
           (key-seq (elt seq 0))
           (beg (elt seq 1))
           (end (elt seq 2))
           (key-seq-map (list (key "Ctrl") (key "Meta") (key "Shift")
                              (key "Tab") (key "Alt") (key "Esc")
                              (key "Enter") (key "Return") (key "Backspace")
                              (key "Delete") (key "F10") (key "F11")
                              (key "F12") (key "F2") (key "F3")
                              (key "F4") (key "F5") (key "F6") (key "F7")
                              (key "F8") (key "F9")
                              ;; Disambiguate F1
                              '("\\`F1" . "@<span class=\"key\">F1@</span>")
                              '("\\([^>]\\)F1" .
                                "\\1@<span class=\"key\">F1@</span>")
                              ;; Symbol on key
                              '("Opt" . "@<span class=\"key\">⌥ Opt@</span>")
                              '("Cmd" . "@<span class=\"key\">⌘ Cmd@</span>")
                              ;; Combining rules
                              '("\+\\(.\\) \\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span>")
                              '("\+\\(.\\) \\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span> ")
                              '("\+\\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> ")
                              '("\+\\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span>"))))
      (mapc (lambda (m) (setq key-seq (replace-regexp-in-string
                                       (car m) (cdr m) key-seq t)))
            key-seq-map)
      ;; Single key
      (if (= (length key-seq) 1)
          (setq key-seq (concat "@<span class=\"key\">" key-seq "@</span>")))
      (delete-region beg end)
      (if omit-brackets
          (insert key-seq)
        (insert (concat "【" key-seq "】")))))
  
(defalias 'pks 'prettify-key-sequence)

(defun open-in-desktop ()
  "Open the current file in desktop.
Works in Microsoft Windows, Mac OS X, Linux."
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux") (shell-command "xdg-open ."))
   ) )

(global-set-key (kbd "<f7>") 'open-in-desktop)


#+end_src

** JavaScript

#+begin_src emacs-lisp 

(starter-kit-load "js")

#+end_src 

** PSVN (subversion)

#+begin_src emacs-lisp 

;;; psvn
(setq svn-status-prefix-key '[(hyper s)])
(require 'psvn)
(define-key svn-log-edit-mode-map [f6] 'svn-log-edit-svn-diff)

(defun xsteve-svn-log-edit-setup ()
  (setq ispell-local-dictionary "english")
  (auto-fill-mode 1))

(add-hook 'svn-log-edit-mode-hook 'xsteve-svn-log-edit-setup)

#+end_src 

** Yas

#+begin_src emacs-lisp 

(yas/load-directory "~/git/.emacs.d/snippets2")

(yas/load-directory "~/git/.emacs.d/snippets")

(yas/define-snippets 'text-mode
             '(("email" "me@google.com" "(user's email)" nil nil nil nil nil)
               ("phone" "777-777-7777" "(phone numer)" nil nil nil nil nil)
               ("thanks" "Thanks. Let me know if you have any questions or concerns" "(salutation)" nil nil nil nil nil)
               ("time" "`(current-time-string)`" "(current time)" nil nil nil nil nil))
             'nil)

(setq yas/indent-line nil)

#+end_src 

** ECB

#+begin_src emacs-lisp :tangle no

;;(require 'cedet)

(add-hook 'ecb-deactivate-hook                                                                                                                          
      '(lambda ()                                                                                                                                       
         (ecb-disable-advices 'ecb-winman-not-supported-function-advices t)))

#+end_src 

** Stack Exchange mode

#+begin_src emacs-lisp 

;; Integrate Emacs with Stack Exchange http://stackoverflow.com/a/10386560/789593                                                       
(add-to-list 'auto-mode-alist '("\\(stack\\(exchange\\|overflow\\)\\|superuser\\|askubuntu\\)\\.com\\.[a-z0-9]+\\.txt" . markdown-mode))

#+end_src 

** Glasses mode
#+begin_src emacs-lisp 

;; face to be put on capitals of an identifier looked through glasses
(setq glasses-face 'bold)

;; string to be displayed as a visual separator in unreadable identifiers
(setq glasses-separator "")

#+end_src 

** Quick Tip: Spaces instead of Tabs
[2011-10-14 Fri 14:06]

September 30th, 2007 by Ryan McGeary · 11 Comments

Tab characters used as indentation of source code is a pet peeve of
mine. Add this to your emacs initialization to make sure all
indentation uses spaces instead.

#+begin_src emacs-lisp 

;; I hate tabs!
;; let tabs indent 4 spaces
(setq-default indent-tabs-mode nil)
(setq default-tab-width 4)
(setq indent-line-function 'insert-tab)

#+end_src 

** Whitespace mode

As usual Prelude comes with a lot of whitespace handling magic
pre-enabled (similar to the last tweets). whitespace-mode ftw :-)

#+begin_src emacs-lisp 

(setq whitespace-action '(auto-cleanup)) (whitespace-mode) ;; automatically clean up bad whitespace

(setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab)) ;; only show bad whitespace

(setq whitespace-style '(face trailing lines-tail) whitespace-line-column 80) 

;; handy too: ;; highlight long lines tails

#+end_src 

** Semantic
#+begin_src emacs-lisp

(setq semantic-load-turn-useful-things-on t)

#+end_src 

* Unicode

#+begin_src emacs-lisp 
;; set unicode data file location. (used by what-cursor-position and describe-char)
(let ((x "~/git/.emacs.d/UnicodeData.txt"))
  (when (file-exists-p x)
    (setq describe-char-unicodedata-file x)))

(defun my-print-chars (&optional start end)
  (interactive "nstart: \nnend: ")
  (switch-to-buffer (get-buffer-create "*UNICODE*"))
  (erase-buffer)
  (let ( (i start) )
    (while (<= i end)
      (insert (format "%s: U+%04x, %s\n" (char-to-string i) i (get-char-code-property i 'name)))
      (setq i (1+ i))
      )))

#+end_src 

* Fun (random)
** life expectancy

(setq sacha/life-expectancy 90)
(setq sacha/birth-date '(05 12 1971))
(defun sacha/memento-mori ()
  (interactive)
  (let* ((expected (list
                    (elt sacha/birth-date 0)
                    (elt sacha/birth-date 1)
                    (+ (elt sacha/birth-date 2) sacha/life-expectancy)))
       (days-left (- (calendar-absolute-from-gregorian expected)
                     (time-to-days (current-time)))))
    (message "~ %d years or %d months or %d weeks left; make the most of them!"
             (/ days-left 365)
             (/ days-left 30)
             (/ days-left 7))))

#+end_src 

* Turn off debugging

#+begin_src emacs-lisp :tangle no

;; Something in el-get is setting debug-on-error to t.
;; Not cool.
(if debug-on-error
    (setq debug-on-error nil))

#+end_src 

* Footnotes

