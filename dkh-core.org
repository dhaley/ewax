#+TITLE: Damon Haley's Emacs 24 Configuration
#+OPTIONS: toc:2 num:nil ^:nil
#+CATEGORY: Emacs Init File

#+begin_quote
  Emacs outshines all other editing software in approximately the same
  way that the noonday sun does the stars. It is not just bigger and
  brighter; it simply makes everything else vanish.

  -- Neal Stephenson, "In the Beginning was the Command Line"
#+end_quote

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

I've been using [[http://eschulte.me/emacs24-starter-kit/#installation][Emacs Starter Kit]] and the literate programming
features in [[http://orgmode.org/worg/org-contrib/babel/][org-babel]] for some time.

Partly inspired by [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file][Sacha Chua's 2012 blog post]], I finally decided to
make my config public to share.

** Installation
   :PROPERTIES:
   :CUSTOM_ID: installation
   :END:

1. Install Emacs version 24 or greater.  Use your package manager if
   you have one and it has an install candidate for Emacs 24,
   otherwise install it directly [[http://savannah.gnu.org/projects/emacs/][from source]], or Mac binaries may be
   downloaded from the /nightlies/ section of
   http://emacsformacosx.com/builds
2. Checkout a version of the starter kit using git -- if you're new to
   git checkout this [[http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html][git-tutorial]], also we'd highly recommend that you
   try out [[http://zagadka.vm.bytemark.co.uk/magit/magit.html][magit]] the Emacs mode for git interaction.
   #+begin_src sh
     git clone http://github.com/eschulte/emacs24-starter-kit.git
   #+end_src
3. Move the resulting directory to =~/.emacs.d= [1]

* Implementation
  :PROPERTIES:
  :CUSTOM_ID: implementation
  :END:

** Load Starter Kit packages

#+begin_src emacs-lisp 

(starter-kit-load "misc-recommended")

#+end_src 
** Verbose debug

#+begin_src emacs-lisp 

(message "emacs-init started ...")
(setq debug-on-error t)

#+end_src 

** Packages
*** El-Get

#+begin_src emacs-lisp 

;; added by dkh
(add-to-list 'load-path (concat user-emacs-directory "el-get/el-get"))

(setq load-path
      (append (list nil
                    )
              load-path))

(add-to-list 'load-path (expand-file-name "~/git/foss/org-mode/contrib/lisp"))

#+end_src 

**** Get stable branch

#+begin_src emacs-lisp :tangle no
(unless (require 'el-get nil t)
  (url-retrieve
   "https://github.com/dimitri/el-get/raw/master/el-get-install.el"
   (lambda (s)
     (end-of-buffer)
     (eval-print-last-sexp))))

#+end_src 

**** OR get devel branch

#+begin_src emacs-lisp :tangle no

;; So the idea is that you copy/paste this code into your *scratch* buffer, ;; hit C-j, and you have a working developper edition of el-get.
 (url-retrieve
   "https://raw.github.com/dimitri/el-get/master/el-get-install.el"
   (lambda (s) (let (el-get-master-branch) (goto-char (point-max))
   (eval-print-last-sexp))))

#+end_src 


**** Sources and packages




#+begin_src emacs-lisp

(require 'el-get)

;; (setq
;;  el-get-sources
;;  '(
;;    (:name eproject :type git :url "https://github.com/jrockway/eproject.git" :features "eproject-extras")
;;    ))


;; now set our own packages
(setq
 my:el-get-packages
 '(
   auto-install
   autosmiley
   browse-kill-ring+
   dictem
   el-get ; el-get is self-hosting
   emacs-w3m
   emoticons
   erc-highlight-nicknames
   face-list
   fliptext
   grep+
   keychain-environment
   paste2
   protbuf
   savehist-20+
   second-sel
   tail
   thing-cmds ;; for thing-region
   thingatpt-ext ;; for 'string
   ))


;; (when (el-get-executable-find "svn")
;;   (loop for p in '(psvn                 ; M-x svn-status
;;                    )
;;         do (add-to-list 'el-get-sources p)))


;; (setq my:el-get-packages
;;       (append
;;        my:el-get-packages
;;        (loop for src in el-get-sources collect (el-get-source-name src))))


(el-get 'sync my:el-get-packages)

#+end_src 


*** Install the packages I need if not already installed

#+begin_src emacs-lisp 

(defun rwd-require-package (name)
(or (package-installed-p name) (package-install name)))

(setq dkh-required-packages
      (list
        'auctex
        'auto-indent-mode
        'bitlbee
        'bm
        'bookmark+
        'browse-kill-ring
        'buffer-move
        'color-theme-solarized
        'etags-select
        'expand-region
        'fill-column-indicator
        'guru-mode
        'js2-mode
        'key-chord
        'lorem-ipsum
        'magit
        'nav
        'oauth2
        'org2blog
        'org-mime
        'pastebin
        'perspective
        'php-mode
        'rainbow-delimiters
        'rainbow-mode
        'rotate-text
        'sauron
        'session
        'smex
        'switch-window
        'synonyms
        'undo-tree
        'window-number
        'winpoint
        'xml-rpc
        'yaml-mode
))

(package-refresh-contents)
(dolist (package dkh-required-packages) (when (not (package-installed-p package)) (package-install package)))

#+end_src 

* Custom settings
** Custom file location

#+begin_src emacs-lisp 

(setq custom-file "~/git/.emacs.d/custom.el")

#+end_src 

** Default directory

#+begin_src emacs-lisp 

(setq default-directory "~/git/")

#+end_src 

** Save my history

#+begin_src emacs-lisp 

(setq savehist-file "~/.emacs.d/history")

#+end_src 

** Ispell

#+begin_src emacs-lisp 

(setq ispell-personal-dictionary "~/git/.emacs.d/.aspell.LANG.pws")

#+end_src 

** Messages buffer
[2012-01-03 Tue 11:42]

The buffer called *Messages* is GnuEmacs’s error log, where all sorts
of useful information is printed, including information that appears
in the EchoArea (except for keystroke echoes). You can adjust the
number of messages kept in the buffer with the variable

#+begin_src emacs-lisp 

(setq message-log-max 1000)

#+end_src

** Scratch Buffer

#+begin_src emacs-lisp 

(setq initial-scratch-message "ಠ_ಠ")
;; empty out the comments on the scratch buffer, (i hate that text)

#+end_src 

** Enable all disabled commands

#+begin_src emacs-lisp 

;; Enable all disabled commands (eval-expression, narrow-to-..., etc.)
(setq disabled-command-function nil)
#+end_src 

** Window settings
*** Pop up windows

#+begin_src emacs-lisp 

(setq pop-up-windows nil)

#+end_src 

*** Use same window

#+begin_src emacs-lisp 

(add-to-list 'same-window-buffer-names "*Help*")
(add-to-list 'same-window-buffer-names "*Apropos*")
(add-to-list 'same-window-buffer-names "*Summary*")
 (add-to-list 'same-window-buffer-names "*Backtrace*")



;; Define buffers that should appear in the same window.
(add-to-list 'same-window-buffer-names "*Buffer List*")
(add-to-list 'same-window-buffer-names "*Colors*")
(add-to-list 'same-window-buffer-names "*Command History*")
(add-to-list 'same-window-buffer-names "*Diff*")
(add-to-list 'same-window-buffer-names "*Proced*")
(add-to-list 'same-window-buffer-names "*vc-dir*")
(add-to-list 'same-window-buffer-names "*SQL*")
(add-to-list 'same-window-buffer-names "scratch.org")


(setq same-window-regexps '(
                          "\*grep\*"
))

(add-to-list 'same-window-regexps "\\*compilation\\*\\(\\|<[0-9]+>\\)")
(add-to-list 'same-window-regexps "\\*Help\\*\\(\\|<[0-9]+>\\)")

(add-to-list 'same-window-regexps "\\*Shell Command Output\\*\\(\\|<[0-9]+>\\)")

(add-to-list 'same-window-regexps "\\*dictem.*")

#+end_src 

** Icomplete mode

#+begin_src emacs-lisp 

(icomplete-mode 1)

(setq sentence-end-double-space nil)

(global-set-key (kbd "RET") 'newline-and-indent)

#+end_src 

** Scrollbars

#+begin_src emacs-lisp 

(scroll-bar-mode -1)                   ;; turn off the scrollbar
;;(scroll-bar-mode 1)                       ;; otherwise, show a scrollbar...
;;(set-scroll-bar-mode 'right))             ;; ... on the right

#+end_src 

** Session save config

#+begin_src emacs-lisp 

(setq session-save-file "~/.emacs.d/.session")

#+end_src 

** Fonts

#+begin_src emacs-lisp 

(setq mswindows-p (string-match "windows" (symbol-name system-type)))
(setq macosx-p (string-match "darwin" (symbol-name system-type)))
(setq linux-p (string-match "gnu/linux" (symbol-name system-type)))

;; We know we have consolas on OS X, so use it
;; We also need to do this as near the beginning as possible, since it crashes
;; otherwise?
(when (and macosx-p
  (when (member "Consolas" (font-family-list))
    (set-face-font 'default "consolas-11"))))
(when mswindows-p
  (set-face-font 'default "consolas-8"))
(when linux-p
  (when (member "Inconsolata" (font-family-list))
;;    (set-face-font 'default "inconsolata-11")
;;    (set-face-font 'default "DejaVu Sans Mono-9")
(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-12"))
))

(when macosx-p
  ;;Change meta to alt
  (setq mac-command-modifier 'meta)
  ;;avoid hiding with M-h
  (setq mac-pass-command-to-system nil))

#+end_src 

 You can get text properties of any char by typing `C-u C-x ='

 Under Windows, you can get the current font string by typing
 `(insert (format "\n%S" (w32-select-font)))' followed by `C-x C-e'

 You can find the current font by typing
 `M-x ielm RET (frame-parameters) RET'
 see the line `font'

 To check if some font is available in Emacs do following:
    1.   Switch to the `*scratch*' buffer.
    2.   Type `(prin1-to-string (x-list-fonts "font-you-want-to-check or
         pattern"))'.
    3.   Place the cursor after the last closing paren and hit
         `C-j'. List of the names of available fonts matching given
         pattern will appear in the current buffer (`*scratch*').
    4.   For listing of all available fonts, use
         `(prin1-to-string (x-list-fonts "*"))' or
         `(dolist (i (x-list-fonts "*")) (princ i) (terpri))'
         for a better output.

 Format: "-a-b-c-d-e-f-g-h-i-j-k-l-"
 where

 a = foundry

 b = font family <<<

 c = weight
     Valid options: `bold', `demibold', `light', `medium', `normal'.

 d = slant
     Valid options: `i' for italic and `r' for roman.

 e = set width
     Ignored by NT-Emacs.

 f = pixels
     Nominal font height in pixels. (Eg. 13 pixels roughly corresponds to
     10 points (a point is 1/72 of an inch) on a 96dpi monitor, so the
     font spec above is selecting a 10 point bold Courier font)

 g = points in tenths of a point
     10 point is 100

 h = horiz resolution in dpi
     I think these numbers represent the "design resolution" of the font -
     on X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

 i = vertical resolution in dpi
     I think these numbers represent the "design resolution" of the font -
     on X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

 j = spacing
     Spacing as in mono-spaced or proportionally spaced.
     Values are `c' (constant) or `m' (monospace) to mean fixed-width or
     `p' for proportionally spaced.

 k = average width in tenths of a pixel

 l = character set
     NT-Emacs understands: ansi, oem, symbol to refer to the standard
     Windows character sets (the first two, at least, are locale
     dependant). "iso8859" and "iso8859-1" are accepted as synonyms for
     ansi.

 Use `xfontsel' utility (or the command-line `xlsfonts') to try out
 different fonts. After choosing a font, click the select button in
 `xfontsel' window. This will copy font name you choose to copy & paste
 buffer.
 Edit your `~/.Xresources' file to have a line with "Emacs.font".
 Then do a `xrdb -merge ~/.Xresources' or restart your X11 to validate the
 modification. I let emacs do this for me:

#+begin_src emacs-lisp 

(defun merge-x-resources ()
  (let ((file (file-name-nondirectory (buffer-file-name))))
    (when (or (string= file ".Xdefaults")
              (string= file ".Xresources"))
      (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
      (message (format "Merged %s into X resource database" file)))))

(add-hook 'after-save-hook 'merge-x-resources)

#+end_src 

Now Emacs should start with that font.

For reasons unknown to me,'emacs' takes a long file to change fonts in an X
environment.

Rather than using (set-default-font ...) in .emacs, stick the font
definition in your .Xresources file (key 'Emacs*font') and then use 'xrdb
-load' to activate it. You will find that startup time is greatly improved!

#+begin_src emacs-lisp 

;; avoid Emacs hanging for a while changing default font
(modify-frame-parameters nil '((wait-for-wm . nil)))

#+end_src 

*** Faces

#+begin_src emacs-lisp :tangle no

(custom-set-faces                                                                           
  ;; custom-set-faces was added by Custom.                                                  
  ;; If you edit it by hand, you could mess it up, so be careful.                           
  ;; Your init file should contain only one such instance.                                  
 ;; If there is more than one, they won't work right.                                      
 '(mumamo-background-chunk-major ((((class color) (min-colors 8)) (:background "white")))))

#+end_src 

*** Cycle font (functions)

#+begin_src emacs-lisp 

(defun cycle-font (num)
  "Change font in current frame.
Each time this is called, font cycles thru a predefined set of fonts.
If NUM is 1, cycle forward.
If NUM is -1, cycle backward.
Warning: tested on Windows Vista only."
  (interactive "p")
  ;; this function sets a property “state”. It is a integer. Possible values are any index to the fontList.
  (let (fontList fontToUse currentState nextState )
    (setq fontList (list
                    "Courier New-10" "DejaVu Sans Mono-9"
;;"Lucida Console-10"
                    "DejaVu Sans-10"
;; "Lucida Sans Unicode-10"
;; "Arial Unicode MS-10" 
;;                    "inconsolata-11"
"DejaVu Sans Mono-9" "DejaVu Sans Mono-10" "DejaVu Sans Mono-12"
))
    ;; fixed-width "Courier New" "Unifont"  "FixedsysTTF" "Miriam Fixed" "Lucida Console" "Lucida Sans Typewriter"
    ;; variable-width "Code2000"
    (setq currentState (if (get 'cycle-font 'state) (get 'cycle-font 'state) 0))
    (setq nextState (% (+ currentState (length fontList) num) (length fontList)))

    (setq fontToUse (nth nextState fontList))
    (set-frame-parameter nil 'font fontToUse)
    (redraw-frame (selected-frame))
    (message "Current font is: %s" fontToUse )

    (put 'cycle-font 'state nextState)
    )
  )

(defun cycle-font-forward ()
  "Switch to the next font, in the current frame.
See `cycle-font'."
  (interactive)
  (cycle-font 1)
  )

(defun cycle-font-backward ()
  "Switch to the previous font, in the current frame.
See `cycle-font'."
  (interactive)
  (cycle-font -1)
  )

#+end_src 

** Recent files mode

#+begin_src emacs-lisp

;; enable recent files mode.
(recentf-mode t)

(setq recentf-save-file "~/.emacs.d/recentf")


#+end_src 

** Recursive minibuffers (config)

#+begin_src emacs-lisp 

(setq enable-recursive-minibuffers t)

#+end_src 

** Security (PGP)

Designed for use with Keychain (see:
http://docs.funtoo.org/wiki/Keychain) a tool for loading the SSH
Agent and keeping it running and accessible on a machine for longer
than a single login session.

#+begin_src emacs-lisp 

(require 'keychain-environment)

#+end_src 

** Emacs maintenance
*** Delete old versions
#+begin_src emacs-lisp 

(setq delete-old-versions t)

#+end_src 
 
** Guru Mode

Guru mode disables some common keybindings and suggests the use of the
established Emacs alternatives instead.

#+begin_src emacs-lisp :tangle no

(require 'guru-mode)
(guru-mode) ;; to enable in all buffers

#+end_src

* Functionality (Ease of use)
** Flyspell
It seems like this is needed for about everything
#+begin_src emacs-lisp 

(require 'flyspell)

(setq flyspell-use-meta-tab nil)

#+end_src 
*** Modes

This stuff is needed to auto spell checking in gnus, etc.

#+begin_src emacs-lisp 

(add-hook 'c-mode-common-hook 'flyspell-prog-mode)
(add-hook 'tcl-mode-hook 'flyspell-prog-mode)

#+end_src 

** Frame functionality
*** Positioning of frame when starting Emacs

#+begin_src emacs-lisp :tangle no


(setq default-frame-alist '(
                            (height . 61) (width . 98)
                            (top . 72) (left . 36)
                            ))
(setq initial-frame-alist '((top . 72) (left . 775)))

#+end_src 

*** Set up initial frame

#+begin_src emacs-lisp :tangle no

(when window-system
  ;; list of frame parameters for creating the initial frame
  (setq initial-frame-alist '((top . 0) (left . 0)))

  (setq initial-frame-alist
        (append (list
                 '(internal-border-width . 2)
                 '(line-spacing          . 1))
                initial-frame-alist))

  ;; list of default values for frame creation
  (setq default-frame-alist
        (cond ((= (x-display-pixel-height) 1200)
               '((left . 0) (height . 74)))

              ((= (x-display-pixel-height) 1024)
               '((left . 0) (height . 63)))

              ((= (x-display-pixel-height) 800)
               (cond (running-ms-windows
                      '((left . 0) (height . 55)))
                     (running-gnu-linux
                      '((left . 0) (height . 47)
                        (vertical-scroll-bars . right)))))

              ((= (x-display-pixel-height) 768)
               '((left . 0) (height . 46)))))
)

#+end_src 

*** Set frame size according to resolution

#+begin_src emacs-lisp 

(defun set-frame-size-according-to-resolution ()
    (interactive)
    (if window-system
    (progn
      (if (> (x-display-pixel-width) 1500) ;; 1500 is the delimiter marging in px to consider the screen big
             (set-frame-width (selected-frame) 237) ;; on the big screen make the fram 237 columns big
             (set-frame-width (selected-frame) 177)) ;; on the small screen we use 177 columns
      (setq my-height (/ (- (x-display-pixel-height) 150) ;; cut 150 px of the screen height and use the rest as height for the frame
                               (frame-char-height)))
      (set-frame-height (selected-frame) my-height)
      (set-frame-position (selected-frame) 3 90) ;; position the frame 3 pixels left and 90 px down
  )))

  ;; (set-frame-size-according-to-resolution)
  (global-set-key (kbd "C-x 9") 'set-frame-size-according-to-resolution)

#+end_src 

*** Frame title

#+begin_src emacs-lisp 
(setq frame-title-format
  '("" invocation-name ": "(:eval (if (buffer-file-name)
                (abbreviate-file-name (buffer-file-name))
                  "%b"))))

#+end_src

** Window functionality (navigation, etc)
This is a visual replacement for C-x o, so here's what
dim-switch-window.el will look like if you happen to use it:
*** Switch Window

Switch window the cowabunga, dude! way

#+begin_src emacs-lisp 

(require 'switch-window)

#+end_src 

*** Show a marker in the left fringe for lines not in the buffer

#+begin_src emacs-lisp 

(setq default-indicate-empty-lines t)

#+end_src

*** Windmove

#+begin_src emacs-lisp 

(setq windmove-wrap-around t)

#+end_src 
*** Window Number Mode

#+begin_src emacs-lisp 

(require 'window-number)
(window-number-mode)
(window-number-meta-mode)

#+end_src 

*** Other window bindings

#+begin_src emacs-lisp 
;;; switch

;; Experiment with more convenient keys than `C-x o' and `M-- C-x o'.
(define-key global-map [(hyper ?\x8a7)] 'other-window)
(define-key global-map [(hyper ?\x8bd)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?\247)] 'other-window)
(define-key global-map [(hyper ?\275)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?`)] 'other-window)
(define-key global-map [(hyper ?~)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?<)] 'other-window)
(define-key global-map [(hyper ?>)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper ?,)] 'other-window)
(define-key global-map [(hyper ?.)] (lambda () (interactive) (other-window -1)))
(define-key global-map [(hyper print)] 'other-window)

#+end_src

*** Window Functions

#+begin_src emacs-lisp 

(defun my-swap-windows ()
  "If you have 2 windows, it swaps them."
  (interactive)
  (cond ((not (= (count-windows) 2))
         (message "You need exactly 2 windows to do this."))
        (t
         (let* ((w1 (first (window-list)))
                (w2 (second (window-list)))
                (b1 (window-buffer w1))
                (b2 (window-buffer w2))
                (s1 (window-start w1))
                (s2 (window-start w2)))
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (set-window-start w1 s2)
           (set-window-start w2 s1)))))

(defun my-toggle-window-split ()
  "Vertical split shows more of each line, horizontal split shows
more lines. This code toggles between them. It only works for
frames with exactly two windows."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

;; I want to be able to conmute between a split and a single window (sort of "C-x 1" for the one on focus)
(defun toggle-windows-split()
"Switch back and forth between one window and whatever split of windows we might have in the frame. The idea is to maximize the current buffer, while being able to go back to the previous split of windows in the frame simply by calling this command again."
(interactive)
(if (not(window-minibuffer-p (selected-window)))
(progn
(if (< 1 (count-windows))
(progn
(window-configuration-to-register ?u)
(delete-other-windows))
(jump-to-register ?u))))
;;(my-iswitchb-close)
)

(defun split-window-switch-buffer () (interactive)
  "Split current window and display the two last buffers used."
  (split-window)
  (switch-to-buffer (other-buffer (current-buffer)))
  )

(defun hsplit-window-switch-buffer () (interactive)
  "Split current window horizontally and display the two last buffers used."
  (split-window-horizontally)
  (switch-to-buffer (other-buffer (current-buffer)))
  )

(setq swapping-buffer nil)
(setq swapping-window nil)

(defun swap-buffers-in-windows ()
  "Swap buffers between two windows"
  (interactive)
  (if (and swapping-window
           swapping-buffer)
      (let ((this-buffer (current-buffer))
            (this-window (selected-window)))
        (if (and (window-live-p swapping-window)
                 (buffer-live-p swapping-buffer))
            (progn (switch-to-buffer swapping-buffer)
                   (select-window swapping-window)
                   (switch-to-buffer this-buffer)
                   (select-window this-window)
                   (message "Swapped buffers."))
          (message "Old buffer/window killed.  Aborting."))
        (setq swapping-buffer nil)
        (setq swapping-window nil))
    (progn
      (setq swapping-buffer (current-buffer))
      (setq swapping-window (selected-window))
      (message "Buffer and window marked for swapping."))))

(defun rotate-windows ()
 "Rotate your windows" (interactive) (cond ((not (> (count-windows) 1)) (message "You can't rotate a single window!"))
(t
 (setq i 1)
 (setq numWindows (count-windows))
 (while  (< i numWindows)
   (let* (
          (w1 (elt (window-list) i))
          (w2 (elt (window-list) (+ (% i numWindows) 1)))

          (b1 (window-buffer w1))
          (b2 (window-buffer w2))

          (s1 (window-start w1))
          (s2 (window-start w2))
          )
     (set-window-buffer w1  b2)
     (set-window-buffer w2 b1)
     (set-window-start w1 s2)
     (set-window-start w2 s1)
     (setq i (1+ i)))))))

(require 'buffer-move)

#+end_src 

*** Window functions

#+begin_src emacs-lisp 

(defun select-next-window ()
  "Switch to the next window" 
  (interactive)
  (select-window (next-window)))

(defun select-previous-window ()
  "Switch to the previous window" 
  (interactive)
  (select-window (previous-window)))

(defun buffer-same-mode (change-buffer-fun)
  (let ((current-mode major-mode)
        (next-mode nil))
    (while (not (eq next-mode current-mode))
      (funcall change-buffer-fun)
      (setq next-mode major-mode))))

(defun previous-buffer-same-mode ()
  (interactive)
  (buffer-same-mode #'previous-buffer))

(defun next-buffer-same-mode ()
  (interactive)
  (buffer-same-mode #'next-buffer))

(global-set-key [H-tab] 'previous-buffer-same-mode)
(global-set-key [C-H-tab] 'next-buffer-same-mode)

#+end_src

*** Winner mode

#+begin_src emacs-lisp 

; a feature to preserve split pane configuration. Use 【Ctrl+c ←】 and 【Ctrl+c →】
(when (fboundp 'winner-mode) (winner-mode 1))

#+end_src

*** More Window functions

#+begin_src emacs-lisp 

;;----------------------------------------------------------------------------
;; When splitting window, show (other-buffer) in the new window
;;----------------------------------------------------------------------------
(defun split-window-func-with-other-buffer (split-function)
  (lexical-let ((s-f split-function))
    (lambda ()
      (interactive)
      (funcall s-f)
      (set-window-buffer (next-window) (other-buffer)))))

(global-set-key "\C-x2" (split-window-func-with-other-buffer 'split-window-vertically))
(global-set-key "\C-x3" (split-window-func-with-other-buffer 'split-window-horizontally))

;;----------------------------------------------------------------------------
;; Rearrange split windows
;;----------------------------------------------------------------------------
(defun split-window-horizontally-instead ()
  (interactive)
  (save-excursion
    (delete-other-windows)
    (funcall (split-window-func-with-other-buffer 'split-window-horizontally))))

(defun split-window-vertically-instead ()
  (interactive)
  (save-excursion
    (delete-other-windows)
    (funcall (split-window-func-with-other-buffer 'split-window-vertically))))

(global-set-key "\C-x|" 'split-window-horizontally-instead)
(global-set-key "\C-x_" 'split-window-vertically-instead)

#+end_src 

** Copy/Paste functionality

#+begin_src emacs-lisp 

;; have pasting work right in emacs 24
(setq x-select-enable-primary t)

#+end_src 

replace a region in emacs with yank buffer contents

#+begin_src emacs-lisp 

(delete-selection-mode t)

#+end_src 

In linux, if copy/paste doesn't work with other apps, you need to add
this line:

#+begin_src emacs-lisp 

(setq x-select-enable-clipboard t)

#+end_src 

*** Copy current file path

One of the drawbacks of integrating the GNU Emacs copy-and-paste
mechanism with X is that Emacs will grab the clipboard or selection
every time you do a kill. This becomes a problem over slow network
links (such as, for example, a DSL connection from home to work, and
from there to a remote datacenter). I wrote replacements for myself
that make clipboard operations explicit. This works with CVS GNU
Emacs. Note that this affects the clipboard, so it will work with
Firefox and “modern” X apps, but older X apps like xterm need to be
modified to use CLIPBOARD rather than the PRIMARY selection.


#+begin_src emacs-lisp :tangle no

  ;; Disable automatic cutting and pasting to the clipboard.
  ;; This causes noticeable delays over slow network links.
  ;; The function `insert-clipboard-contents' and the function
  ;; `set-clipboard-contents' let me do this explicitly.
  (setq interprogram-cut-function nil)
  (setq interprogram-paste-function nil)

  (defun get-clipboard-contents-as-string ()
    "Return the value of the clipboard contents as a string."
    (let ((x-select-enable-clipboard t))
      (or (x-cut-buffer-or-selection-value)
          x-last-selected-text-clipboard)))

  (defun insert-clipboard-contents ()
    "Insert the value of the current X selection at point.
  Uses the clipboard value if it is defined or not empty, otherwise
  falls back on the primary selection."
    (interactive)
    (let ((text (get-clipboard-contents-as-string)))
      (when text
        ;; This operation is very much like a yank, so set mark like
        ;; yank does.  Note that the "longlines" mode advice on this
        ;; function depends on mark having been set.
        (push-mark)
        (insert text))))

  (defun set-clipboard-contents-from-string (str)
    "Copy the value of string STR into the clipboard."
    (let ((x-select-enable-clipboard t))
      (x-select-text str)))

  (defun set-clipboard-contents (beg end)
    "Copy the value of the current region into the clipboard."
    (interactive "r")
    (set-clipboard-contents-from-string
     (buffer-substring-no-properties beg end))
    (setq deactivate-mark t))

  (defun set-clipboard-contents-delete (beg end)
    "Cut the value of the current region into the clipboard.
  The current region is deleted (without updating the kill ring)."
    (interactive "r")
    (set-clipboard-contents-from-string
     (buffer-substring-no-properties beg end))
    (delete-region beg end)
    (setq deactivate-mark t))

  (defun set-clipboard-contents-and-kill-ring-from-string (str)
    "Copy the value of string STR into the clipboard, and make it the latest kill."
    (set-clipboard-contents-from-string str)
    (kill-new str)
    (message "%s" str))

  (eval-after-load "longlines"
    '(progn
       (defadvice insert-clipboard-contents (after longlines-decode-kill activate)
         ;; Depends on insert-clipboard-contents having set mark at the
         ;; begging of the text.  If we have to stop doing that, we
         ;; should turn this into "around" advice that can capture point
         ;; before doing the insert.
         (when longlines-mode
           (longlines-decode-region (point) (mark t))
           (when longlines-showing
             (longlines-show-hard-newlines))))
       (defadvice set-clipboard-contents (around longlines-encode-kill activate)
         (if longlines-mode
             (let ((str (buffer-substring beg end)))
               (with-temp-buffer
                 (insert str)
                 (longlines-encode-region (point-min) (point-max))
                 (setq beg (point-min))
                 (setq end (point-max))
                 ad-do-it))
           ad-do-it))
       (defadvice set-clipboard-contents-delete (before longlines-encode-kill activate)
         (when longlines-mode
           (longlines-encode-region beg end)))))

  (defun path-to-clipboard ()
    "Copy the current file's path to the clipboard.

  If the current buffer has no file, copy the buffer's default directory."
    (interactive)
    (let ((path (expand-file-name (or (buffer-file-name) default-directory))))
      (set-clipboard-contents-from-string path)
      (message "%s" path)))

  (defun npath-to-clipboard ()
    "Copy the current file's path to the clipboard, with a network filename.
  The resulting value will have the correct syntax to use with SCP.

  If the current buffer has no file, copy the buffer's default directory."
    (interactive)
    (let* ((host (system-name))
           (path (expand-file-name (or (buffer-file-name) default-directory)))
           (network-path (concat host ":" path)))
      (set-clipboard-contents-from-string network-path)
      (message "%s" network-path)))

#+end_src

#+begin_src emacs-lisp 

(defun copy-buffer-file-name (use-backslashes)
  "Puts the file name of the current buffer (or the current directory,
if the buffer isn't visiting a file) onto the kill ring, so that it
can be retrieved with \\[yank], or by another program.  With argument,
uses backslashes instead of forward slashes."
  (interactive "P")
  (let ((fn (subst-char-in-string
             ?/
             (if use-backslashes ?\\ ?/)
             (or
              (buffer-file-name (current-buffer))
              ;; Perhaps the buffer isn't visiting a file at all.  In
              ;; that case, let's return the directory.
              (expand-file-name default-directory)))))
    (when (null fn)
      (error "Buffer doesn't appear to be associated with any file or 
directory."))
    (kill-new fn)
    (message "%s" fn)
    fn))

(global-set-key (kbd "H-f") 'copy-buffer-file-name)

#+end_src 


** Completion functionality
*** Ignore case in completion

#+begin_src emacs-lisp 

(setq completion-ignore-case t)

#+end_src 



*** Some files I don't want to see often

#+begin_src emacs-lisp 

(setq completion-ignored-extensions
      (append (list
                    ".bak"
                  ".old"
                  ".tar"
                  ".new"
                  ".tar.gz"
                  ".jeff"
                    )
              completion-ignored-extensions))

#+end_src 

*** Pc-Complete

#+begin_src emacs-lisp 

(defconst pcmpl-git-commands
  '("add" "bisect" "branch" "checkout" "clone"
    "commit" "diff" "fetch" "grep"
    "init" "log" "merge" "mv" "pull" "push" "rebase"
    "reset" "rm" "show" "status" "tag" )
  "List of `git' commands")
 
(defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
  "The `git' command to run to get a list of refs")
 
(defun pcmpl-git-get-refs (type)
  "Return a list of `git' refs filtered by TYPE"
  (with-temp-buffer
    (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
    (goto-char (point-min))
    (let ((ref-list))
      (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
        (add-to-list 'ref-list (match-string 1)))
      ref-list)))
 
(defun pcomplete/git ()
  "Completion for `git'"
  ;; Completion for the command argument.
  (pcomplete-here* pcmpl-git-commands)  
  ;; complete files/dirs forever if the command is `add' or `rm'
  (cond
   ((pcomplete-match (regexp-opt '("add" "rm")) 1)
    (while (pcomplete-here (pcomplete-entries))))
   ;; provide branch completion for the command `checkout'.
   ((pcomplete-match "checkout" 1)
    (pcomplete-here* (pcmpl-git-get-refs "heads")))))

#+end_src 

** Mode-line functionality
*** Show approx buffer size in modeline

#+begin_src emacs-lisp 

(size-indication-mode)

#+end_src 

*** Show buffer position in modeline

;; show buffer pos in the
;; use sml-modeline if available

#+begin_src emacs-lisp 

(if (require 'sml-modeline nil 'noerror)    
  (progn (sml-modeline-mode 1) mode line))

#+end_src

*** Diminish
[2011-10-04 Tue 13:47]Emacs' version on a status-bar is called the
mode-line, and contains all kind of information – the current buffer
name, the cursor position and a lot of other things, depending on what
major and minor modes are active.

Customizing the mode-line is, unfortunately, rather hard. One day,
I'll write something about that… but for now at least we may be able
to improve things a little bit, by reducing mode line pollution. Mode
line pollution? Well, many parts of emacs like to announce their
presence and state in the mode line. With the limited space available
there, this can become a bit of an issue, the (Lisp Interaction
company Yas abbrev) takes quite some space:
                                                  

But there are some ways to limit the space taken by modes and
minor-modes. Note, these snippets should go in your .emacs, and you
need to restart emacs to make them active.

First, the minor modes (note, you can see the currently activated ones
with C-h m); install the handy diminish.el (or get it using the
emacs-goodies-el package when using Debian/Ubuntu) and add something
like the following:

#+begin_src emacs-lisp 

(when (require 'diminish nil 'noerror)
  (eval-after-load "company"
      '(diminish 'company-mode "Cmp"))
  (eval-after-load "abbrev"
    '(diminish 'abbrev-mode "Ab"))
  (eval-after-load "yasnippet"
    '(diminish 'yas/minor-mode "Y")))

;; And the major-modes, for example for Emacs Lisp mode:

(add-hook 'emacs-lisp-mode-hook 
  (lambda()
    (setq mode-name "el")))

#+end_src 

** Mouse functionality
*** Make URLs in comments/strings clickable

#+begin_src emacs-lisp 

(add-hook 'find-file-hooks 'goto-address-prog-mode)

#+end_src 

** Color functionality
*** Color themes

**** Long live Solarized

#+begin_src emacs-lisp 

(require 'color-theme)
(require 'color-theme-solarized)
(load-theme 'solarized-dark t)
;;(setq solarized-termcolors "256")

#+end_src

*** Somewhere over the rainbow

#+begin_src emacs-lisp 

(require 'rainbow-mode)
(rainbow-mode t)
(setq rainbow-x-colors t)
(require 'rainbow-delimiters)

(when (require 'rainbow-delimiters nil 'noerror)
  (progn
    (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode))
    (add-hook 'js2-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'c-mode-common-hook 'rainbow-delimiters-mode)
    (add-hook 'php-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))

#+end_src

*** Sort list-colors-display by Hue

Perm URL with updates: http://xahlee.org/emacs/emacs24_features.html

You can call list-colors-display to list colors and their RGB hex
values. But the result is not sorted. Now, you can sort it by
hue. Much better. Put this in your emacs init file:

#+begin_src emacs-lisp 

(setq list-colors-sort 'hsv )

#+end_src 

** Point, Search Rectangle & Region functionality
*** Store and restore point

When two windows view the same buffer at the same time, and one
window is switched to another buffer and back, point is now the
same as in the other window, not as it was before we switched away.
This mode tries to work around this problem by storing and
restoring per-window positions for each buffer.

#+begin_src emacs-lisp 

(require 'winpoint)
(window-point-remember-mode 1)

#+end_src 

*** I like returning to the same place

Purpose: When you visit a file, point goes to the last place where
  it was when you previously visited the same file.
  
To use it, turn it on in the options menu - “Save place in files
between Sessions”

#+begin_src emacs-lisp 

(require 'saveplace)                          ;; get the package

#+end_src 

*** Goto last change - this is bodacious 

#+begin_src emacs-lisp 

(when (require 'goto-last-change nil 'noerror)
  (global-set-key (kbd "C-x C-/") 'goto-last-change))

#+end_src 

*** Expand Region

#+begin_src emacs-lisp 

(add-to-list 'load-path "~/.emacs.d/src/expand-region.el")
(require 'expand-region)
(global-set-key (kbd "H-SPC") 'er/expand-region)

(defun er/add-text-mode-expansions ()
  (make-variable-buffer-local 'er/try-expand-list)
  (setq er/try-expand-list (append
                            er/try-expand-list
                            '(mark-paragraph
                              mark-page))))

(add-hook 'text-mode-hook 'er/add-text-mode-expansions)

#+end_src 

*** Get Selection or unit under Point

#+begin_src emacs-lisp 

(defun get-selection-or-unit  (unit)
  "Return the string and boundary of text selection or UNIT under cursor.

If `region-active-p' is true, then the region is the unit. Else,
it depends on the UNIT. See `unit-at-cursor' for detail about
UNIT.

Returns a vector [text a b], where text is the string and a and b
are its boundary."
  (interactive)

  (let (mytext p1 p2)
    (if (region-active-p)
        (progn
          (setq p1 (region-beginning))
          (setq p2 (region-end))
          (setq mytext (buffer-substring p1 p2) )
          (vector (buffer-substring-no-properties p1 p2) p1 p2 )
          )
      (unit-at-cursor unit)
 ) ) )

(defun unit-at-cursor  (unit)
  "Return the string and boundary of UNIT under cursor.

Returns a vector [text a b], where text is the string and a and b are its boundary.

UNIT can be:
• 'word — sequence of 0 to 9, A to Z, a to z, and hyphen.
• 'glyphs — sequence of visible glyphs. Useful for file name, url, …, that doesn't have spaces in it.
• 'line — delimited by “\\n”.
• 'block — delimited by “\\n\\n” or beginning/end of buffer.
• 'buffer — whole buffer. (respects `narrow-to-region')
• a vector [beginRegex endRegex] — The elements are regex strings used to determine the beginning/end of boundary chars. They are passed to `skip-chars-backward' and `skip-chars-forward'. For example, if you want paren as delimiter, use [\"^(\" \"^)\"]

Example usage:
    (setq bds (unit-at-cursor 'line))
    (setq myText (elt bds 0) p1 (elt bds 1) p2 (elt bds 2)  )

This function is similar to `thing-at-point' and `bounds-of-thing-at-point'.
The main differences are:
• this function returns the text and the 2 boundaries as a vector in one shot.
• 'line always returns the line without end of line character, avoiding inconsistency when the line is at end of buffer.
• 'word does not depend on syntax table.
• 'block does not depend on syntax table."
  (let (p1 p2)
    (save-excursion
        (cond
         ( (eq unit 'word)
           (let ((wordcharset "-A-Za-zÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ"))
             (skip-chars-backward wordcharset)
             (setq p1 (point))
             (skip-chars-forward wordcharset)
             (setq p2 (point)))
           )

         ( (eq unit 'glyphs)
           (progn
             (skip-chars-backward "[:graph:]")
             (setq p1 (point))
             (skip-chars-forward "[:graph:]")
             (setq p2 (point)))
           )

         ( (eq unit 'buffer)
           (progn
             (setq p1 (point-min))
             (setq p2 (point-max))
             )
           )

         ((eq unit 'line)
          (progn
            (setq p1 (line-beginning-position))
            (setq p2 (line-end-position))))
         ((eq unit 'block)
          (progn
            (if (re-search-backward "\n\n" nil t)
                (progn (forward-char 2)
                       (setq p1 (point) ) )
              (setq p1 (line-beginning-position) )
              )

            (if (re-search-forward "\n\n" nil t)
                (progn (backward-char)
                       (setq p2 (point) ))
              (setq p2 (line-end-position) ) ) ))

         ((vectorp unit)
          (let (p0)
             (setq p0 (point))
             (skip-chars-backward (elt unit 0))
             (setq p1 (point))
             (goto-char p0)
             (skip-chars-forward (elt unit 1))
             (setq p2 (point))))
         ) )

    (vector (buffer-substring-no-properties p1 p2) p1 p2 )
    ) )

(defun region-or-thing (thing)
  "Return a vector containing the region and its bounds if there is one
or the thing at the point and its bounds if there is no region"
  (if (use-region-p)
      (vector (buffer-substring-no-properties (region-beginning) (region-end))
              (region-beginning) (region-end))
    (let* ((bounds (bounds-of-thing-at-point thing))
           (beg (car bounds))
           (end (cdr bounds)))
      (vector (buffer-substring-no-properties beg end) beg end))))

(defun google-search ()
  "Do a Google search of the region or symbol at the point"
  (interactive)
  (let ((phrase (elt (region-or-thing 'symbol) 0)))
    (browse-url (concat "http://www.google.com/search?q="
                        (replace-regexp-in-string " " "+" phrase)))))


#+end_src 

*** Sacha Chua search word functions

#+begin_src emacs-lisp 

(defun sacha/search-word-backward ()
  "Find the previous occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-backward "w_")
    (goto-char
     (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
         (match-beginning 0)
       cur))))

(defun sacha/search-word-forward ()
  "Find the next occurrence of the current word."
  (interactive)
  (let ((cur (point)))
    (skip-syntax-forward "w_")
    (goto-char
     (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
         (match-beginning 0)
       cur))))

(global-set-key (kbd "C-H-r") 'sacha/search-word-backward)
(global-set-key (kbd "C-H-s") 'sacha/search-word-forward)
(defadvice search-for-keyword (around sacha activate)
  "Match in a case-insensitive way."
  (let ((case-fold-search t))
    ad-do-it))

#+end_src 

*** Thing at point functions

#+begin_src emacs-lisp 

(defun ash-forward-string (&optional arg)
  "Move forward to ARGth string."
  (setq arg (or arg 1))
  (if (not (bobp))
      (save-match-data
        (when (or (and (looking-at-p "\\s-*\"")
                       (not (looking-back "\\\\")))
                  (re-search-backward "[^\\\\]\"" nil nil))
          (looking-at "\\s-*\"")
          (goto-char (match-end 0))
          (forward-char -1))))
  (while (and (> arg 0)
              (not (eobp))
              (looking-at-p "\\s-*\""))
    (forward-sexp 1)
    (setq arg (1- arg)))
  (while (and (< arg 0)
              (not (bobp))
              (looking-at-p "\""))
    (forward-sexp -1)
    (setq arg (1+ arg)))
  (ignore))

(put 'string 'forward-op 'ash-forward-string)

(defun ash-kill-string (&optional arg) 
  "Kill ARG strings under point."
  (interactive "*p")
  (setq arg (or (and (not (zerop arg)) arg) 1))
  (if (> arg 0)
      (kill-region
       (progn (forward-thing 'string 0) (point))
       (progn (forward-thing 'string arg) (point)))
    (kill-region
     (progn (forward-thing 'string 1) (point))
     (progn (forward-thing 'string arg) (point)))))

#+end_src 

*** Translate word at point function

#+begin_src emacs-lisp 

(defun translate ()
  "Translate the word at point using WordReference."
  (interactive)
  (browse-url (concat "http://www.wordreference.com/fren/" 
              (thing-at-point 'word)))
)

#+end_src 

*** Thing at point
**** Answers.com

#+begin_src emacs-lisp 
(defun answers-define ()
  "Look up the word under cursor in a browser."
  (interactive)
  (browse-url
   (concat "http://www.answers.com/main/ntquery?s="
           (thing-at-point 'word))))

#+end_src 

*** Replace region function

#+begin_src emacs-lisp 

(defun my-replace-region ()
  (interactive)
  (unless (use-region-p)
    (error "no region"))
  (let ((what (buffer-substring-no-properties
               (region-beginning) (region-end)))
        (replacement (read-string "replace with: ")))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward what nil t)
        (replace-match replacement)))))

#+end_src 

*** Rectangles
**** Kill save rectangle function

#+begin_src emacs-lisp 

(defun kill-save-rectangle (start end &optional fill)       
  "Save the rectangle as if killed, but don't kill it.  See 
`kill-rectangle' for more information."                     
  (interactive "r\nP")                                      
  (kill-rectangle start end fill)                           
  (goto-char start)                                         
  (yank-rectangle))

(global-set-key (kbd "C-x r M-k") 'kill-save-rectangle)

#+end_src 

** Confirm exiting emacs

#+begin_src emacs-lisp 

(defun confirm-exit-emacs ()
        "ask for confirmation before exiting emacs"
        (interactive)
        (if (yes-or-no-p "Are you sure you want to exit? ")
                (save-buffers-kill-emacs)))

(global-unset-key "\C-x\C-c")
(global-set-key "\C-x\C-c" 'confirm-exit-emacs)

#+end_src 

** Autorevert

whenever an external process changes a file underneath emacs, and
there was no unsaved changes in the corresponding buffer, just revert
its content to reflect what's on-disk.

#+begin_src emacs-lisp 

(global-auto-revert-mode 1)

#+end_src 
** Abbrevs

I like abbrev cause it saves typing

#+begin_src emacs-lisp 

(setq abbrev-file-name "~/git/.emacs.d/.abbrev_defs")
(read-abbrev-file abbrev-file-name t)
(setq dabbrev-case-replace nil)  ; Preserve case when expanding
(setq abbrev-mode t)
(setq-default abbrev-mode t)

#+end_src 

** Saving history

#+begin_src emacs-lisp 

(require 'savehist-20+)
(savehist-mode 1)

#+end_src 

** Bell

#+begin_src emacs-lisp 

;; provided by snogglethorpe
(defcustom mode-line-bell-string "ding" ;"â™ª"
  "Message displayed in mode-line by `mode-line-bell' function."
  :group 'user)
(defcustom mode-line-bell-delay 1.0
  "Number of seconds `mode-line-bell' displays its message."
  :group 'user)

;; internal variables
(defvar mode-line-bell-cached-string nil)
(defvar mode-line-bell-propertized-string nil)

(defun mode-line-bell ()
  "Briefly display a highlighted message in the mode-line.

  The string displayed is the value of `mode-line-bell-string',
  with a red background; the background highlighting extends to the
  right margin.  The string is displayed for `mode-line-bell-delay'
  seconds.

  This function is intended to be used as a value of `ring-bell-function'."

  (unless (equal mode-line-bell-string mode-line-bell-cached-string)
    (setq mode-line-bell-propertized-string
          (propertize
           (concat
            (propertize
             "x"
             'display
             `(space :align-to (- right ,(string-width mode-line-bell-string))))
            mode-line-bell-string)
           'face '(:background "red")))
    (setq mode-line-bell-cached-string mode-line-bell-string))
  (message mode-line-bell-propertized-string)
  (sit-for mode-line-bell-delay)
  (message ""))

(setq ring-bell-function 'mode-line-bell)

#+end_src 

** auto byte-compile elisp files

If you code elisp, it's nice to have the elisp file automatically byte-compiled everytime you save it. Put the following in your emacs init file:

;; auto compile elisp files after save

#+begin_src emacs-lisp 

(add-hook 'emacs-lisp-mode-hook (lambda () (add-hook 'after-save-hook 'emacs-lisp-byte-compile t t)) )

#+end_src 

** Make script files executable automatically

You can force Emacs to make a file executable (respecting your umask
settings) if Emacs considers it a script. To determine if it is a
script, Emacs will look for the hash-bang notation in the file and
treat it as a script if it finds it.

Add this to your .emacs and Emacs will then make the file executable
if it is a script.

#+begin_src emacs-lisp 

(add-hook 'after-save-hook
  'executable-make-buffer-file-executable-if-script-p)

#+end_src 

** Cyberpunk Cursor

#+begin_src emacs-lisp 

(blink-cursor-mode 1)

(defvar blink-cursor-colors (list  "#92c48f" "#6785c5" "#be369c" "#d9ca65")
  "On each blink the cursor will cycle to the next color in this list.")

(setq blink-cursor-count 0)

(defun blink-cursor-timer-function ()
  "Cyberpunk variant of timer `blink-cursor-timer'. OVERWRITES original version in `frame.el'.

This one changes the cursor color on each blink. Define colors in `blink-cursor-colors'."
  (when (not (internal-show-cursor-p))
    (when (>= blink-cursor-count (length blink-cursor-colors))
      (setq blink-cursor-count 0))
    (set-cursor-color (nth blink-cursor-count blink-cursor-colors))
    (setq blink-cursor-count (+ 1 blink-cursor-count))
    )
  (internal-show-cursor nil (not (internal-show-cursor-p)))
  )

#+end_src 

** CUA

#+begin_src emacs-lisp 

(cua-selection-mode t)

(global-set-key "\M-[" 'cua-set-rectangle-mark)

#+end_src

** Fill column

#+begin_src emacs-lisp 

(require 'fill-column-indicator)

(setq fci-rule-width 1)
(setq fci-rule-color "darkblue")

(define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode 1)))
(global-fci-mode 1)

#+end_src 

** KeyChords

#+begin_src emacs-lisp 

(require 'key-chord)
(key-chord-mode 1)

(key-chord-define-global "''"     "`'\C-b")
(key-chord-define-global ",,"     'indent-for-comment)
(key-chord-define-global "qq"     "the ")
(key-chord-define-global "QQ"     "The ")
(key-chord-define-global ",."     'append-next-kill)
(key-chord-define-global "4r"     "$")
(key-chord-define-global "jk" 'goto-line)
(key-chord-define-global "df"     'bookmark-jump)
(key-chord-define-global "sd"     'er/expand-region)
(key-chord-define-global "kl"     'dabbrev-expand)
(key-chord-define-global "AS" 'my-swap-windows)
(key-chord-define-global "SD" 'my-toggle-window-split)
(key-chord-define-global "DF" 'toggle-windows-split)
(key-chord-define-global "FG" 'split-window-switch-buffer)
(key-chord-define-global "GH" 'hsplit-window-switch-buffer)
(key-chord-define-global "JK" 'rotate-windows)
(key-chord-define-global "KL" 'swap-buffers-in-windows)
(key-chord-define-global "L:" 'transpose-windows)

#+end_src

** Line numbers

#+begin_src emacs-lisp 

(setq linum-mode-inhibit-modes-list '(eshell-mode                                                 
                                      shell-mode                                                  
                                      erc-mode                                                    
                                      jabber-roster-mode                                          
                                      jabber-chat-mode                                            
                                      gnus-group-mode                                             
                                      gnus-summary-mode                                           
                                      gnus-article-mode))                                         
                                                                                                  
(defadvice linum-on (around linum-on-inhibit-for-modes)                                           
  "Stop the load of linum-mode for some major modes."                                             
    (unless (member major-mode linum-mode-inhibit-modes-list)                                     
      ad-do-it))                                                                                  
                                                                                                  
(ad-activate 'linum-on)

#+end_src 

** Rotate text

#+begin_src emacs-lisp 

(require 'rotate-text)
(autoload 'rotate-text "rotate-text" nil t)
(autoload 'rotate-text-backward "rotate-text" nil t)

#+end_src

** artbollocks

#+begin_src emacs-lisp 

(if (require 'artbollocks-mode nil t)
    (progn
      (setq weasel-words-regex
            (concat "\\b" (regexp-opt
                           '("one of the"
                             "should"
                             "just"
                             "sort of"
                             "a lot"
                             "probably"
                             "maybe"
                             "perhaps"
                             "I think"
                             "really"
                             "pretty"
                             "maybe"
                             "nice"
                             "action"
                             "utilize"
                             "leverage") t) "\\b"))
      ;; Fix a bug in the regular expression to catch repeated words
      (setq lexical-illusions-regex "\\b\\(\\w+\\)\\W+\\(\\1\\)\\b")
      ;; Don't show the art critic words, or at least until I figure
      ;; out my own jargon
      (setq artbollocks nil)
      (add-hook 'org-capture-mode-hook 'artbollocks-mode)

      ))

#+end_src 

** miniedit

#+begin_src emacs-lisp 

(if (require 'miniedit nil t)
    (miniedit-install))

#+end_src 

** Auto-indent mode

#+begin_src emacs-lisp 

(require 'auto-indent-mode)

#+end_src

** Kill Ring
*** Kill Ring

#+begin_src emacs-lisp 

(require 'browse-kill-ring)

;;(when (require 'browse-kill-ring nil 'noerror)
;;  (browse-kill-ring-default-keybindings))

(global-set-key (kbd "C-M-y") '(lambda ()
   (interactive)
   (popup-menu 'yank-menu)))

(require 'second-sel)
(require 'browse-kill-ring+)

#+end_src 

*** Undo-tree

#+begin_src emacs-lisp 

(require 'undo-tree)
(global-undo-tree-mode 1)

(defalias 'redo 'undo-tree-redo)

(global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
(global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】

#+end_src

*** Kill ring hook

#+begin_src emacs-lisp 

(add-hook 'before-revert-hook  (lambda () (kill-ring-save (point-min) (point-max))))

#+end_src 

* Org (Organize your life)
** Org Agenda

;; The following setting is different from the document so that you
;; can override the document org-agenda-files by setting your
;; org-agenda-files in the variable org-user-agenda-files

#+begin_src emacs-lisp 

(setq org-user-agenda-files (quote (
"~/git/cu"
"~/git/cu/igp"
"~/git/cu/centers"
"~/git/dkh-org"
"~/git/dkh-org/wordpress"
"~/git/netlsd"
)))

#+end_src 

** Diary location

#+begin_src emacs-lisp 

(setq diary-file "~/git/.emacs.d/.diary")

#+end_src 

** Org modules I like

#+begin_src emacs-lisp 

(require 'org-habit) ;; added by dkh

#+end_src 

** Org Latex

#+begin_src emacs-lisp

(require 'org-latex)
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")))

(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
             `("book"
               "\\documentclass{book}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
             )

(add-to-list 'org-export-latex-classes
      '("org-article"
         "\\documentclass{org-article}
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}" . "\\paragraph*{%s}")
         ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
          '("koma-article"
             "\\documentclass{scrartcl}
             [NO-DEFAULT-PACKAGES]
             [EXTRA]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(setq org-export-latex-listings 'minted)
(setq org-export-latex-custom-lang-environments
      '(
       (emacs-lisp "common-lispcode")
        ))
(setq org-export-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")))
(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-export-latex-listings 'listings)
(setq org-export-latex-custom-lang-environments
      '((emacs-lisp "common-lispcode")))
(setq org-export-latex-listings-options
      '(("frame" "lines")
        ("basicstyle" "\\footnotesize")
        ("numbers" "left")
        ("numberstyle" "\\tiny")))
(setq org-latex-to-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"))
(org-add-link-type
 "latex" nil
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span class=\"%s\">%s</span>" path desc))
    ((eq format 'latex)
     (format "\\%s{%s}" path desc)))))

#+end_src 

** org subtree cut function
#+begin_src emacs-lisp 

(define-key org-mode-map (kbd "C-c k") 'org-cut-subtree)

(setq org-export-with-section-numbers nil)
(setq org-html-include-timestamps nil)

(defun sacha/org-export-subtree-as-html-fragment ()
  (interactive)
  (org-export-region-as-html
   (org-back-to-heading)
   (org-end-of-subtree)
   t))

(setq org-link-abbrev-alist
  '(("google" . "http://www.google.com/search?q=")
    ("gmap" . "http://maps.google.com/maps?q=%s")
    ("blog" . "http://sachachua.com/blog/p/")))

#+end_src

** org-bable
#+begin_src emacs-lisp 

(org-babel-do-load-languages
    'org-babel-load-languages '((python . t) (R . t) (perl . t)))

#+end_src 


   
* Navigation (Driving the car)
** Ibuffer

#+begin_src emacs-lisp 

(setq ibuffer-saved-filter-groups
      (quote
       (("default"
         ("ssh"
          (or
           (name . "\\*tramp") 
           (name . "^\\*debug tramp")
           ))

         ("emacs"
          (or
           (mode . occur-mode)
           (mode . bookmark-bmenu-mode)
           (mode . help-mode)
           (name . "^\\*scratch\\*$")
           (name . "^\\*Messages\\*$")

           (name . "^\\*Compile-Log\\*$")
           (name . "^\\*Backtrace\\*$")
           (name . "^\\*info\\*$")
           (name . "^\\*Occur\\*$")
           (name . "^\\*grep\\*$")
           (name . "^\\*Process List\\*$")
           (name . "^\\*gud\\*$")
           (name . "^\\*compilation\\*$")
           (name . "^\\*Kill Ring\\*$")
           ))
         ("agenda" (or (name . "^\\*Calendar\\*$")
                       (name . "^\\*Org Agenda")
                       (name . "^\\*scratch\\* (org)$")
                       (filename . "git\\/dkh\-org")
                       (mode . muse-mode)
                       ))
         ("blog" (or 
                       (filename . "git\\/blog")
                       (filename . "git\\/netlsd")
                       ))

         ("cu agenda" (or (filename . "git\\/cu")))
         ("latex" (or (mode . latex-mode)
                      (mode . LaTeX-mode)
                      (mode . bibtex-mode)
                      (mode . reftex-mode)))
         ("irc"
          (or
           (name . "^\\*Sauron\\*$")
           (mode . garak-mode)
           (name . "^\\*Garak\\*$")
           (mode . erc-mode)
           (mode . twittering-mode)
  (name . "^\\*scratch\\* (irc)$")
         ))
         ("jabber"
          (or
          (name . "^\\*-jabber.*")
           (name . "\\*fsm-debug\\*")
          (name . "^\\*scratch\\* (jabber)$")
        ))
         ("test"
          (or
           (name . "test")
           (filename . "user\\@localhost:/home/www/htdocs")
           ))
         ("devel"
          (or
           (name . "^\\*eshell\\-devel\\-drupal\\*$")
           (name . "devel")
           (filename . "localhost:/home/www")
           (filename . "localhost:/home/user")
           ))

         ("stage"
          (or
           (name . "stage")
           (name . "staging")
           (filename . "host-staging.domain.com")
           (name . "\\*ansi\\-term\\-stage\\*")
           ))
         ("prod"
          (or
           (name . "prod")
           (filename . "host-prod.domain.com")
           ))
         ("IGP Project Trunk"
          (filename . "igp_reporting_trunk"))
         ("competitions" (or
                          (filename . "competitions")
                          (filename . "apache2\/competitions")
                          ))
         ("templates"
          (filename . "templates_trunk"))
         ("gnus" (or
                  (mode . message-mode)
                  (mode . bbdb-mode)
                  (mode . mail-mode)
                  (mode . gnus-group-mode)
                  (mode . gnus-summary-mode)
                  (mode . gnus-article-mode)
                  (name . "^\\.bbdb$")
                  (name . "^\\.newsrc-dribble")
                  (name . "^\\*gnus trace\\*$")
                  (name . "^\\*scratch\\* (gnus)$")
                  ))
         ("tool config" (or (mode . emacs-lisp-mode)
                            (filename . "\\.emacs\\.d")
                            (filename . "git\\/vinylisland")
                            (name . "^\\.conkerorrc$")
                            (filename . "org-mode-doc")
                            ))

         ("w3m" (or
                 (mode . w3m-mode)
               ;;  (name . "\\(w3m\\)$")
                  (name . "w3m")
                 ))
         ("documentation" (or (mode . Info-mode)
                              (mode . apropos-mode)
                              (mode . woman-mode)
                              (mode . help-mode)
                              (mode . Man-mode)))
         ("Magit" (name . "\*magit"))
         ))))

(setq ibuffer-never-show-predicates
      (list
       ;; Gnus development version
       "^\\*Completions\\*$"
       "^\\*nnimap"
       "^\\*gnus trace"
       "^\\*imap log"
       ;; Elim
       "^\\*elim"
       ;; others
       "^\\*Completions\\*$"
       "^\\*BBDB\\*$"
       "^\\.bbdb$"
       "^\\.newsrc-dribble$"
       ;;       "^\\*magit-"        ;; magit stuff
       "^\\*fsm-debug"     ;; jabber
       "\\.org_archive$"   ;; orgmode archive files
       "^\\*jekyll-aa\\*$" ;; local jekyll server
       "\\.diary$"
       "^mumamo-fetch-major-mode-setup-php-mode$"
       ))

                                        ; default groups for ibuffer
;; http://www.shellarchive.co.uk/content/emacs_tips.html#sec17


;; ibuffer, I like my buffers to be grouped
(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups
             "default")))

(setq ibuffer-never-show-predicates
      (list "\\*Completions\\*"
            "\\*vc\\*"))

;; Switching to ibuffer puts the cursor on the most recent buffer
(defadvice ibuffer (around ibuffer-point-to-most-recent) ()
  "Open ibuffer with cursor pointed to most recent buffer name"
  (let ((recent-buffer-name (buffer-name)))
    ad-do-it
    (ibuffer-jump-to-buffer recent-buffer-name)))
(ad-activate 'ibuffer)

(setq ibuffer-show-empty-filter-groups nil)

(defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups ()
                                                 activate)
  (setq ad-return-value (nreverse ad-return-value)))

(setq ibuffer-restore-window-config-on-quit t)

;; Enable ibuffer-filter-by-filename to filter on directory names too.
(eval-after-load "ibuf-ext"
  '(define-ibuffer-filter filename
     "Toggle current view to buffers with file or directory name matching QUALIFIER."
     (:description "filename"
      :reader (read-from-minibuffer "Filter by file/directory name (regexp): "))
     (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                        (buffer-local-value 'dired-directory buf))
       (string-match qualifier it))))

#+end_src 

** Iswitchb

#+begin_src emacs-lisp :tangle no

;; iswitchb ignores
;;============================================================
(add-to-list 'iswitchb-buffer-ignore "^ ")
(add-to-list 'iswitchb-buffer-ignore "*Messages*")
(add-to-list 'iswitchb-buffer-ignore "*ECB")
(add-to-list 'iswitchb-buffer-ignore "*Buffer")
(add-to-list 'iswitchb-buffer-ignore "*Completions")
(add-to-list 'iswitchb-buffer-ignore "*ftp ")
(add-to-list 'iswitchb-buffer-ignore "*bsh")
(add-to-list 'iswitchb-buffer-ignore "*jde-log")
(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")

#+end_src 

** Perspective

#+begin_src emacs-lisp 

(define-prefix-command 'perspective-map)
(global-set-key (kbd "C-8") 'perspective-map)

#+end_src 

** IDO

#+begin_src emacs-lisp 

;; ido makes competing buffers and finding files easier
;; http://www.emacswiki.org/cgi-bin/wiki/InteractivelyDoThings

(setq 
  ido-save-directory-list-file "~/.emacs.d/ido.last"
)

(set `ido-ignore-files '("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./"
"\\`\\./" "\\.el?$"))

(setq ido-ignore-buffers 
  '("\\` " "^\*Mess" "^\*Back" ".*Completions" "^\*Ido" "^\*trace"
     "^\*compilation" "^\*GTAGS" "^session\.*" "^\*" "^\\*Completions\\*$"))

(setq  ido-work-directory-list '("~/git" "~/.emacs.d" "~/docs" ))



(setq  ido-case-fold  t                 ; be case-insensitive
  ido-enable-last-directory-history t ; remember last used dirs
  ido-max-work-directory-list 30   ; should be enough
  ido-max-work-file-list      50   ; remember many
)

(setq ido-use-filename-at-point 'guess)

(setq ido-use-url-at-point nil)         ; don't use url at point (annoying)

(setq ido-enable-flex-matching t)   ; don't try to be too smart

(setq ido-max-prospects 8)              ; don't spam my minibuffer

(setq  ido-confirm-unique-completion t) ; wait for RET, even with unique completion

;; when using ido, the confirmation is rather annoying...
(setq confirm-nonexistent-file-or-buffer nil)

                                          ; 50 files ought to be enough.
  (setq recentf-max-saved-items 50)
  
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
  
                                          ; IDO switch between irc channels.

;; get rid of `find-file-read-only' and replace it with something
  ;; more useful.
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

(setq ido-create-new-buffer 'always)

(setq ido-file-extensions-order '(".org" ".php" ".txt" ".py" ".xml" ".el" ".ini" ".cfg" ".cnf"))

(defun rgr/ido-erc-buffer()
(interactive)
(switch-to-buffer
 (ido-completing-read "Channel:" 
                      (save-excursion
                        (delq
                         nil
                         (mapcar (lambda (buf)
                                   (when (buffer-live-p buf)
                                     (with-current-buffer buf
                                       (and (eq major-mode 'erc-mode)
                                            (buffer-name buf)))))
                                 (buffer-list)))))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(lambda (x) (and (string-match-p "^\\.." x) x))

(lambda (a b)
      (let ((a-tramp-file-p (string-match-p ":\\'" a))
            (b-tramp-file-p (string-match-p ":\\'" b)))
        (cond
         ((and a-tramp-file-p b-tramp-file-p)
          (string< a b))
         (a-tramp-file-p nil)
         (b-tramp-file-p t)
         (t (time-less-p
             (sixth (file-attributes (concat ido-current-directory b)))
             (sixth (file-attributes (concat ido-current-directory a))))))))

(setq ido-enable-tramp-completion nil)

(setq ido-use-virtual-buffers 't)

(add-to-list 'ido-work-directory-list-ignore-regexps tramp-file-name-regexp)

(setq ido-default-buffer-method 'selected-window)

(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
    (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)

(defun ido-sort-mtime ()
      (setq ido-temp-list
            (sort ido-temp-list 
                  (lambda (a b)
                    (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                          (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                      (if (= (nth 0 ta) (nth 0 tb))
                          (> (nth 1 ta) (nth 1 tb))
                        (> (nth 0 ta) (nth 0 tb)))))))
      (ido-to-end  ;; move . files to end (again)
       (delq nil (mapcar
                  (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                  ido-temp-list))))

#+end_src                   

** Find file as root function(s)

#+begin_src emacs-lisp 

(defun find-file-as-root ()
  "Find a file as root."
  (interactive)
  (let* ((parsed (when (tramp-tramp-file-p default-directory)
                   (coerce (tramp-dissect-file-name default-directory)
                           'list)))
         (default-directory
           (if parsed
               (apply 'tramp-make-tramp-file-name
                      (append '("sudo" "root") (cddr parsed)))
             (tramp-make-tramp-file-name "sudo" "root" "localhost"
                                         default-directory))))
    (call-interactively 'find-file)))

(defun toggle-alternate-file-as-root (&optional filename)
  "Toggle between the current file as the default user and as root."
  (interactive)
  (let* ((filename (or filename (buffer-file-name)))
         (parsed (when (tramp-tramp-file-p filename)
                   (coerce (tramp-dissect-file-name filename)
                           'list))))
    (unless filename
      (error "No file in this buffer."))

    (find-alternate-file
     (if (equal '("sudo" "root") (butlast parsed 2))
         ;; As non-root
         (if (or
              (string= "localhost" (nth 2 parsed))
              (string= (system-name) (nth 2 parsed)))
             (car (last parsed))
           (apply 'tramp-make-tramp-file-name
                  (append (list tramp-default-method nil) (cddr parsed))))

       ;; As root
       (if parsed
           (apply 'tramp-make-tramp-file-name
                  (append '("sudo" "root") (cddr parsed)))
         (tramp-make-tramp-file-name "sudo" nil nil filename))))))

(defun th-find-file-sudo (file)
  "Opens FILE with root privileges."
  (interactive "F")
  (set-buffer (find-file (concat "/sudo::" file))))

(defadvice find-file (around th-find-file activate)
  "Open FILENAME using tramp's sudo method if it's read-only."
  (if (and (not (file-writable-p (ad-get-arg 0)))
       (not (file-remote-p (ad-get-arg 0)))
       (y-or-n-p (concat "File "
                 (ad-get-arg 0)
                 " is read-only.  Open it as root? ")))
      (th-find-file-sudo (ad-get-arg 0))
    ad-do-it))

#+end_src 

** filecache

#+begin_src emacs-lisp 

(require 'filecache)

(defun file-cache-ido-find-file (file)
  "Using ido, interactively open file from file cache'.
First select a file, matched using ido-switch-buffer against the contents
in `file-cache-alist'. If the file exist in more than one
directory, select directory. Lastly the file is opened."
  (interactive (list (file-cache-ido-read "File: "
                                          (mapcar
                                           (lambda (x)
                                             (car x))
                                           file-cache-alist))))
  (let* ((record (assoc file file-cache-alist)))
    (find-file
     (expand-file-name
      file
      (if (= (length record) 2)
          (car (cdr record))
        (file-cache-ido-read
         (format "Find %s in dir: " file) (cdr record)))))))

(defun file-cache-ido-read (prompt choices)
  (let ((ido-make-buffer-list-hook
         (lambda ()
           (setq ido-temp-list choices))))
    (ido-read-buffer prompt)))
(add-to-list 'file-cache-filter-regexps "docs/html")
(add-to-list 'file-cache-filter-regexps "\\.svn-base$")
(add-to-list 'file-cache-filter-regexps "\\.dump$")

#+end_src 

** Imenu

#+begin_src emacs-lisp 

(setq imenu-auto-rescan 't)

#+end_src 

** Smex
smex-save-file is a variable defined in `smex.el'.

#+begin_src emacs-lisp 

(setq smex-save-file "~/.emacs.d/.smex-items")

#+end_src 

** Registers

#+TITLE: Starter Kit Registers
#+OPTIONS: toc:nil num:nil ^:nil

*** Starter Kit Registers
Registers allow you to jump to a file or other location quickly. Use
=C-x r j= followed by the letter of the register (i for =init.el=, s
for this file) to jump to it.

You should add registers here for the files you edit most often.

#+srcname: starter-kit-registers

Documentation:
Alist of elements (NAME . CONTENTS), one for each Emacs register.
NAME is a character (a number).  CONTENTS is a string, number, marker, list
or a struct returned by `registerv-make'.
A list of strings represents a rectangle.
A list of the form (file . FILE-NAME) represents the file named FILE-NAME.
A list of the form (file-query FILE-NAME POSITION) represents
 position POSITION in the file named FILE-NAME, but query before
 visiting it.
A list of the form (WINDOW-CONFIGURATION POSITION)
 represents a saved window configuration plus a saved value of point.
A list of the form (FRAME-CONFIGURATION POSITION)
 represents a saved frame configuration plus a saved value of point.
;; (cond ((file-exists-p (expand-file-name "~/work/rldev")

#+begin_src emacs-lisp 

(dolist (r `( (?e (file . "~/git/ewax/dkh-core.org"))))
             (set-register (car r) (cadr r)))

#+end_src 

** Bookmarks
*** Bookmark locations

#+begin_src emacs-lisp 

(setq bookmark-default-file "~/git/.emacs.d/.emacs.bmk")

(setq bmkp-last-as-first-bookmark-file "~/git/.emacs.d/.emacs.bmk")

#+end_src 

*** Persistent bookmarks

#+begin_src emacs-lisp :tangle no

(setq bm-repository-file "~/git/.emacs.d/.bm-repository")
(setq bm-restore-repository-on-load t)
(require 'bm)

(global-set-key (kbd "<M-f6>") 'bm-toggle)
(global-set-key (kbd "<H-f6>")   'bm-next)
(global-set-key (kbd "<S-f6>") 'bm-previous)
 
;; make bookmarks persistent as default
(setq-default bm-buffer-persistence t)
 
;; Loading the repository from file when on start up.
(add-hook' after-init-hook 'bm-repository-load)
 
;; Restoring bookmarks when on file find.
(add-hook 'find-file-hooks 'bm-buffer-restore)
 
;; Saving bookmark data on killing a buffer
(add-hook 'kill-buffer-hook 'bm-buffer-save)
 
;; Saving the repository to file when on exit.
;; kill-buffer-hook is not called when emacs is killed, so we
;; must save all bookmarks first.
(add-hook 'kill-emacs-hook '(lambda nil
                              (bm-buffer-save-all)
                              (bm-repository-save)))

#+end_src 
                              
*** Bookmark+

#+begin_src emacs-lisp 

(require 'bookmark+)
;; (call-interactively 'bookmark-bmenu-list)

(setq bmkp-bmenu-state-file "~/git/.emacs.d/.emacs-bmk-bmenu-state.el")

#+end_src 

** Command aliases

#+begin_src emacs-lisp 

(defalias 'tc 'dkh/toggle-chrome)
(defalias 'll 'load-library)  ;; dynamic, instead of require
(defalias 'es 'eshell)
(defalias 'r 'list-registers)
(defalias 'ev 'eval-buffer)
(defalias 'td 'toggle-debug-on-error)
(defalias 'sc 'sql-connect)

(defalias 'j 'jabber)

(defalias 'iw 'ispell-word)
;; (defalias 'fm 'flyspell-mode)

(defalias 'egi 'el-get-install)
(defalias 'pi 'package-install)
(defalias 'ai 'auto-install-from-emacswiki)
(defalias 'bc  'bbdb-create)
(defalias 'bb  'bbdb)

(defalias 'qrr 'query-replace-regexp)

(defalias 'rn 'wdired-change-to-wdired-mode) ; rename file in dired
(defalias 'g 'grep)
(defalias 'gf 'grep-find)
(defalias 'fd 'find-dired)
(defalias 'ntr 'narrow-to-region)
(defalias 'lml 'list-matching-lines)
(defalias 'dml 'delete-matching-lines)
(defalias 'dnml 'delete-non-matching-lines)
(defalias 'sl 'sort-lines)
(defalias 'dtw 'delete-trailing-whitespace)
(defalias 'lcd 'list-colors-display)
(defalias 'rb 'revert-buffer)
(defalias 'rs 'replace-string)
(defalias 'rr 'reverse-region)
(defalias 'lf 'load-file)
(defalias 'man 'woman)

(defalias 'sh 'shell)
(defalias 'ps 'powershell)
(defalias 'fb 'flyspell-buffer)
(defalias 'sbc 'set-background-color)

(defalias 'rof 'recentf-open-files)

; elisp
(defalias 'eb 'eval-buffer)
(defalias 'er 'eval-region)
(defalias 'ed 'eval-defun)
(defalias 'ele 'eval-last-sexp)
(defalias 'eis 'elisp-index-search)

; modes
(defalias 'hm 'html-mode)
(defalias 'tm 'text-mode)
(defalias 'elm 'emacs-lisp-mode)
(defalias 'vbm 'visual-basic-mode)
(defalias 'vlm 'visual-line-mode)
(defalias 'wsm 'whitespace-mode)
(defalias 'gwsm 'global-whitespace-mode)
(defalias 'om 'org-mode)
(defalias 'ssm 'shell-script-mode)
(defalias 'cc 'calc)
(defalias 'dsm 'desktop-save-mode)

(defalias 'acm 'auto-complete-mode)

(defalias 'eu 'eudc-query-form)
#+end_src 
    
* Documentation
** Self-documentation
*** Which func mode

Which-func is a minor-mode that will add the function point is inside
to the mode-line. This is mainly useful if you are looking at large
functions, but it could also be nice if you use vertical
splits. Which-func mode is built into emacs, so you have to go through
very little work to enable it.

This package prints name of function where your current point is
located in mode line. It assumes that you work with imenu package and
imenu--index-alist is up to date.

#+begin_src emacs-lisp

(which-function-mode t)
(setq which-func-modes t)
(which-func-mode 1)

#+end_src 

*** Man

#+begin_src emacs-lisp 
(setq Man-switches "-a")

(defadvice Man-build-page-list (after reverse-page-list activate)
  (setq Man-page-list (nreverse Man-page-list)))

#+end_src 
  
*** 25.16 Using (info "(emacs)Dialog Boxes")

Don't use dialog boxes to ask questions

#+begin_src emacs-lisp 

(setq use-dialog-box nil)

#+end_src 

Don't use a file dialog to ask for files

#+begin_src emacs-lisp 

(setq use-file-dialog nil)

#+end_src 

** Google Definitions

#+begin_src emacs-lisp 

(require 'mm-url)
(defun google-define-word-or-phrase (query)
  (interactive "sInsert word or phrase to search: ")
  (let* ((url (concat "http://www.google.com.pe/search?hl=en&q=define%3A"
              (replace-regexp-in-string " " "+" query)))
     (definition
       (save-excursion
         (with-temp-buffer
           (mm-url-insert url)
           (goto-char (point-min))
           (if (search-forward "No definitions found of " nil t)
           "No definitions found"
         (buffer-substring (search-forward "<li>") (- (search-forward "<") 1)))))))
    (message "%s: %s" query definition)))

#+end_src 

** Eldoc

#+begin_src emacs-lisp 

(eldoc-mode t)

#+end_src 

* Utilities (tools)
** Tramp

*** General
    
#+begin_src emacs-lisp 

(setq tramp-default-method "ssh")

(setq tramp-default-user "username")

(setq tramp-debug-buffer t)
(setq tramp-verbose 10)

(setq password-cache nil)
;;(setq password-cache-expiry nil)

(setq tramp-backup-directory-alist backup-directory-alist)


#+end_src 

*** Clean up tramp before saving desktop

#+begin_src emacs-lisp 

(add-hook 'desktop-save-hook 'tramp-cleanup-all-buffers)



#+end_src 

** Shells
*** Eshell

#+begin_src emacs-lisp 

;;       (starter-kit-load "eshell")

;;This makes Eshell’s ‘ls’ file names RET-able. Yay!
  (eval-after-load "em-ls"
    '(progn
       (defun ted-eshell-ls-find-file-at-point (point)
         "RET on Eshell's `ls' output to open files."
         (interactive "d")
         (find-file (buffer-substring-no-properties
                     (previous-single-property-change point 'help-echo)
                     (next-single-property-change point 'help-echo))))

       (defun pat-eshell-ls-find-file-at-mouse-click (event)
         "Middle click on Eshell's `ls' output to open files.
   From Patrick Anderson via the wiki."
         (interactive "e")
         (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
         (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
         (defvar ted-eshell-ls-keymap map))

       (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
         "Eshell's `ls' now lets you click or RET on file names to open them."
         (add-text-properties 0 (length ad-return-value)
                              (list 'help-echo "RET, mouse-2: visit this file"
                                    'mouse-face 'highlight
                                    'keymap ted-eshell-ls-keymap)
                              ad-return-value)
         ad-return-value)))

  (defun ted-eshell-ls-find-file ()
          (interactive)
    (let ((fname (buffer-substring-no-properties
              (previous-single-property-change (point) 'help-echo)
              (next-single-property-change (point) 'help-echo))))
            ;; Remove any leading whitespace, including newline that might
            ;; be fetched by buffer-substring-no-properties
      (setq fname (replace-regexp-in-string "^[ \t\n]*" "" fname))
            ;; Same for trailing whitespace and newline
      (setq fname (replace-regexp-in-string "[ \t\n]*$" "" fname))
      (cond
       ((equal "" fname)
        (message "No file name found at point"))
       (fname
        (find-file fname)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Here is a cool function by MilanZamazal? that brings lots of Debian commands together. Note how options are defined and documented using eshell-eval-using-options.

    (defun eshell/deb (&rest args)
      (eshell-eval-using-options
       "deb" args
       '((?f "find" t find "list available packages matching a pattern")
         (?i "installed" t installed "list installed debs matching a pattern")
         (?l "list-files" t list-files "list files of a package")
         (?s "show" t show "show an available package")
         (?v "version" t version "show the version of an installed package")
         (?w "where" t where "find the package containing the given file")
         (nil "help" nil nil "show this usage information")
         :show-usage)
       (eshell-do-eval
        (eshell-parse-command
         (cond
          (find
           (format "apt-cache search %s" find))
          (installed
           (format "dlocate -l %s | grep '^.i'" installed))
          (list-files
           (format "dlocate -L %s | sort" list-files))
          (show
           (format "apt-cache show %s" show))
          (version
           (format "dlocate -s %s | egrep '^(Package|Status|Version):'" version))
          (where
           (format "dlocate %s" where))))
        t)))

;; aliases

(defalias 'open 'find-file)
(defalias 'openo 'find-file-other-window)

(defun eshell/emacs (file)
          (find-file file))


(setq eshell-aliases-file "~/git/.emacs.d/eshell/alias")

  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)

(defvar explicit-su-file-name "/bin/su")
(defvar explicit-su-args '("-"))

(defun su (&optional buffer)
  (interactive
   (list
    (and current-prefix-arg
     (prog1
         (read-buffer "SU buffer: "
              (generate-new-buffer-name "*su*"))
       (if (file-remote-p default-directory)
       ;; It must be possible to declare a local default-directory.
       (setq default-directory
             (expand-file-name
          (read-file-name
           "Default directory: " default-directory default-directory
           t nil 'file-directory-p))))))))
  (setq buffer (get-buffer-create (or buffer "*su*")))
  ;; Pop to buffer, so that the buffer's window will be correctly set
  ;; when we call comint (so that comint sets the COLUMNS env var properly).
  (pop-to-buffer buffer)
  (unless (comint-check-proc buffer)
    (let* ((prog explicit-su-file-name)
       (name (file-name-nondirectory prog))
       (startfile (concat "~/.emacs_" name))
       (xargs-name (intern-soft (concat "explicit-" name "-args"))))
  (apply 'make-comint-in-buffer "su" buffer prog
         (if (file-exists-p startfile) startfile)
         (if (and xargs-name (boundp xargs-name))
         (symbol-value xargs-name)
       '("-i")))
  (shell-mode)))
  buffer)

#+end_src 

*** AnsiTerm

In the above mentioned article Joseph wrote a nice little bit of elisp
to get to a running ansi-term efficiently, by hitting F2. The nice
thing about it is that it does what I mean:

 1. If I'm already in an ansi-term, but it's called "*ansi-term*"
    rename it.
 2. If I'm already in an ansi-term, but it's called something else,
    start a new ansi-term called "*ansi-term*"
 3. If I'm in another non-terminal buffer, switch to a buffer called
    "*ansi-term*" or create a new one if it doesn't exist

There's one more catch though, as Joseph explains, an ansi-term can be
considered "stopped" such that it is no longer running but the buffer
still exists. In that case I don't want the third rule to switch me to
a defunct terminal, so instead I want it to kill the buffer and create
a new ansi-term. Here is my enhanced elisp:

#+begin_src emacs-lisp 

(defun visit-ansi-term ()
  (interactive)
  "Creates an ansi-term and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*ansi-term-" (persp-name persp-curr))))
;;        (default-directory "/home/www")
        (term-cmd "/bin/bash")
)
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (ansi-term term-cmd)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*ansi-term-" (persp-name persp-curr))))))))

(global-set-key (kbd "C-x <f2>") 'visit-ansi-term)

#+end_src 

Localhost

For terminal emulation on the local host, this simple function names
the buffers *localhost*, *localhost<2>*, etc…

#+begin_src emacs-lisp 

(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))


(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))

#+end_src 

For remote hosts, an additional function was required since the
ansi-term command doesn’t support additional arguments:

#+begin_src emacs-lisp 

;; Use this for remote so I can specify command line arguments
(defun remote-term (new-buffer-name cmd &rest switches)
  (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
  (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
  (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name cmd nil switches))
  (set-buffer term-ansi-buffer-name)
  (term-mode)
  (term-char-mode)
  (term-set-escape-char ?\C-x)
  (switch-to-buffer term-ansi-buffer-name))

#+end_src 

You can then define a new function in your init file for each host you
frequently visit with it’s own buffer name and connection parameters:

#+begin_src emacs-lisp 

(defun open-prod ()
  (interactive)
  (remote-term (concat "ansi-term-" (persp-name persp-curr) ) "ssh" "user@prod.domain.com"))

(defun open-stage ()
  (interactive)
  (remote-term (concat "ansi-term-" (persp-name persp-curr) ) "ssh" "user@host-staging.domain.com"))

(defun open-test ()
  (interactive)
  (remote-term (concat "ansi-term-" (persp-name persp-curr) ) "ssh" "user@localhost"))


(defun open-devel ()
  (interactive)
  (remote-term (concat "ansi-term-" (persp-name persp-curr) ) "ssh" "user@localhost"))

(global-set-key (kbd "C-x <f6>") 'open-devel)
(global-set-key (kbd "C-x <f7>") 'open-test)
(global-set-key (kbd "C-x <f8>") 'open-stage)
(global-set-key (kbd "C-x <f9>") 'open-prod)

#+end_src 

*** Shell functions

#+begin_src emacs-lisp 

(defun shell-command-on-region-to-string (start end command)                    
  (with-output-to-string                                                        
    (shell-command-on-region start end command standard-output)))               
                                                                                
(defun shell-command-on-region-with-output-to-end-of-buffer (start end command) 
  (interactive                                                                  
   (let ((command (read-shell-command "Shell command on region: ")))            
     (if (use-region-p)                                                         
         (list (region-beginning) (region-end) command)                         
       (list (point-min) (point-max) command))))                                
  (save-excursion                                                               
    (goto-char (point-max))                                                     
    (insert (shell-command-on-region-to-string start end command))))

(defun shell-here ()
  "Open a shell in `default-directory'."
  (interactive)
  (let ((dir (expand-file-name default-directory))
        (buf (or (get-buffer "*shell*") (shell))))
    (goto-char (point-max))
    (if (not (string= (buffer-name) "*shell*"))
        (switch-to-buffer-other-window buf))
    (message list-buffers-directory)
    (if (not (string= (expand-file-name list-buffers-directory) dir))
        (progn (comint-send-string (get-buffer-process buf)
                                   (concat "cd \"" dir "\"\r"))
               (setq list-buffers-directory dir)))))

(setq ansi-color-names-vector
      ["black" "tomato" "PaleGreen2" "gold1"
       "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])

(setq ansi-color-map (ansi-color-make-color-map))

(add-hook 'shell-mode-hook 
     '(lambda () (toggle-truncate-lines 1)))
(setq comint-prompt-read-only t)

(defvar my-local-shells
  '("*shell0*" "*shell1*" "*shell2*" "*shell3*" "*music*"))
(defvar my-remote-shells
  '("*dhaley*" "*pup*" "*pup-staging*" "*heaven2*" "*heaven3*"))
(defvar my-shells (append my-local-shells my-remote-shells))

(custom-set-variables
 '(comint-scroll-to-bottom-on-input t)  ; always insert at the bottom
 ;; '(comint-completion-autolist t)     ; show completion list when ambiguous
 '(comint-input-ignoredups t)           ; no duplicates in command history
 '(comint-buffer-maximum-size 20000)    ; max length of the buffer in lines
 '(comint-prompt-read-only nil)         ; if this is t, it breaks shell-command
 '(comint-get-old-input (lambda () "")) ; what to run when i press enter on a
                                        ; line above the current prompt
 '(protect-buffer-bury-p nil)
)

;; truncate buffers continuously
(add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

(defun make-my-shell-output-read-only (text)
  "Add to comint-output-filter-functions to make stdout read only in my shells."
  (if (member (buffer-name) my-shells)
      (let ((inhibit-read-only t)
            (output-end (process-mark (get-buffer-process (current-buffer)))))
        (put-text-property comint-last-output-start output-end 'read-only t))))
(add-hook 'comint-output-filter-functions 'make-my-shell-output-read-only)

(defun my-dirtrack-mode ()
  "Add to shell-mode-hook to use dirtrack mode in my shell buffers."
  (when (member (buffer-name) my-shells)
    (shell-dirtrack-mode 0)
    (set-variable 'dirtrack-list '("^.*[^ ]+:\\(.*\\)>" 1 nil))
    (dirtrack-mode 1)))
(add-hook 'shell-mode-hook 'my-dirtrack-mode)

; interpret and use ansi color codes in shell output windows
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

(defun set-scroll-conservatively ()
  "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
  (set (make-local-variable 'scroll-conservatively) 10))
(add-hook 'shell-mode-hook 'set-scroll-conservatively)

;; i think this is wrong, and it buries the shell when you run emacsclient from
;; it. temporarily removing.
;; (defun unset-display-buffer-reuse-frames ()
;;   "Add to shell-mode-hook to prevent switching away from the shell buffer
;; when emacsclient opens a new buffer."
;;   (set (make-local-variable 'display-buffer-reuse-frames) t))
;; (add-hook 'shell-mode-hook 'unset-display-buffer-reuse-frames)

(require 'protbuf)
(add-hook 'shell-mode-hook 'protect-process-buffer-from-kill-mode)


(defun make-comint-directory-tracking-work-remotely ()
  "Add this to comint-mode-hook to make directory tracking work
while sshed into a remote host, e.g. for remote shell buffers
started in tramp. (This is a bug fix backported from Emacs 24:
http://comments.gmane.org/gmane.emacs.bugs/39082"
  (set (make-local-variable 'comint-file-name-prefix)
       (or (file-remote-p default-directory) "")))
(add-hook 'comint-mode-hook 'make-comint-directory-tracking-work-remotely)

(defun enter-again-if-enter ()
  "Make the return key select the current item in minibuf and shell history isearch.
An alternate approach would be after-advice on isearch-other-meta-char."
  (when (and (not isearch-mode-end-hook-quit)
             (equal (this-command-keys-vector) [13])) ; == return
    (cond ((active-minibuffer-window) (minibuffer-complete-and-exit))
          ((member (buffer-name) my-shells) (comint-send-input)))))
(add-hook 'isearch-mode-end-hook 'enter-again-if-enter)

(defadvice comint-previous-matching-input
    (around suppress-history-item-messages activate)
  "Suppress the annoying 'History item : NNN' messages from shell history isearch.
If this isn't enough, try the same thing with
comint-replace-by-expanded-history-before-point."
  (let ((old-message (symbol-function 'message)))
    (unwind-protect
      (progn (fset 'message 'ignore) ad-do-it)
    (fset 'message old-message))))

(defadvice comint-send-input (around go-to-end-of-multiline activate)
  "When I press enter, jump to the end of the *buffer*, instead of the end of
the line, to capture multiline input. (This only has effect if
`comint-eol-on-send' is non-nil."
  (flet ((end-of-line () (end-of-buffer)))
    ad-do-it))

;; not sure why, but comint needs to be reloaded from the source (*not*
;; compiled) elisp to make the above advise stick.
(load "comint.el.gz")

;; for other code, e.g. emacsclient in TRAMP ssh shells and automatically
;; closing completions buffers, see the links above.

#+end_src 

*** Improving ansi-term

I use ansi-term quite a bit. Why leave Emacs to have a terminal?
However, there were a few issues I had with ansi-term that were quite
annoying.

However, because Emacs is awesome, the issues were pretty easily
fixed.

First things first, I didn't like that running `exit` in my terminal
left a useless buffer around. A little searching around online, and I
found the following solution, using defadvice:

#+begin_src emacs-lisp :tangle no

    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
            ad-do-it
            (kill-buffer buffer))
        ad-do-it))
    (ad-activate 'term-sentinel)

#+end_src 
    
This tells term (which is used by ansi-term) to kill the buffer after
the terminal is exited. The original I found online also killed the
frame, but I use one frame with multiple windows, so I removed that
call.

Secondly, I always use bash. I don't need ansi-term to ask me which
shell to use every time I invoke it. Once again, defadvice to the
rescue. I wrote the following bit of advice that lets the user set the
shell program to a variable, then advise ansi-term to always use that
(and not ask). The defvar could just as easily be made a defcustom,
and perhaps one day I'll do that. For now, though, this works for me.


#+begin_src emacs-lisp :tangle no

    (defvar my-term-shell "/bin/bash")
    (defadvice ansi-term (before force-bash)
      (interactive (list my-term-shell)))
    (ad-activate 'ansi-term)

#+end_src     
    
Another issue I has was with the display of certain characters and
control codes. The following hook sets the term to use UTF-8.

#+begin_src emacs-lisp 

    (defun my-term-use-utf8 ()
      (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
    (add-hook 'term-exec-hook 'my-term-use-utf8)

#+end_src

Next, I wanted urls that show up in my terminal (via man pages, help,
info, errors, etc) to be clickable. This was solved very easily by
hooking `goto-address-mode` into ansi-term. To make add more hooks
into ansi-term easier in the future, I defined my own hook function,
currently with just `goto-address-mode`:

#+begin_src emacs-lisp :tangle no

    (defun my-term-hook ()
      (goto-address-mode))

#+end_src       

Then added my hook to term-mode-hook:

#+begin_src emacs-lisp 

    (add-hook 'term-mode-hook 'my-term-hook)

#+end_src 
    
After this, I realized that C-y doesn't work in ansi-term like you'd
expect. It pastes into the buffer, sure, but the text doesn't get sent
to the process. So if you copy a bash command, then C-y it into the
buffer, nothing happens when you press enter (because, as far as
ansi-term is concerned, no text was entered at the prompt). The
following function will paste whatever is copied into ansi-term in
such a way that the process can, well, process it:

#+begin_src emacs-lisp 

    (defun my-term-paste (&optional string)
     (interactive)
     (process-send-string
      (get-buffer-process (current-buffer))
      (if string string (current-kill 0))))

#+end_src 
      
Then I just add the binding to my hook from before, making it this:

#+begin_src emacs-lisp :tangle no

    (defun my-term-hook ()
      (goto-address-mode)
      (define-key term-raw-map "\C-y" 'my-term-paste))

#+end_src 
      
Since I've already hooked it into 'term-mode-hook, there's no reason
to do so again. Simply reevaluate the function.

Finally, I've recently been using the [[http://ethanschoonover.com/solarized][solarized theme]], both in Emacs
and in my terminals. However, ansi-term wasn't quite playing well with
this. The colors were wrong in ansi-term, even though they were right
in the rest of Emacs. A friend and co-worker of mine wrote the
following bit of elisp that, when added to the term-mode-hook, makes
ansi-term use the right colors for solarized. (Note that this is only
needed if you use solarized and your ansi-term doesn't look right.
Installing solarized, either in emacs or on your system, is beyond the
scope of this post. However, I should mention that you can find it via
M-x package-list-packages. The one you probably want is
`color-theme-solarized `.) So, adding the elisp he wrote to my
my-term-hook results in this:

#+begin_src emacs-lisp 

    (defun my-term-hook ()
      (goto-address-mode)
      (define-key term-raw-map "\C-y" 'my-term-paste)
      (let ((base03  "#002b36")
            (base02  "#073642")
            (base01  "#586e75")
            (base00  "#657b83")
            (base0   "#839496")
            (base1   "#93a1a1")
            (base2   "#eee8d5")
            (base3   "#fdf6e3")
            (yellow  "#b58900")
            (orange  "#cb4b16")
            (red     "#dc322f")
            (magenta "#d33682")
            (violet  "#6c71c4")
            (blue    "#268bd2")
            (cyan    "#2aa198")
            (green   "#859900"))
        (setq ansi-term-color-vector
              (vconcat `(unspecified ,base02 ,red ,green ,yellow ,blue
                                     ,magenta ,cyan ,base2)))))

#+end_src 
                                     
Again, its already added to my term-mode-hook, so reevaluate and off
we go.

So there you have it. With a little bit of elisp, ansi-term is much
more streamlined (in my opinion) and better to work with. Hopefully
this information will help others in the future. Posted by [[https://profiles.google.com/111299187812335372965][Brian Zwahr]]
at [[http://emacs-journey.blogspot.com/2012/06/improving-ansi-term.html][12:02 PM]] [[http://www.blogger.com/email-post.g?blogID%3D3610844988855884806&postID%3D7346863015606057752][# ]] [[http://www.blogger.com/post-edit.g?blogID%3D3610844988855884806&postID%3D7346863015606057752&from%3Dpencil][# ]] Labels: [[http://emacs-journey.blogspot.com/search/label/ansi-term][ansi-term]], [[http://emacs-journey.blogspot.com/search/label/emacs][emacs]], [[http://emacs-journey.blogspot.com/search/label/hook][hook]], [[http://emacs-journey.blogspot.com/search/label/term][term]], [[http://emacs-journey.blogspot.com/search/label/terminal][terminal]],
[[http://emacs-journey.blogspot.com/search/label/utf-8][utf-8]], [[http://emacs-journey.blogspot.com/search/label/utf8][utf8]]

** Dired

#+begin_src emacs-lisp 

;; enable the use of the command `dired-find-alternate-file'
;; without confirmation
(put 'dired-find-alternate-file 'disabled nil)

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map "b" 'my-browser-find-file)))

(defun my-dired-browser-find-file ()
  "Dired function to view a file in a web browser"
  (interactive)
  (browse-url (browse-url-file-url (dired-get-filename))))

(add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))

;; (setq dired-omit-file "^\\.?#\\|^\\.$\\|^\\.\\.$")

(setq dired-omit-files 
      (rx (or (seq bol (? ".") "#")         ;; emacs autosave files 
              (seq "~" eol)                 ;; backup-files 
              (seq bol "svn" eol)           ;; svn dirs 
;;              (seq ".git" eol)
              (seq bol "." (not (any "."))) ;; dot-files                                                                                                                                                                    
;;              (seq ".pyc" eol)
              )))
(setq dired-omit-extensions 
      (append dired-latex-unclean-extensions 
              dired-bibtex-unclean-extensions 
              dired-texinfo-unclean-extensions))
(add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))

(defun 2zip ()
  "Zip the current file/dir in `dired'.
If multiple files are marked, only zip the first one.
Require unix zip commandline tool."
  (interactive)
  (require 'dired)
  (let ( (fileName (elt (dired-get-marked-files) 0))  )
    (shell-command (format "zip -r '%s.zip' '%s'" (file-relative-name fileName) (file-relative-name fileName)))
    ))

(autoload 'dired-jump "dired-x" "Jump to dired corresponding current buffer.") 
(autoload 'dired-jump-other-window "dired-x" "jump to dired in other window.")


(setq toggle-diredp-find-file-reuse-directory t)

#+end_src 

** Gnus

[[http://wikemacs.org/wiki/Gnus][Some nice tips on using gnus]]

#+begin_src emacs-lisp 

(add-hook 'message-sent-hook 'gnus-score-followup-article)
(add-hook 'message-sent-hook 'gnus-score-followup-thread)

(setq gnus-kill-files-directory "~/git/gnus/.gnuskillfiled") ;;

(defun my-gnus ()
  "Start a new Gnus, or locate the existing buffer *Group*."
  (interactive)
  (if (buffer-live-p    (get-buffer "*Group*"))
      (switch-to-buffer (get-buffer "*Group*"))
    (gnus)))

#+end_src 

*** Main Gnus IMAP config

#+begin_src emacs-lisp 

(require 'gnus)
(setq message-directory "~/git/gnus/Mail")
(setq nnml-directory "~/git/gnus/Mail")
(setq gnus-article-save-directory "~/git/gnus/News")
(setq gnus-cache-directory "~/git/gnus/News/cache")

(setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\”]\”[#’()]")

;;(setq gnus-select-method
;;      (nntp "Gwene"
;;            (nntp-address "news.gwene.org"))
;;      (nntp "Gmane"
;;            (nntp-address "news.gmane.org"))
;;      (nntp "Gnus"
;;            (nntp-address "news.gnus.org"))
;;      (nnml "freeshell"
;;            (nnmaildir "" (directory "~/Mail"))
;;            (nnml-get-new-mail t)))


(setq auth-sources (quote ((:source "~/.emacs.d/.authinfo.gpg"
                                    :host t :protocol t))))

(copy-face 'default 'my-gnus-face)
(copy-face 'my-gnus-face 'my-subject-face)

(copy-face 'my-gnus-face 'my-group-face)
(set-face-attribute 'my-group-face nil :inherit 'my-gnus-face)

(copy-face 'my-group-face 'my-group-face-unread)
(set-face-attribute 'my-group-face-unread nil :inherit 'my-group-face)

(copy-face 'my-group-face 'my-group-server-face)
(copy-face 'my-group-server-face 'my-group-server-face-unread)
(set-face-attribute 'my-group-server-face-unread nil :inherit 'my-group-server-face)

(copy-face 'my-group-face 'my-unread-count-face)
(copy-face 'my-unread-count-face 'my-unread-count-face-unread)
(set-face-attribute 'my-unread-count-face-unread nil :inherit 'my-unread-count-face)

(copy-face 'my-group-face 'my-inbox-icon-face)
(copy-face 'my-inbox-icon-face 'my-inbox-icon-face-unread)
(set-face-attribute 'my-inbox-icon-face-unread nil :inherit 'my-inbox-icon-face)

(copy-face 'my-gnus-face 'my-topic-empty-face)
(copy-face 'my-gnus-face 'my-topic-face)


(setq nntp-marks-is-evil t)


(require 'gnus)
;; (require 'gnushush)

;;           (require 'miniedit)

(defun store-gnus-outgoing-message-group ()
  (cond ((and gnus-newsgroup-name
              (not (message-news-p))
              (stringp gnus-newsgroup-name))
         gnus-newsgroup-name)
        (t ted-default-gcc-group)))

(setq gnus-outgoing-message-group nil
      gnus-level-subscribed 5)

(setq gnus-topic-line-format "%i[ %u&topic-line; ] %v\n")

(defun dkh/unread-face (f)
  (intern (if (> (string-to-number gnus-tmp-number-of-unread) 0) (concat f "-unread") f)))

;; this corresponds to a topic line format of "%n %A"
(defun gnus-user-format-function-topic-line (dummy)
  (let ((topic-face (if (zerop total-number-of-articles)
                        'my-topic-empty-face
                      'my-topic-face)))
    (propertize
     (format "%s %d" name total-number-of-articles)
     'face topic-face)))

(defun gnus-user-format-function-s (header)
  (propertize (mail-header-subject header) 'face 'my-subject-face 'gnus-face t))

;; dkh commented out all this stuff
(defun gnus-user-format-function-g (headers) ;; gnus-group-line-format use %ug to call this func! e.g  "%M%S%p%P%(%-40,40ug%)%-5uy %ud\n"
  split full group protocol-server:group into three parts.
  (message "format function g for group %s" gnus-tmp-group)
  (string-match "\\(^.*\\)\\+\\(.*\\):\\(.*\\)" gnus-tmp-group)
  map the first two letters of the server name to a more friendly and cuddly display name
  (let*  ((match-ok (match-string 2 gnus-tmp-group))
          (server-key (if (null match-ok) nil (upcase(substring match-ok 0 2)))))
    (if (zerop (length server-key))
        gnus-tmp-group
      ;; construct new group format line with a small envelope taking the place of any INBOX
      (concat
       (propertize
        (format "%-8s" (cdr (assoc server-key dkh/server-name-maps)))
        'face (dkh/unread-face "my-group-server-face") 'face (dkh/unread-face (concat "my-group-server-face-" server-key)) 'gnus-face t)
       " - "
       (if (or (string-match "mail.misc" (match-string 3 gnus-tmp-group) )(string-match "INBOX" (match-string 3 gnus-tmp-group) ))
           (propertize "\x2709" 'face (dkh/unread-face "my-inbox-icon-face") 'gnus-face t)
         (propertize (match-string 3 gnus-tmp-group) 'face (dkh/unread-face "my-group-face") 'gnus-face t) )))))


(defun gnus-user-format-function-j (headers)
  ;; prefix each post depending on whether to, cc or Bcc to
  (let ((to (gnus-extra-header 'To headers)))
    (if (string-match dkh-mails to)
        (if (string-match "," to) "~" "»")
      (if (or (string-match dkh-mails
                            (gnus-extra-header 'Cc headers))
              (string-match dkh-mails
                            (gnus-extra-header 'BCc headers)))
          "~"
        " "))))

(defun gnus-user-format-function-y (headers)
  "return string representation for unread articles"
  (concat
   (propertize  (if (= (string-to-number  gnus-tmp-number-of-unread) 0) "" "\x2709") 'face (dkh/unread-face "my-inbox-icon-face") 'gnus-face t)
   (propertize  (if (= (string-to-number  gnus-tmp-number-of-unread) 0) ""
                  (concat "   (" gnus-tmp-number-of-unread ")")) 'face (dkh/unread-face "my-unread-count-face") 'gnus-face t)))



(setq  gnus-user-date-format-alist
       ;; Format the date so we can see today/tomorrow quickly.
       ;; See http://emacs.wordpress.com/category/gnus/ for the original.
       '(
         ((gnus-seconds-today) . "Today, %H:%M")
         ((+ 86400 (gnus-seconds-today)) . "Yesterday, %H:%M")
         (604800 . "%A %H:%M") ;;that's one week
         ((gnus-seconds-month) . "%A %d")
         ((gnus-seconds-year) . "%B %d")
         (t . "%B %d '%y"))) ;;this one is used when no other does match


(defun gnus-group-read-group-no-prompt ()
  "Read news in this newsgroup and don't prompt.
                                Use the value of `gnus-large-newsgroup'."
  (interactive)
  (gnus-group-read-group gnus-large-newsgroup))

(defun gnus-article-sort-by-chars (h1 h2)
  "Sort articles by size."
  (< (mail-header-chars h1)
     (mail-header-chars h2)))

;;             (add-to-list 'message-syntax-checks '(existing-newsgroups . disabled))





;; group topics
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)


;;F6 killfiles a poster, F7 ignores a thread
;;   (define-key gnus-summary-mode-map (kbd "<f6>") "LA")
;;   (define-key gnus-summary-mode-map (kbd "<f7>") 'gnus-summary-kill-thread)
(define-key gnus-summary-mode-map (kbd "<deletechar>") (lambda ()(interactive)(gnus-summary-delete-article)(next-line)))

;; some comfort keys to scroll article in other window when in summary window
(define-key gnus-summary-mode-map [(meta up)] (lambda() (interactive) (scroll-other-window -1)))
(define-key gnus-summary-mode-map [(meta down)] (lambda() (interactive) (scroll-other-window 1)))
;; thread navigation
(define-key gnus-summary-mode-map [(control down)] 'gnus-summary-next-thread)
(define-key gnus-summary-mode-map [(control up)] 'gnus-summary-prev-thread)


(define-key gnus-summary-mode-map (kbd ">") 'gnus-summary-show-thread)
(define-key gnus-summary-mode-map (kbd "<") 'gnus-summary-hide-thread)


;; some trickery to show the newsread people are using and colour code depending on type
;; in this case highlight users of any outlook type dross :-;
(setq  gnus-header-face-alist nil)
(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*") ;; other
       nil font-lock-comment-face))

(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*Outlook.*")
       nil 'gnus-emphasis-highlight-words))

;; And show any real men who use Gnus!
(add-to-list
 'gnus-header-face-alist
 (list (concat
        "^"
        (regexp-opt '("User-Agent" "X-Mailer" "Newsreader" "X-Newsreader") t)
        ":.*Gnus.*")
       nil 'gnus-server-opened))

;; Format RSS feed titles nicely
(add-hook 'gnus-summary-mode-hook
          (lambda ()
            (if (string-match "^nnrss:.*" gnus-newsgroup-name)
                (progn
                  (make-local-variable 'gnus-show-threads)
                  (make-local-variable 'gnus-article-sort-functions)
                  (make-local-variable 'gnus-use-adaptive-scoring)
                  (make-local-variable 'gnus-use-scoring)
                  (make-local-variable 'gnus-score-find-score-files-function)
                  (setq gnus-show-threads nil)
                  (setq gnus-article-sort-functions 'gnus-article-sort-by-date)
                  (setq gnus-use-adaptive-scoring nil)
                  (setq gnus-use-scoring t)
                  ;;                  (setq gnus-score-find-score-files-function 'gnus-score-find-single)
                  ))))


(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)

(defun gnus-user-format-function-d (headers)
  (let ((time (gnus-group-timestamp gnus-tmp-group)))
    (if time
        (format-time-string "%b %d  %H:%M" time)
      ""
      )
    )
  )

(define-key mode-specific-map [?m] (lambda()(interactive) (gnus-agent-toggle-plugged t)(gnus 1)))

;; which email addresses to detect for special highlighting
(defvar dkh-mails
  "me@google.com")



(starter-kit-load "gnus" "pretty-summary")

(setq gnus-suppress-duplicates t
      gnus-save-duplicate-list t
      gnus-duplicate-list-length 100000)

(remove-hook 'gnus-article-prepare-hook 'bbdb-mua-display-sender)




(gnus-add-configuration
 '(article
   (horizontal 1.0
               (group 0.25)
               (vertical 1.0
                         (summary 0.16 point)
                         (article 1.0)
                         ("*BBDB*" 6))
               )))

(add-hook 'gnus-summary-exit-hook
          (lambda ()
            (when (every (lambda (buffer) (member buffer (gnus-buffers)))
                         (mapcar 'window-buffer (window-list)))
              (delete-other-windows)))
          t nil)

;; Set the window title
                                        ;(modify-frame-parameters nil '((title . "Gnus")))

;; indexing in mail groups supported by dovecot on the server side.
(require 'nnir)

(define-key gnus-group-mode-map (kbd "<H-f1>") 'gnus-group-make-nnir-group)
;; (define-key gnus-group-mode-map (kbd "<C-f3>") 'gnus-group-make-nnir-group)
;;  (define-key gnus-summary-mode-map (kbd "G G") 'command gnus-group-make-nnir-group)

                                        ; (setq nnir-search-engine 'imap)

(defcustom dkh/authinfo-file (expand-file-name(concat user-emacs-directory ".authinfo.gpg"))
  "regexp for searching blogger"
  :group 'dkh/gnus
  :type 'string)

(global-set-key (kbd "C-c x") '(lambda()(interactive)(save-buffers-kill-emacs)))
;; Mark gcc'ed (archive) as read:
(setq gnus-gcc-mark-as-read t)

;; put everything in ~/.emacs.d
(setq
 gnus-init-file "~/git/.emacs.d/dkh-gnus.el"
 message-signatrue-directory "~/git/.emacs.d/sig/"
 )

#+end_src 


*** Second part




#+begin_src emacs-lisp 

(setq gnus-startup-file "~/git/gnus/.newsrc")
       (setq gnus-directory "~/git/gnus/News")
     (setq gnus-dribble-directory "~/git/gnus/")
       (setq gnus-home-directory "~/git/gnus")
     (setq nntp-marks-directory "~/git/gnus/News/")
     (setq nndraft-directory "~/git/gnus/News/drafts/")
     (setq nndraft-current-directory "~/git/gnus/News/drafts/")
   (setq mail-default-directory "~/git/gnus/Mail")
   (setq gnus-default-directory "~/git/gnus")
   (setq nnmail-message-id-cache-file "~/git/gnus/nnmail_cache")

     (setq gnus-posting-styles
           '(
             ;;
             ;; Default (also used when no group is selected)
             ;; - innovation address
             ;; - record copy into INBOX
             ;;
             (".*"
              (eval(setq gnushush-user-agent-header (quote real)))
              ;;                             (eval (setq mml2015-signers '("b39a104a")))
              )
           ))

           (setq gnus-permanently-visible-groups nil)

(setq gnus-summary-save-parts-last-directory "~/Downloads")


;; (require 'info)
  (if (featurep 'xemacs)
      (add-to-list 'Info-directory-list "~/.emacs.d/el-get/nognus/texi/")
    (add-to-list 'Info-default-directory-list "~/.emacs.d/el-get/nognus/texi/"))

(defcustom gnus-summary-save-parts-exclude-article nil                                                                                                                                                                     
          "If non-nil don't save article along with attachments."                                                                                                                                                                  
          :group 'gnus-article-mime                                                                                                                                                                                                
          :type 'boolean)                                                                                                                                                                                                          
                                                                                                                                                                                                                                   
        (defun gnus-summary-save-parts-1 (type dir handle reverse)                                                                                                                                                                 
          (if (stringp (car handle))                                                                                                                                                                                               
(mapcar (lambda (h) (gnus-summary-save-parts-1 type dir h reverse))                                                                                                                                                  
    (cdr handle))                                                                                                                                                                                                    
            (when (if reverse                                                                                                                                                                                                      
                  (not (string-match type (mm-handle-media-type handle)))                                                                                                                                                          
                (string-match type (mm-handle-media-type handle)))                                                                                                                                                                 
              (let* ((name (or                                                                                                                                                                                                     
                            (mm-handle-filename handle)                                                                                                                                                                            
                            (unless gnus-summary-save-parts-exclude-article                                                                                                                                                        
                              (format "%s.%d.%d" gnus-newsgroup-name                                                                                                                                                               
                                      (cdr gnus-article-current)                                                                                                                                                                   
                                      gnus-summary-save-parts-counter))))                                                                                                                                                          
                     (file (when name                                                                                                                                                                                              
                             (expand-file-name                                                                                                                                                                                     
                              (gnus-map-function                                                                                                                                                                                   
                               mm-file-name-rewrite-functions                                                                                                                                                                      
                               (file-name-nondirectory                                                                                                                                                                             
                                name))                                                                                                                                                                                             
                              dir))))                                                                                                                                                                                              
                (when file                                                                                                                                                                                                         
                  (incf gnus-summary-save-parts-counter)                                                                                                                                                                           
                  (unless (file-exists-p file)                                                                                                                                                                                     
                    (mm-save-part-to-file handle file)))))))

(setq message-cite-prefix-regexp
"\\([ ]*[-_.#[:word:]]+>+\\|[ ]*[]>|}]\\)+")


#+end_src 


*** Gnus pop

#+begin_src emacs-lisp :tangle no

(require 'secrets)
(setq mail-sources
  `(
   (file :path "/var/mail/user")
   (pop :server "mail.host.org"
        :user "user@host.org"
        :password ,(rest (assoc :nightmarehost password-alist)))
   (pop
    :server "127.0.0.1"
    :port 1235
    :user "user"
    :password ,(rest (assoc :freehost password-alist))
    :prescript "ssh -f -L 1235:mail.freehost.org:110 user@mail.freehost.org sleep 60 &")))

#+end_src 

*** Gnus smtp

#+begin_src emacs-lisp 

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-default-smtp-server "smtp.host.com")

(setq smtpmail-smtp-service 587)

#+end_src 

** ERC

#+begin_src emacs-lisp

(erc-notify-mode 1)
(load-library "erc-highlight-nicknames")
(add-to-list 'erc-modules 'highlight-nicknames)
(add-to-list 'erc-modules 'match)

(erc-update-modules)

(require 'erc-autoaway)
(setq erc-auto-discard-away t)
(setq erc-autoaway-idle-seconds 600)
(setq erc-autoaway-use-emacs-idle t)
(setq erc-autoaway-message "cappuccino time")

(erc-button-mode nil) ;slow
(erc-fill-mode t)

(require 'erc-log)
  ;; logging
  (setq erc-log-channels-directory "~/.emacs.d/.erc/logs/")

  (if (not (file-exists-p erc-log-channels-directory))
      (mkdir erc-log-channels-directory t))

;; logging:
(setq erc-log-insert-log-on-open nil)
(setq erc-log-channels t)

(setq erc-hide-timestamps nil)
(erc-netsplit-mode t)

(require 'erc-notify)
      (setq erc-notify-list  '(
                       "ultimateboy"
                       "techgeekgirl"
"technomancy" ;; mentioned conkeror in #emacs
))

;; (require 'erc-ring)
(erc-ring-mode t)

(require 'erc-spelling)
;; enable spell checking
(erc-spelling-mode 1)

(erc-timestamp-mode t)
(setq erc-timestamp-format "[%R-%m/%d]")

;; check channels
(erc-track-mode t)
(setq erc-track-use-faces t)

(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))

(setq erc-track-exclude-server-buffer t)

(defadvice erc-track-find-face (around erc-track-find-face-promote-query activate)
  (if (erc-query-buffer-p)
      (setq ad-return-value (intern "erc-current-nick-face"))
    ad-do-it))

(defadvice erc-track-modified-channels (around erc-track-modified-channels-promote-query activate)
  (if (erc-query-buffer-p) (setq erc-track-priority-faces-only 'nil))
  ad-do-it
  (if (erc-query-buffer-p) (setq erc-track-priority-faces-only 'all)))

;;;; truncate long irc buffers
(erc-truncate-mode +1)

; auto truncatebuffers
(defvar erc-insert-post-hook)
(add-hook 'erc-insert-post-hook
    'erc-truncate-buffer)

;; share my real name
(setq erc-user-full-name "Mi nombre")

(defun erc-cmd-UPTIME (&rest ignore)
  "Display the uptime of the system, as well as some load-related
stuff, to the current ERC buffer."
  (let ((uname-output
         (replace-regexp-in-string
          ", load average: " "] {Load average} ["
          ;; Collapse spaces, remove
          (replace-regexp-in-string
           " +" " "
           ;; Remove beginning and trailing whitespace
           (replace-regexp-in-string
            "^ +\\|[ \n]+$" ""
            (shell-command-to-string "uptime"))))))
    (erc-send-message
     (concat "{Uptime} [" uname-output "]"))))

(global-set-key (kbd "C-H-i") (lambda () (interactive)
(erc :server "asimov.freenode.net"  :nick "my_nick" :password "my_pass" :port 6667)
))

(setq erc-autojoin-channels-alist
  '((".*\\.freenode.net" "#drupal-colorado" "#emacs" 
  "#solidstatedepot" "#fsf-members" "#erc" "#conkeror" "#org-mode")
;;     (".*\\.gimp.org" "#unix" "#gtk+")
;;     (".*\\.gnome.org" "#sparklehorse" "#gtk+")
))

(setq erc-interpret-mirc-color t)

;; The following are commented out by default, but users of other
;; non-Emacs IRC clients might find them useful.
;; Kill buffers for channels after /part
;; (setq erc-kill-buffer-on-part t)
;; Kill buffers for private queries after quitting the server
;; (setq erc-kill-queries-on-quit t)
;; Kill buffers for server messages after quitting the server
;; (setq erc-kill-server-buffer-on-quit t)

(setq erc-query-display 'buffer)

(defun erc-cmd-SHOWOFF (&rest ignore)
  "Show off implementation"
  (let* ((chnl (erc-buffer-list))
         (srvl (erc-buffer-list 'erc-server-buffer-p))
         (memb (apply '+ (mapcar (lambda (chn)
                                   (with-current-buffer chn
                                     (1- (length (erc-get-channel-user-list)))))
                                 chnl)))
         (show (format "is connected to %i networks and talks in %i chans to %i ppl overall :>"
                       (length srvl)
                       (- (length chnl) (length srvl))
                       memb)))
    (erc-send-action (erc-default-target) show)))

(defalias 'erc-cmd-SO 'erc-cmd-SHOWOFF)

(defun erc-cmd-DETAILED-SHOWOFF (&rest ignore)
  "Show off implementation enriched with even more with details"
  (let* ((chnl (erc-buffer-list))
         (srvl (erc-buffer-list 'erc-server-buffer-p)))
    (mapcar (lambda (srv)
              (let* ((netn (with-current-buffer srv erc-session-server))
                     (netp (with-current-buffer srv erc-session-port))
                     (chns (remove-if-not
                            (lambda (chn)
                              (and (string= netn (with-current-buffer chn erc-session-server))
                                   (eq netp (with-current-buffer chn erc-session-port))))
                            chnl))
                     (chnn (1- (length chns)))
                     (chnm (remove nil
                                   (mapcar (lambda (chn)
                                             (with-current-buffer chn
                                               (erc-get-channel-user-list)))
                                           chns)))
                     (chnmn (apply '+ (mapcar '1- (mapcar 'length chnm))))
                     (show (format "is connected to %s (%s), talking to %i users in %i chans"
                                   netn
                                   (buffer-name srv)
                                   chnmn
                                   chnn)))
                (erc-send-action (erc-default-target) show)
                (sit-for 1)))
            srvl)))

(defalias 'erc-cmd-DSO 'erc-cmd-DETAILED-SHOWOFF)

(setq erc-server-coding-system '(utf-8 . utf-8))

(defun filter-server-buffers ()
  (delq nil
        (mapcar
         (lambda (x) (and (erc-server-buffer-p x) x))
         (buffer-list))))

(setq erc-keywords '("\scu\s" "\stor\s" "university"
   "academic" "organic groups" "relation module" "contextual filter" "gmane" "gwene"
   "dired" "bitcoin" ) )

(erc-match-enable)
(erc-match-mode 1)

(setq erc-track-faces-priority-list
'(erc-current-nick-face erc-keyword-face erc-pal-face
erc-nick-msg-face erc-direct-msg-face))

(setq erc-current-nick-highlight-type 'nick)

(setq erc-track-priority-faces-only 'all)

(defun my-erc-md-all-but-emacs ()
  "Minimal distraction for all channels except #emacs"
  (interactive)
  (setq erc-track-priority-faces-only
        (remove "#emacs" (my-erc-joined-channels))))

(defun my-erc-joined-channels ()
  "Return all the channels you're in as a list.  This does not include queries."
  (save-excursion
    ;; need to get out of ERC mode so we can have *all* channels returned
    (set-buffer "*scratch*")
    (mapcar #'(lambda (chanbuf)
                (with-current-buffer chanbuf (erc-default-target)))
            (erc-channel-list erc-process))))

(defun erc-cmd-UNTRACK (&optional target)
  "Add TARGET to the list of target to be tracked."
  (if target
      (erc-with-server-buffer
 (let ((untracked (car (erc-member-ignore-case target erc-track-exclude))))
   (if untracked
       (erc-display-line
        (erc-make-notice (format "%s is not currently tracked!" target))
        'active)
     (add-to-list 'erc-track-exclude target)
     (erc-display-line
      (erc-make-notice (format "Now not tracking %s" target))
      'active))))

    (if (null erc-track-exclude)
 (erc-display-line (erc-make-notice "Untracked targets list is empty") 'active)

      (erc-display-line (erc-make-notice "Untracked targets list:") 'active)
      (mapc #'(lambda (item)
     (erc-display-line (erc-make-notice item) 'active))
     (erc-with-server-buffer erc-track-exclude))))
  t)


(defun erc-cmd-TRACK (target)
  "Remove TARGET of the list of targets which they should not be tracked.
If no TARGET argument is specified, list the contents of `erc-track-exclude'."
  (when target
    (erc-with-server-buffer
      (let ((tracked (not (car (erc-member-ignore-case target erc-track-exclude)))))
 (if tracked
     (erc-display-line
      (erc-make-notice (format "%s is currently tracked!" target))
      'active)
   (setq erc-track-exclude (remove target erc-track-exclude))
   (erc-display-line
    (erc-make-notice (format "Now tracking %s" target))
    'active)))))
  t)

(defvar erc-channels-to-visit nil
  "Channels that have not yet been visited by erc-next-channel-buffer")
(defun erc-next-channel-buffer ()
  "Switch to the next unvisited channel. See erc-channels-to-visit"
  (interactive)
  (when (null erc-channels-to-visit)
    (setq erc-channels-to-visit
      (remove (current-buffer) (erc-channel-list nil))))
  (let ((target (pop erc-channels-to-visit)))
    (if target
    (switch-to-buffer target))))

;; don't show any of this
(setq erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))

(setq erc-max-buffer-size 20000)
(defvar erc-insert-post-hook)
(add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
(setq erc-truncate-buffer-on-save t)

(defadvice erc-display-prompt (after conversation-erc-display-prompt activate)
  "Insert last recipient after prompt."
  (let ((previous
         (save-excursion
           (if (and (search-backward-regexp (concat "^[^<]*<" erc-nick ">") nil t)
                    (search-forward-regexp (concat "^[^<]*<" erc-nick ">"
                                                   " *\\([^:]*: ?\\)") nil t))
               (match-string 1)))))
    ;; when we got something, and it was in the last 3 mins, put it in
    (when (and
           previous
           (> 180 (float-time
                   (time-since (get-text-property 0 'timestamp previous)))))
      (set-text-properties 0 (length previous) nil previous)
      (insert previous))))

#+end_src 
      
*** start-irc

#+begin_src emacs-lisp 

 (defun start-irc ()
   "Connect to IRC."
   (interactive)
   (erc-tls :server "irc.oftc.net" :port 6697
        :nick "ootput" :full-name "ootput")
   (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs" "#screen" "#ion")  ("oftc.net" "#debian")))
)

(setq erc-track-showcount t)

#+end_src 

** Download utils

#+begin_src emacs-lisp 

(require 'url)

(defun download-file (&optional url download-dir download-name)
  (interactive)
  (let ((url (or url
                 (read-string "Enter download URL: "))))
    (let ((download-buffer (url-retrieve-synchronously url)))
      (save-excursion
        (set-buffer download-buffer)
        ;; we may have to trim the http response
        (goto-char (point-min))
        (re-search-forward "^$" nil 'move)
        (forward-char)
        (delete-region (point-min) (point))
        (write-file (concat (or download-dir
                                "~/downloads/")
                            (or download-name
                                (car (last (split-string url "/" t))))))))))

#+end_src 

** Calendar
Embed location maps, with directions from home
*** General Settings
#+begin_src emacs-lisp 

  (setq calendar-latitude 40)
  (setq calendar-longitude -105)
  (setq calendar-location-name "Boulder, CO")

(setq calendar-intermonth-text
      '(propertize
        (format "%2d"
                (car
                 (calendar-iso-from-absolute
                  (calendar-absolute-from-gregorian (list month day year)))))
        'font-lock-face 'font-lock-function-name-face))

(require 'calendar)                                                                                                                                             
(defun display-a-month (day month year)                                                                                                                         
  (insert (format "%s\n" (calendar-date-string (list  month day year))))                                                                                        
  (if (< day 30)                                                                                                                                                
    (display-a-month (+ day 1) month year)))

#+end_src 

*** Calfw - A calendar framework for Emacs

#+begin_src emacs-lisp 

(require 'calfw)

(require 'calfw-org)

#+end_src 

** LDAP and bbdb

#+begin_src emacs-lisp 

(setq
 eudc-ldap-bbdb-conversion-alist (quote ((name . displayName) (net . mail) (address eudc-bbdbify-address Postaladdress "Office") (phone (eudc-bbdbify-phone telephoneNumber "Office")) (notes . title)))
 eudc-protocol (quote ldap)
 eudc-query-form-attributes (quote (name firstname email phone
 cuedupersonuuid Postaladdress)))

(setq eudc-server "directory.colorado.edu"
 ldap-host-parameters-alist
 '(("directory.colorado.edu" base "dc=colorado,dc=edu")))



(setq eudc-default-return-attributes nil
 eudc-strict-return-matches nil
 ldap-ldapsearch-args (quote ("-tt" "-LLL" "-x")))

(setq eudc-options-file "~/git/.emacs.d/.eudc-options")

#+end_src 

*** EUDC

#+begin_src emacs-lisp

(require 'ldap)
(require 'eudc)
(require 'imap)


(eudc-protocol-set 'eudc-inline-query-format
                   '((firstname)
                     (lastname)
                     (firstname lastname)
                     (net))
                    'bbdb)

(eudc-protocol-set 'eudc-inline-expansion-format
                   '("%s %s <%s>" firstname lastname net)
                   'bbdb)

(eudc-protocol-set 'eudc-inline-query-format
                   '(
                     (cn)
                     (cn cn)
                     (cn cn cn)
                     (Displayname)
                     (mail))
                   'ldap)


                   
(eudc-protocol-set 'eudc-inline-expansion-format
                   '("%s <%s>"  displayName mail)
                   'ldap)

(defun enz-eudc-expand-inline()
  (interactive)
  (move-end-of-line 1)
  (insert "*")
  (unless (condition-case nil
              (eudc-expand-inline)
            (error nil))
    (backward-delete-char-untabify 1))
  )

;; Adds some hooks

(eval-after-load "message"
  '(define-key message-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
(eval-after-load "sendmail"
  '(define-key mail-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
(eval-after-load "post"
  '(define-key post-mode-map (kbd "TAB") 'enz-eudc-expand-inline))

; Protocol local. A mapping between EUDC attribute names and corresponding
;; protocol specific names.  The following names are defined by EUDC and may be
;; included in that list: `name' , `firstname', `email', `phone'
(set eudc-protocol-attributes-translation-alist
     '(
       (fistname . Displayname)
       (name . cn)
       (email . mail)
       (phone . telephoneNumber)
       (title . title)
       )
     )

;; (provide 'dkh-directory)

#+end_src 

** Autoinstall

#+begin_src emacs-lisp :tangle no

(setq auto-install-update-emacswiki-package-name-when-startup nil
      auto-install-directory "~/.emacs.d/src/"
      auto-install-replace-confirm t
      auto-install-save-confirm t)

(require 'auto-install) ; auto update from wiki

#+end_src 

** bash completion

#+begin_src emacs-lisp 

(add-to-list 'load-path (expand-file-name "~/git/src/emacs-bash-completion"))

(require 'bash-completion)
(bash-completion-setup)

#+end_src 

** Macros

#+begin_src emacs-lisp 

(defun save-macro (name)                  
  "save a macro. Take a name as argument
   and save the last defined macro under 
   this name at the end of your .emacs"
   (interactive "SName of the macro :")  ; ask for the name of the macro    
   (kmacro-name-last-macro name)         ; use this name for the macro    
   (find-file (user-init-file))                   ; open ~/.emacs or other user init file 
   (goto-char (point-max))               ; go to the end of the .emacs
   (newline)                             ; insert a newline
   (insert-kbd-macro name)               ; copy the macro 
   (newline)                             ; insert a newline
   (switch-to-buffer nil))               ; return to the initial buffer

(defun init-macro-counter-default () "Set the initial counter to 1 and
  reset every time it's called.  To set to a different value call
  `kmacro-set-counter' interactively i.e M-x kmacro-set-counter."
  (interactive) (kmacro-set-counter 1))

(global-set-key (kbd "H-<f5>") 'init-macro-counter-default)
(global-set-key (kbd "M-<f5>") 'kmacro-insert-counter)

#+end_src 

** BBDB
#+begin_src emacs-lisp 

(setq bbdb-file "~/git/.emacs.d/.bbdb")           ;; keep ~/ clean; set before loading

(require 'bbdb-loaddefs "~/.emacs.d/src/bbdb/lisp/bbdb-loaddefs.el")

(require 'bbdb)

(bbdb-initialize 'gnus 'message)
(setq bbdb-accept-name-mismatch                 t
      bbdb-completion-display-record            nil
      bbdb-message-all-addresses                t
      bbdb-mua-update-interactive-p             '(create . query))

(defun my-alter-summary-map ()
; ....
  (local-set-key ":" 'bbdb-mua-display-records))

(add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)

(defun message-read-from-minibuffer (prompt &optional initial-contents)
  "Read from the minibuffer while providing abbrev expansion."
  (bbdb-completing-read-mails prompt initial-contents))

(bbdb-mua-auto-update-init 'gnus 'message)

;; don't display a continuously-updating BBDB window while in GNUS
(setq bbdb-pop-up-layout  nil)

;;; turn on the electric mode (t) for popup behavior
;; be disposable with SPC
(setq bbdb-electric nil)

(setq
         bbdb-mail-avoid-redundancy  t ;; always use full name
    bbdb-accept-name-mismatch 2)       ;; show name-mismatches 2 secs

(setq    bbdb-completion-list t                 ;; complete on anything
    ;; allow cycling of email addresses while completing them
    bbdb-complete-mail-allow-cycling t  ;; cycle through matches
                                             ;; this only works partially (bbdb3)
)

(setq bbdb-use-alternate-names t)

(setq
       bbdb/gnus-header-prefer-real-names t
       bbdb-check-postcode t
       ;;; if non-nil, pop a database record of every mail sender when
       ;; message is viewed. If a record for a mail message does not exist,
       ;; use : to create a new one. display vbls control the popup format
       bbdb/gnus-split-nomatch-function 'nnmail-split-fancy ; change from nnimap-split-fancy - dky
       bbdb/gnus-split-myaddr-regexp 'gnus-ignored-from-addresses
       bbdb-phone-style nil
       bbdb-mail-user-agent 'gnus)  ;; (bbdb3)

(setq
       bbdb-canonicalize-mail-function
       '(lambda (net)
         (let ((buf (get-buffer gnus-article-buffer)))
           (if buf
               (save-excursion
                 (goto-char (point-min))
                 (if (and (string-match "@public.gmane.org" net)
                          (re-search-forward (format "[^:,]*<%s>" net) (point-max) t))
                     (let ((ad (mail-extract-address-components (match-string 0)))
                           realnet)
                       (message "Found `%S' in headers! Doing realname search!" ad)
                       (and (car ad)
                            (setq realnet (bbdb-search-simple (car ad) nil))
                            (setq realnet (car (bbdb-record-net realnet)))
                            (setq net realnet))))
                 net))
           net))
)

;;        (add-hook 'message-setup-hook 'bbdb-get-mail-aliases) ;; bbdb 3
(add-hook 'message-setup-hook 'bbdb-mail-aliases) ; BBDB 3.x

(require 'bbdb-message)


(defun dkh/bbdb-name ()
  "function to bbdb-search name word at point"
  (interactive)
   (let (myresult)
    (setq myresult (thing-at-point 'word))
    (bbdb-search-name myresult)
    ))

;; no default area code to use when prompting for a new phone number
(setq bbdb-default-area-code nil)

;; default country to use if none is specified
(setq bbdb-default-country "USA")

;; desired number of lines in a GNUS pop-up BBDB window
;;    (setq bbdb-pop-up-window-size  1)
    (setq bbdb-pop-up-window-size  0.5)

;; default display layout
(setq bbdb-layout 'multi-line)

;; automatically add some text to the notes field of the BBDB record
    (add-hook 'bbdb-notice-mail-hook 'bbdb-auto-notes)


(set `bbdb-auto-notes-rules
   `(
;;("From" ("@colorado" . "University of Colorado"))
("CC" ("tmr" . "OIT Managed Services"))
("To" ("-vm@" . "VM mailing list"))
    ("Subject" ("sprocket" . "mail about sprockets")
               ("you bonehead" . "called me a bonehead"))
))


;; will cause the text "VM mailing list" to be added to the notes field
;; of the records corresponding to anyone you get mail from via one of the VM
;; mailing lists.


    ;; capture auto-notes
    (setq bbdb-auto-notes-alist
          ;; organization
          `(("Organization" (".*" Organization 0))

            ;; mailer
            ("User-Agent" (".*" mailer 0 t))  ;; t = overwrite
            ("X-Mailer" (".*" mailer 0 t))
            ("X-Newsreader" (".*" mailer 0 t))

            ;; X-Face bitmaps of the people
            ("x-face" ,(list (concat "[ \t\n]*\\([^ \t\n]*\\)"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?")
                             'face
                             "\\1\\3\\5\\7"))))

(defun dkh/toggle-bbdb-mua-update-interactive-p ()
  "function to toggle bbdb-mua-update-interactive-p"
  (interactive)
(lambda ()
                (when (y-or-n-p "BBDB update interactive? ")
    (cdr bbdb-mua-update-interactive-p)
    (car bbdb-mua-update-interactive-p)
)))

(setq rs-bbdb-ignored-from-list '(
                               "@public.gmane.org"
                                "post <at> gwene.org"
                                "post@gwene.org"
                                "bozo@dev.null.invalid"
                                "no.?reply"
                                "DAEMON"
                                "daemon"
                                "facebookmail"
                                "twitter"
                                "do-not-reply"
                                "lists.math.uh.edu"
                                "emacs-orgmode-confirm"
                         "-confirm"
"gnulist"
"privacy-noreply"
"-request@kgnu.org"
"confirm-nomail"
"noreply"
"webappsec-return"
"vinylisl"
"MAILER-DAEMON"
"noreply"
"mailman-owner"
))


(setq bbdb-ignore-message-alist
      `(("From" . , (regexp-opt rs-bbdb-ignored-from-list))))


#+end_src 

* Custom functions
** Push to mark no activate

#+begin_src emacs-lisp 

(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))
(global-set-key (kbd "C-,") 'push-mark-no-activate)

#+end_src 

** Toggle Chrome

#+begin_src emacs-lisp 

(defun dkh/toggle-chrome ()
  "Show/hide toolbar and menubar."
  (interactive)
  (menu-bar-mode)
  (when (window-system)
    (tool-bar-mode)))

#+end_src

** Handle MS-Word

#+begin_src emacs-lisp 

;; this seems to enable MS-Word documents
 (defun mm-inline-msword (handle)
   (let (text)
     (with-temp-buffer
       (mm-insert-part handle)
       (call-process-region (point-min) (point-max) "antiword" t t nil "-")
       (setq text (buffer-string)))
     (mm-insert-inline handle text)))

#+end_src 
     
** Switch or start

#+begin_src emacs-lisp 

;; stolen from old starter-kit
(defun switch-or-start (function buffer)
  "If the buffer is current, bury it, otherwise invoke the function."
  (if (equal (buffer-name (current-buffer)) buffer)
      (bury-buffer)
    (if (get-buffer buffer)
        (switch-to-buffer buffer)
      (funcall function))))

#+end_src 

** Open with sudo if necessary

#+begin_src emacs-lisp 

(defun find-alternative-file-with-sudo ()
    "Open current buffer as root!"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))

(global-set-key (kbd "C-x C-t") 'find-alternative-file-with-sudo)

#+end_src 

** Opacity
#+begin_src emacs-lisp 

(defun djcb-opacity-modify (&optional dec)
  "modify the transparency of the emacs frame; if DEC is t,
    decrease the transparency, otherwise increase it in 10%-steps"
  (let* ((alpha-or-nil (frame-parameter nil 'alpha)) ; nil before setting
          (oldalpha (if alpha-or-nil alpha-or-nil 100))
          (newalpha (if dec (- oldalpha 10) (+ oldalpha 10))))
    (when (and (>= newalpha frame-alpha-lower-limit) (<= newalpha 100))
      (modify-frame-parameters nil (list (cons 'alpha newalpha))))))

 ;; C-8 will increase opacity (== decrease transparency)
 ;; C-9 will decrease opacity (== increase transparency
 ;; C-0 will returns the state to normal
(global-set-key (kbd "H-8") '(lambda()(interactive)(djcb-opacity-modify)))
(global-set-key (kbd "H-9") '(lambda()(interactive)(djcb-opacity-modify t)))
(global-set-key (kbd "H-0") '(lambda()(interactive)
                               (modify-frame-parameters nil `((alpha . 100)))))

#+end_src 

** Bracket functions

#+begin_src emacs-lisp 
(defun forward-open-bracket ()
  "Move cursor to the next occurrence of left bracket or quotation mark."
  (interactive)
  (forward-char 1)
  (search-forward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  (backward-char 1)
  )

(defun backward-open-bracket ()
  "Move cursor to the previous occurrence of left bracket or quotation mark.."
  (interactive)
  (search-backward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  )

(defun forward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (search-forward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
 )

(defun backward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (backward-char 1)
  (search-backward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
  (forward-char 1)
  )

#+end_src 
  
** Point functions

#+begin_src emacs-lisp 

(defun get-point (symbol &optional arg)
 "get the point"
 (funcall symbol arg)
 (point)
)

(defun copy-thing (begin-of-thing end-of-thing &optional arg)
  "copy thing between beg & end into kill ring"
   (save-excursion
     (let ((beg (get-point begin-of-thing 1))
        (end (get-point end-of-thing arg)))
       (copy-region-as-kill beg end)))
)

(defun paste-to-mark(&optional arg)
  "Paste things to mark, or to the prompt in shell-mode"
  (let ((pasteMe 
    (lambda()
      (if (string= "shell-mode" major-mode)
        (progn (comint-next-prompt 25535) (yank))
      (progn (goto-char (mark)) (yank) )))))
   (if arg
       (if (= arg 1)
       nil
         (funcall pasteMe))
     (funcall pasteMe))
   ))

(defun copy-word (&optional arg)
 "Copy words at point into kill-ring"
  (interactive "P")
  (copy-thing 'backward-word 'forward-word arg)
  ;;(paste-to-mark arg)
)

;; (transient-mark-mode 1)

(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

#+end_src 

** Full screen function

#+begin_src emacs-lisp 

(defun toggle-fullscreen (&optional f)
  (interactive)
  (let ((current-value (frame-parameter nil 'fullscreen)))
       (set-frame-parameter nil 'fullscreen
                            (if (equal 'fullboth current-value)
                                (if (boundp 'old-fullscreen) old-fullscreen nil)
                                (progn (setq old-fullscreen current-value)
                                       'fullboth)))))

#+end_src 

** Insert date function

#+begin_src emacs-lisp 

(defun insert-date ()
"Insert date at point."
(interactive)
(insert (format-time-string "%d.%m.%Y %H:%M")))

#+end_src 

** dos 2 unix function(s)

#+begin_src emacs-lisp 

(defun dos-to-unix ()
  "Cut all visible ^M from the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\r" nil t)
      (replace-match ""))))

(defun unix-to-dos ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\n" nil t)
      (replace-match "\r\n"))))

#+end_src 

** rename file and buffer function

#+begin_src emacs-lisp 

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

#+end_src 

** Other functions

#+begin_src emacs-lisp 

(defun remove-dupes (list)
  (let (tmp-list head)
    (while list
      (setq head (pop list))
      (unless (equal head (car list))
        (push head tmp-list)))
    (reverse tmp-list)))

(defun assoc-replace (seq values)
  "Replace an element within an association list where the cars match."
  (mapcar (lambda (elem)
            (let* ((key (car elem))
                   (val (assoc key values)))
              (if val (cadr val) elem))) seq))

(defun duplicate-current-line ()
  (interactive)
  (beginning-of-line nil)
  (let ((b (point)))
    (end-of-line nil)
    (copy-region-as-kill b (point)))
  (beginning-of-line 2)
  (open-line 1)
  (yank)
  (back-to-indentation))

(defun duplicate-current-line (&optional n)
“duplicate current line, make more than 1 copy given a numeric argument”
(interactive “p”)
(save-excursion
(let ((nb (or n 1))
(current-line (thing-at-point ‘line)))
;; when on last line, insert a newline first
(when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
(insert “\n”))

;; now insert as many time as requested
(while (> n 0)
(insert current-line)
(setq n (- n 1))))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)

(defun set-longlines-mode ()
  (interactive)
  (text-mode)
  (longlines-mode 1))

(defun regex-replace (regex string)
  (goto-char (point-min))
  (while (re-search-forward regex nil t)
    (replace-match string)))

(defun string-repeat (str n)
  (let ((retval ""))
    (dotimes (i n)
      (setq retval (concat retval str)))
    retval))

;;;###autoload

(defun grab-url-at-point-my ()
  (interactive)
  (kill-new (thing-at-point 'url)))

;;;###autoload

(defun grab-email-my ()
  "Grab the next email in the buffer
  First posted by François Fleuret <francois.fleuret@inria.fr>..
improved by many.."
  (interactive)
  (re-search-forward "[^ \t\n]+@[^ \t\n]+")
  (copy-region-as-kill (match-beginning 0) (match-end 0))
  )

(defun duplicate-line-or-region (&optional n)
  "Duplicate current line, or region if active.
With argument N, make N copies.
With negative N, comment out original line and use the absolute value."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (save-excursion
      (let ((text (if use-region        ;Get region if active, otherwise line
                      (buffer-substring (region-beginning) (region-end))
                    (prog1 (thing-at-point 'line)
                      (end-of-line)
                      (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                          (newline))))))
        (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
          (insert text))))
    (if use-region nil                  ;Only if we're working with a line (not a region)
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (if (> 0 n)                             ;Comment out original with negative arg
            (comment-region (line-beginning-position) (line-end-position)))
        (forward-line 1)
        (forward-char pos)))))

(defun increment (n) (interactive "p")
 ;; Increment the number after point.  With an argument, add that much.
 (let (val)
   (delete-region
    (point)
    (progn
      (setq val (read (current-buffer)))
      (if (not (numberp val)) (error "Not in front of a number"))
      (point)))
   (insert (int-to-string (+ val n)))))
(global-set-key "\C-c+" 'increment)

;; Macro way
;; from insert-kbd-macro
(fset 'ucase_between_quotes
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([18 34 67108896 19 34 19 24 21] 0 "%d")) arg)))

;;;  Create a thing type for double-quote delimited "string"
(put 'string 'bounds-of-thing-at-point
     (lambda () (thing-at-point-bounds-of-delimited-thing-at-point "\"")))

(defun dkh/select_q_string_region ()
  "Select the region of string at point"
  (interactive)
  (thing-region "string"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Get IP Address
;; http://emacs-fu.blogspot.com/2009/05/getting-your-ip-address.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun get-ip-address (&optional dev)
  "get the IP-address for device DEV (default: eth0)"
  (interactive)
  (let ((dev (if dev dev "eth0")))
    (format-network-address (car (network-interface-info dev)) t)))

;; http://snipplr.com/view.php?codeview&id=34032

(defun get-ip-addresses ()
  "Returns the current system IPv4 addresses as a list of
strings"
  (let* ((start 0)
; (match-positions ())
(ip-re "[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?")
;; The rest of these variables try to make this platform agnostic.
;; Add more on to the cond statements if you need
(ipconfig (cond ((eq system-type 'windows-nt)
"ipconfig")
((eq system-type 'gnu/linux)
"/sbin/ifconfig")
((eq system-type 'darwin)
"/sbin/ifconfig")
(t (error "Don't know how to get-ip-address for %s"
system-type))))
(line-re (cond ((eq system-type 'windows-nt)
"IPv4 Address.*")
((eq system-type 'gnu/linux)
(concat "inet addr:" ip-re))
((eq system-type 'darwin)
(concat "inet " ip-re))
(t (error "Don't know how regex out ip line for %s"
system-type))))
;; I lied, not all of the rest of the variables are to make it
;; platform agnostic. This is where we grab the output
(output (shell-command-to-string ipconfig)))

    ;; The inner loop is a bit funky since I can't seem to get it to behave
    ;; exactly like Common Lisp
    (loop for pos in
(loop named inner
with match-positions = ()
do (let ((ret (string-match line-re output start)))
(if ret
(setq start (1+ ret))
(return-from inner match-positions))
(setq match-positions
(append match-positions (list ret)))))
collect (progn
(string-match ip-re output pos)
(match-string 0 output)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Reload current file with position saved
;; http://www.thekidder.net/2008/10/21/emacs-reload-file/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun reload-file ()
  (interactive)
  (let ((curr-scroll (window-vscroll)))
    (find-file (buffer-name))
    (set-window-vscroll nil curr-scroll)
    (message "Reloaded file")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Edit files as root
;; http://nflath.com/2009/08/tramp/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sudo-edit (&optional arg)
  (interactive "p")
  (if arg
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(defun sudo-edit-current-file ()
  (interactive)
  (let ((pos (point)))
    (find-alternate-file
     (concat "/sudo:root@localhost:" (buffer-file-name (current-buffer))))
    (goto-char pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rename a file and the buffer it's in at the same time
;; Via yeggeconf http://sites.google.com/site/steveyegge2/my-dot-emacs-file
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file name new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Abort minibuffer when mousing
;; http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun stop-using-minibuffer ()
  "kill the minibuffer"
  (when (>= (recursion-depth) 1)
    (abort-recursive-edit)))

(add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Random crap
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; http://www.emacswiki.org/emacs/ElispCookbook
(defun qdot/filter (condp lst)
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

;; http://stackoverflow.com/questions/2238418/emacs-lisp-how-to-get-buffer-major-mode
(defun qdot/buffer-mode (buffer-or-string)
  "Returns the major mode associated with a buffer."
  (save-excursion
     (set-buffer buffer-or-string)
     major-mode))

(defun qdot/open-in-browser()
  (interactive)
  (let ((filename (buffer-file-name)))
    (browse-url (concat "file://" filename))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun shell-current-directory ()
  "Opens a shell in the current directory"
  (interactive)
  (shell (concat "shell-" default-directory "-shell" )))

;; http://blog.tuxicity.se/elisp/emacs/2010/11/16/delete-file-and-buffer-in-emacs.html
(defun delete-this-buffer-and-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; http://www.reddit.com/r/emacs/comments/jfrqm/what_does_your_tab_key_do/
(defun smart-tab ()
  "If mark is active, indents region. Else if point is at the end of a symbol,
expands it. Else indents the current line. Acts as normal in minibuffer."
  (interactive)
  (cond (mark-active (indent-region (region-beginning) (region-end)))
        ((and (looking-at "\\_>") (not (looking-at "end")))
         (hippie-expand nil))
        (t (indent-for-tab-command))))

(defun dkh-shell-with-name (name)
  (interactive "sName: ")
  "Creates a shell with name given by the first argument, and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*eshell-" (persp-name persp-curr) "-" name "*")))
       (localdir name))
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (eshell)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*eshell-" (persp-name persp-curr) "-" name "*")))))))


(defun dkh-eshell-macs ()
  (interactive)
  "Creates a tool config shell and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*eshell-" (persp-name persp-curr) "-tool-config*")))
        (default-directory "~/git/ewax"))
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t 
            (progn
              (eshell t)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*eshell-" (persp-name persp-curr) "-tool-config*")))))))

(message (concat "0 " (buffer-name) "... Done"))

(defun cat-command ()
  "A command for cats."
  (interactive)
  (require 'animate)
  (let ((mouse "
           ___00
        ~~/____'>
          \"  \"")
        (h-pos (floor (/ (window-height) 2)))
        (contents (buffer-string))
        (mouse-buffer (generate-new-buffer "*mouse*")))
    (save-excursion
      (switch-to-buffer mouse-buffer)
      (insert contents)
      (setq truncate-lines t)
      (animate-string mouse h-pos 0)
      (dotimes (_ (window-width))
        (sit-for 0.01)
        (dotimes (n 3)
          (goto-line (+ h-pos n 2))
          (move-to-column 0)
          (insert " "))))
    (kill-buffer mouse-buffer)))

#+end_src 

** toggle line spacing function

#+begin_src emacs-lisp 

(defun toggle-line-spacing ()
  "Toggle line spacing between no extra space to extra half line height."
  (interactive)
  (if (eq line-spacing nil)
      (setq-default line-spacing 0.5) ; add 0.5 height between lines
    (setq-default line-spacing nil)   ; no extra heigh between lines
    )
  (redraw-display))

#+end_src 

** Insert filename function

#+begin_src emacs-lisp 

(defun my-insert-file-name (filename &optional args)
  "Insert name of file FILENAME into buffer after point.

Prefixed with \\[universal-argument], expand the file name to
its fully canocalized path.  See `expand-file-name'.

Prefixed with \\[negative-argument], use relative path to file
name from current directory, `default-directory'.  See
`file-relative-name'.

The default with no prefix is to insert the file name exactly as
it appears in the minibuffer prompt."
  ;; Based on insert-file in Emacs -- ashawley 20080926
  (interactive "*fInsert file name: \nP")
  (cond ((eq '- args)
         (insert (file-relative-name filename)))
        ((not (null args))
         (insert (expand-file-name filename)))
        (t
         (insert filename))))

(global-set-key (kbd "C-H-f") 'my-insert-file-name)

(autoload 'ffap-guesser "ffap")
(autoload 'ffap-read-file-or-url "ffap")

(defun my-replace-file-at-point (currfile newfile)
  "Replace CURRFILE at point with NEWFILE.

When interactive, CURRFILE will need to be confirmed by user
and will need to exist on the file system to be recognized,
unless it is a URL.

NEWFILE does not need to exist.  However, Emacs's minibuffer
completion can help if it needs to be.

Based on `ffap'."
  (interactive
   (let ((currfile (ffap-read-file-or-url "Replace filename: "
                                          (ffap-guesser))))
     (list currfile
           (ffap-read-file-or-url (format "Replace `%s' with: "
                                          currfile) currfile))))
  (save-match-data
    (if (or (looking-at (regexp-quote currfile))
            (let ((filelen (length currfile))
                  (opoint (point))
                  (limit (+ (point) (length currfile))))
              (save-excursion
                (goto-char (1- filelen))
                (and (search-forward currfile limit
                                     'noerror)
                     (< (match-beginning 0) opoint))
                     (>= (match-end 0) opoint))))
        (replace-match newfile)
      (error "No file at point to replace"))))

(global-set-key (kbd "C-H-v") 'my-replace-file-at-point)

(message "0 dkh-insert-filename... Done")

(defun get-relative-line-content (num)
  "Return the string content of line `num' relative to the current line"
  (save-excursion
    (forward-line num)
    (buffer-substring-no-properties
     (line-beginning-position) (line-end-position))))

(defun insert-line-same ()
  "Insert the content up to the first difference of the previous two lines."
  (interactive)
  (let* ((line1 (get-relative-line-content -2))
    (line2 (get-relative-line-content -1))
      (beg (current-column))
      (end (compare-strings line1 beg nil line2 beg nil)))
    (insert-string
     (substring line1 beg
            (if (integerp end)
                (+ beg (- (abs end) 1))
              (length line1))))))

#+end_src

* Value added packages
** Lorem Ipsum

Somtimes I just need some filler text. And it’s silly typing it out
myself when I’m using a thermonuclear text editor.

Via EmacsWiki, I discover lorem-ipsum.el. I toss it into my elisp
folder and set up some autoloads so that it will be loaded when
needed.

#+begin_src emacs-lisp 

(autoload 'Lorem-ipsum-insert-paragraphs "lorem-ipsum" "" t)
(autoload 'Lorem-ipsum-insert-sentences "lorem-ipsum" "" t)
(autoload 'Lorem-ipsum-insert-list "lorem-ipsum" "" t)

#+end_src 

** Use pastebin.com

#+begin_src emacs-lisp 

(require 'pastebin)

#+end_src 

** Dictem

#+begin_src emacs-lisp 

(setq dictem-server "localhost")
(require 'dictem)

;;  http://www.myrkr.in-berlin.de/dictionary/

; SEARCH = MATCH + DEFINE
; Ask for word, database and search strategy
; and show definitions found

; SHOW DB
; Show a list of databases provided by DICT server
(global-set-key "\C-c\M-b" 'dictem-run-show-databases)

(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)
(define-key dictem-mode-map [return] 'dictem-run-search)

(dictem-initialize)

(defun my-dictem-run-search ()
  "Look up definitions for word at point."
  (interactive)
  (dictem-run 'dictem-base-search "*" (thing-at-point 'word) ".")
  (other-window 1))

;;;###autoload

(defun rgr/synonyms()
 (interactive)
 (let* ((default (thing-at-point 'symbol))
        (term (read-string (format "Synonyms for (%s): "
                                   default) default)))
   (dictem-run
    'dictem-base-search
    "moby-thes" term "exact")))

(define-key mode-specific-map [?S] 'rgr/synonyms)

(dictem-initialize)

;; junk

;; moby-thes is not a valid database, use -D for a list
;; No matches found for "junk"

    ;; For creating hyperlinks on database names and found matches.
    ;; Click on them with `mouse-2'
(add-hook 'dictem-postprocess-match-hook
         'dictem-postprocess-match)

    ;; For highlighting the separator between the definitions found.
    ;; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-separator)

    ;; For creating hyperlinks in dictem buffer that contains definitions.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-hyperlinks)

    ;; For creating hyperlinks in dictem buffer that contains information
    ;; about a database.
(add-hook 'dictem-postprocess-show-info-hook
         'dictem-postprocess-definition-hyperlinks)

(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-each-definition)



(define-key flyspell-mode-map (kbd "C-+") 'flyspell-check-previous-highlighted-word)
(define-key flyspell-mode-map (kbd "C-#") 'flyspell-auto-correct-previous-word)
(define-key flyspell-mode-map (kbd "S-<f2>") 'ispell-word)
(define-key flyspell-mode-map (kbd "C-<f2>") 'flyspell-auto-correct-previous-word)

(setq synonyms-file "~/.emacs.d/thesaurus/mthesaur.txt")
(setq synonyms-cache-file "~/.emacs.d/thesaurus/syn.cache")
(setq synonyms-match-more-flag nil)

(require 'synonyms)
(define-key mode-specific-map [?S] 'synonyms)

(define-key mode-specific-map [?s] 'dictem-run-search)


(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)

; For creating hyperlinks on database names
                                      ; and found matches.
                                      ; Click on them with mouse-2
(add-hook 'dictem-postprocess-match-hook
        'dictem-postprocess-match)

        ; For highlighting the separator between the definitions found.
        ; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook 
        'dictem-postprocess-definition-separator)

        ; For creating hyperlinks in dictem buffer
                                      ; that contains definitions.
(add-hook 'dictem-postprocess-definition-hook 
        'dictem-postprocess-definition-hyperlinks)

        ; For creating hyperlinks in dictem buffer
        ; that contains information about a database.
(add-hook 'dictem-postprocess-show-info-hook
        'dictem-postprocess-definition-hyperlinks)


#+end_src 

** Identi.ca mode

#+begin_src emacs-lisp 

(require 'identica-mode)

(require 'oauth2)

(autoload 'identica-mode "identica-mode" nil t)
(setq identica-auth-mode "oauth2")

(global-set-key "\C-cip" 'identica-update-status-interactive)

(global-set-key "\C-cid" 'identica-direct-message-interactive)

;; secrets.el.gpg
(setq identica-username "username")

#+end_src 

** W3m

*** For Gnus
#+begin_src emacs-lisp 

;; (setq load-path (cons "/usr/share/emacs/site-lisp/w3m/" load-path))
(require 'w3m)


;;             (defun playwav (url)
;;               (interactive)
;;               (message "url is %s" url)
;;               (w3m-view-this-url url)
;;               )

(setq mm-text-html-renderer 'w3m)


;;(define-key gnus-article-mode-map (kbd "M-w") 'org-w3m-copy-for-org-mode)

(define-key gnus-article-mode-map (kbd "C-c C-x M-w") 'org-w3m-copy-for-org-mode)

#+end_src 



#+begin_src emacs-lisp 

(setq apropos-url-alist
      '(("^gw?:? +\\(.*\\)" . ;; Google Web 
         "http://www.google.com/search?q=\\1")

        ("^g!:? +\\(.*\\)" . ;; Google Lucky
         "http://www.google.com/search?btnI=I%27m+Feeling+Lucky&q=\\1")
        
        ("^gl:? +\\(.*\\)" .  ;; Google Linux 
         "http://www.google.com/linux?q=\\1")
        
        ("^gi:? +\\(.*\\)" . ;; Google Images
         "http://images.google.com/images?sa=N&tab=wi&q=\\1")

        ("^gg:? +\\(.*\\)" . ;; Google Groups
         "http://groups.google.com/groups?q=\\1")

        ("^gd:? +\\(.*\\)" . ;; Google Directory
         "http://www.google.com/search?&sa=N&cat=gwd/Top&tab=gd&q=\\1")

        ("^gn:? +\\(.*\\)" . ;; Google News
         "http://news.google.com/news?sa=N&tab=dn&q=\\1")

        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(\\w+://.*\\)" . ;; Google Translate URL
         "http://translate.google.com/translate?langpair=\\1|\\2&u=\\3")
        
        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . ;; Google Translate Text
         "http://translate.google.com/translate_t?langpair=\\1|\\2&text=\\3")

        ("^/\\.$" . ;; Slashdot 
         "http://www.slashdot.org")

        ("^/\\.:? +\\(.*\\)" . ;; Slashdot search
         "http://www.osdn.com/osdnsearch.pl?site=Slashdot&query=\\1")        
        
        ("^fm$" . ;; Freshmeat
         "http://www.freshmeat.net")

        ("^ewiki:? +\\(.*\\)" . ;; Emacs Wiki Search
         "http://www.emacswiki.org/cgi-bin/wiki?search=\\1")
 
        ("^ewiki$" . ;; Emacs Wiki 
         "http://www.emacswiki.org")

        ("^arda$" . ;; The Encyclopedia of Arda 
         "http://www.glyphweb.com/arda/")
         
         ))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))

(add-to-list 'apropos-url-alist '("^dpi:? +\\(.*\\)" . "http://api.drupal.org/api/search/7/\\1")) ;; Drupal API default to 7, api number if specified

(defun browse-apropos-url (text &optional new-window)
  (interactive (browse-url-interactive-arg "Location: "))
  (let ((text (replace-regexp-in-string 
               "^ *\\| *$" "" 
               (replace-regexp-in-string "[ \t\n]+" " " text))))
    (let ((url (assoc-default 
                text apropos-url-alist 
                '(lambda (a b) (let () (setq __braplast a) (string-match a b)))
                text)))
      (browse-url (replace-regexp-in-string __braplast url text) new-window))))

(defun browse-apropos-url-on-region (min max text &optional new-window)
  (interactive "r \nsAppend region to location: \nP")
  (browse-apropos-url (concat text " " (buffer-substring min max)) new-window))

;;(require 'browse-apropos-url)
;; (provide 'browse-url)



(defun rgr/browse-url (arg &optional url)
  "Browse the URL passed. Use a prefix arg for external default browser else use default browser which is probably W3m"
  (interactive "P")
  (setq url (or url (w3m-url-valid (w3m-anchor))
  (browse-url-url-at-point) 
(thing-at-point 'word)
))
  (if arg
      (when url (browse-url-default-browser url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))


(defun rgr/google(term)
  "Call google search for the specified term. Do not call if string is zero length."
  (let ((url (if (zerop (length term)) "http://www.google.com " (concat "gw: " term))))
    (browse-apropos-url url)))

(defun rgr/google-search-prompt()
  (interactive)
  (rgr/google (read-string "Google the web for the following phrase :
  "
(thing-at-point 'word)
)))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))


(defun rgr/call-google-translate (langpair prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word) )
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat (if (string-match " " thing) (quote "gt")(quote "googledict")) " " langpair " " thing))))

(defun rgr/browse-apropos-url (prefix prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word))
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat prefix " " thing))))

;; Search Google at point:
(defun my-search-google (w)
  "Launch google on the Word at Point"
  (interactive
   (list (let* ((word (thing-at-point 'symbol))
                (input (read-string (format "Google%s: " 
                                (if (not word) "" (format " (default %s)" word))))))
           (if (string= input "") (if (not word) 
                       (error "No keyword to search given") word) input) ;sinon input
           )))
  (browse-url (format "http:/www.google.com/search?q=%s" w))
  )

;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.


(defun pm/region-or-word (prompt)
  "Read a string from the minibuffer, prompting with PROMPT.
If `transient-mark-mode' is non-nil and the mark is active,
it defaults to the current region, else to the word at or before
point. This function returns a list (string) for use in `interactive'."
  (list (read-string prompt (or (and transient-mark-mode mark-active
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end)))
                            (current-word))))) 
(defun pm/google (string)
  "Ask a WWW browser to google string.
Prompts for a string, defaulting to the active region or the current word at
or before point."
  (interactive (pm/region-or-word "Google: "))
  (browse-url (concat "http://google.com/search?num=100&q=" string)))


(setq w3m-use-cookies t)

(setq w3m-coding-system 'utf-8
      w3m-file-coding-system 'utf-8
      w3m-file-name-coding-system 'utf-8
      w3m-input-coding-system 'utf-8
      w3m-output-coding-system 'utf-8
      w3m-terminal-coding-system 'utf-8)

(require 'org-w3m)

(setq browse-url-new-window-flag t)

(setq browse-url-browser-function 'w3m-browse-url-other-workgroup)

(defun w3m-browse-url-other-workgroup (url &optional newwin)
  (let ((w3m-pop-up-windows t))
   (dkh-persp/w3m)
    (w3m-browse-url url newwin)))

(setq browse-url-generic-program "conkeror")

(defun rgr/browse (url)
  "If prefix is specified use the system default browser else use the configured emacs one"
  (if current-prefix-arg
;;      (when url (browse-url-default-browser url))
      (when url (browse-url-generic url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))

(defun rgr/browse-url (&optional url)
  "browse the url passed in"
  (interactive)
  (setq url (or url (w3m-url-valid (w3m-anchor)) (browse-url-url-at-point) (region-or-word-at-point)))
  (setq url (read-string (format "Url \"%s\" :" url) url nil url))
  (rgr/browse url))

(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key (kbd "<f4>") 'rgr/browse-url)

(require 'webjump)

(global-set-key [H-f2] 'webjump)
(setq webjump-sites
(append '(
("Java API" .
[simple-query "www.google.com" "http://www.google.com/search?hl=en&as_sitesearch=http://java.sun.com/javase/6/docs/api/&q=" ""])
("Stack Overflow" . "www.stackoverlow.com")
("Pop's Site"   . "www.joebob-and-son.com/")

)
      webjump-sample-sites))

(setq
           w3m-session-file "~/.emacs.d/.w3m-session"
)

 (defun w3m-add-keys ()
   (define-key w3m-mode-map "S" 'w3m-session-save)
   (define-key w3m-mode-map "L" 'w3m-session-load))
 (add-hook 'w3m-mode-hook 'w3m-add-keys)

(defun my-w3m-rename-buffer (url)
  "Renames the current buffer to be the current URL"
  (rename-buffer url t))
(add-hook 'w3m-display-hook 'my-w3m-rename-buffer)

(setq w3m-default-directory "~/.emacs.d/.w3m")

(message "0 dkh-w3m... Done")

(defun sacha/toggle-w3m ()
  (interactive)
  (let ((list (buffer-list))
        found
        (from-w3m (equal major-mode 'w3m-mode)))
    (while list
      (when (with-current-buffer (car list)
              (if from-w3m
                  (not (equal major-mode 'w3m-mode))
                (equal major-mode 'w3m-mode)))
        (setq found (car list))
        (pop-to-buffer (car list))
        (setq list nil))
      (setq list (cdr list)))
    (unless (or from-w3m found)
      (call-interactively 'w3m))))

;; http://www.mit.edu/afs/sipb/contrib/emacs/packages/w3m_el-1.2.8/w3m-filter.el
(defun sacha/w3m-filter-google (url &rest ignore)
  "Add <LINK> tag to search results of www.google.com."
  (goto-char (point-max))
  (let ((next (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_next.gif"
                     nil t)
                (match-string 1)))
        (prev (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_previous.gif"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

(defun sacha/w3m-filter-clientcopia (url &rest ignore)
  "Add <LINK> tag to search results of www.clientcopia.com."
  (goto-char (point-max))
  (let* ((next (when (re-search-backward
                     "\\(quotes.php.id=[0-9]+\\).*NEXT"
                     nil t)
                (match-string 1)))
         (prev (when (re-search-backward
                     "<a href=\\(quotes.php.id=[0-9]+\\).*BACK"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

;; Guessed
(defun w3m-filter-find-relationships (url next previous)
  "Add <LINK> tags if they don't yet exist."
  (let ((case-fold-search t))
    (goto-char (point-max))
    (when (re-search-backward next nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-next-url (match-string 1))))
    (when (re-search-backward previous nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-previous-url (match-string 1))))))

(defun w3m-download-with-wget ()
  (interactive)
  (let ((url (or (w3m-anchor) (w3m-image))))
    (if url
        (let ((proc (start-process "wget" (format "*wget %s*" url)
                                   "wget" "-x" "--passive-ftp" "-nv"
                                   "-P" "/home/sacha/notebook/mirrors" url)))
          (with-current-buffer (process-buffer proc)
            (erase-buffer))
          (set-process-sentinel proc (lambda (proc str)
                                       (message "wget download done"))))
      (message "Nothing to get"))))

(defun sacha/w3m-setup-keymap ()
  "Use my heavily customized map."
  (interactive)
  ;; Undefine this key and use the advice instead so that my ido doesn't get
  ;; overridden
  (define-key w3m-mode-map (kbd "C-x b") nil)
  (define-key w3m-mode-map "C" 'w3m-print-this-url)
  (define-key w3m-mode-map "a" 'sacha/delicious-url)
  (define-key w3m-mode-map "A" 'w3m-bookmark-add-current-url)
  (define-key w3m-mode-map "w" 'w3m-download-with-wget)
  (define-key w3m-mode-map "d" 'w3m-download-with-wget)
  (define-key w3m-mode-map "D" 'w3m-download-this-url)
  ;; Do not override my ever so handy ERC binding
  (define-key w3m-mode-map (kbd "C-c C-SPC") nil)
  (define-key w3m-mode-map "m" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "M" 'sacha/w3m-mirror-link)
  ;; I use search much more often than the context history list, although
  ;; context is still cool. 
  (define-key w3m-mode-map "!" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "s" 'w3m-search)
  (define-key w3m-mode-map "h" 'w3m-history)
  (define-key w3m-mode-map "t" 'w3m-scroll-down-or-previous-url)
  (define-key w3m-mode-map "n" 'w3m-scroll-up-or-next-url)
  ;; I don't often w3m to edit pages, so I'm borrowing o and e (right
  ;; below , / . for tab navigation) for page navigation instead.
  (define-key w3m-mode-map "o" 'w3m-view-previous-page)
  (define-key w3m-mode-map "e" 'w3m-view-next-page)
  ;; i is a more useful mnemonic for toggling images
  (define-key w3m-mode-map "i" 'w3m-toggle-inline-image)
  (define-key w3m-mode-map "I" 'w3m-toggle-inline-images)
  ;; and X for closing the buffer
  (define-key w3m-mode-map "X" 'w3m-delete-buffer)
  (define-key w3m-mode-map "x" 'w3m-delete-buffer)
  (define-key w3m-mode-map "z" 'w3m-delete-buffer)
  ;; and b for bookmarks
  (define-key w3m-mode-map "b" 'w3m-bookmark-view)
  ;; I don't use the Qwerty keymap, so hjkl is useless for me
  ;; I'll use HTNS, though
  (define-key w3m-mode-map "H" 'backward-char)
  (define-key w3m-mode-map "T" 'previous-line)
  (define-key w3m-mode-map "N" 'next-line)
  (define-key w3m-mode-map "S" 'forward-char)
  ;; Browse in new sessions by default
  (define-key w3m-mode-map (kbd "RET") 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map [(shift return)] 'w3m-view-this-url)
  (define-key w3m-mode-map "g" 'w3m-goto-url)
  (define-key w3m-mode-map "G" 'w3m-goto-url-new-session)
  ;; f for forward? I want to be able to follow links without removing
  ;; most of my fingers from home row. My fingers are too short to hit
  ;; Enter.
  (define-key w3m-mode-map "f" 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map "F" 'w3m-view-this-url)
  ;; Use cursor keys to scroll
  (define-key w3m-mode-map [(left)] 'backward-char)
  (define-key w3m-mode-map [(right)] 'forward-char)
  (define-key w3m-mode-map [(shift left)] 'w3m-shift-right)
  (define-key w3m-mode-map [(shift right)] 'w3m-shift-left)
  ;; Which means I can now use , and . to switch pages
  (define-key w3m-mode-map "." 'w3m-next-buffer)
  (define-key w3m-mode-map "," 'w3m-previous-buffer)
  ;; IBM stuff
  (define-key w3m-mode-map "i" nil)
  (define-key w3m-mode-map "ib" 'sacha/ibm-blog)
  (define-key w3m-mode-map "id" 'sacha/dogear-url)
  (define-key w3m-mode-map "f" 'sacha/w3m-open-in-firefox)

  )

(setq w3m-keep-arrived-urls 5000)
(add-hook 'w3m-mode-hook 'sacha/w3m-setup-keymap)
;;(sacha/w3m-setup-keymap)

(defun sacha/w3m-open-in-firefox ()
  (interactive)
  (browse-url-firefox w3m-current-url))

(eval-after-load 'w3m
  '(progn
     (define-key w3m-mode-map "q" 'w3m-previous-buffer)
     (define-key w3m-mode-map "w" 'w3m-next-buffer)
     (define-key w3m-mode-map "x" 'w3m-close-window)))

#+end_src 

** Bittlebee

*** [[http://emacs-fu.blogspot.com/2012/03/social-networking-with-bitlbee-and-erc.html][social networking with bitlbee and erc]]

#+begin_src emacs-lisp 

(defun i-wanna-be-social ()
  "Connect to IM networks using bitlbee."
  (interactive)
  (erc :server "localhost" :port 6667 :nick "my_nick")
)

(setq dkh-bitlebee-password "password")

(defun bitlbee-identify ()
  (when (and (string= "localhost" erc-session-server)
          (string= "&bitlbee" (buffer-name)))
    (erc-message "PRIVMSG" (format "%s identify user secretpassword"
                             (erc-default-target)
                             dkh-bitlebee-password))))

(add-hook 'erc-join-hook 'bitlbee-identify)

#+end_src 

*** The ICQ white pages

Ever wondered what this 938748324 person is that sends messages to
you. AFAIK bitlbee has no builtin support to query the white pages of
ICQ, therefore i quickly hacked up this one:

#+begin_src emacs-lisp 

(defun erc-cmd-ICQWHOIS (uin)
  "Queries icq-user with UIN `uin', and returns the result."
  (let* ((result (myerc-query-icq-user uin))
         (fname (cdr (assoc 'fname result)))
         (lname (cdr (assoc 'lname result)))
         (nick (cdr (assoc 'nick result))))
    (erc-display-message nil 'notice (current-buffer) (format "%s (%s %s)" nick fname lname))))

#+end_src 

* Programming (IDE)
** Magit

#+begin_src emacs-lisp 

(require 'magit)

(setq magit-repo-dirs (quote
(
        "/home/user/git/project"
        "/home/user/git/project2"
        "/su:user@localhost:/home/www/project1"
)))

#+end_src 

** Comment Box

In a [[http://irreal.org/blog/?p%3D371#comment-1543][comment]] to my [[http://irreal.org/blog/?p%3D371][Emacs comment-box Revisited]] post, Aaron showed me a
nice way to deal with the boundaries of expanding regions. Recall that
in that post I wanted to pad the first line of a comment out to the
fill column so that comment-box would draw the box across the whole
width (more or less) of the window. The problem was that adding those
blanks increased the size of the region so the character number of the
end of the region was no longer correct. In my code that was easily
fixed because I could use (point-max) to locate the end of the region
since I had narrowed the buffer to the region.

Aaron’s way of handling this is nice because it feels less ad hoc and
because it works for any position in the buffer not just the beginning
or end. The idea is to use a marker to point at the end of the
region. Conceptually, a marker is just like a position (that is a
character index into the buffer) but it has the nice property that if
you change the size of the buffer, the marker is adjusted when
necessary. It’s as if you planted a flag at the position and the flag
moves as the buffer expands or contracts.

Here’s what the revised code looks like

#+begin_src emacs-lisp 
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

#+end_src 

** Compilation settings

#+begin_src emacs-lisp 

(setq compilation-scroll-output 1)

;;; Shut up compile saves
(setq compilation-ask-about-save nil)
;;; Don't save *anything*
(setq compilation-save-buffers-predicate '(lambda () nil))

#+end_src 

** CSS

#+begin_src emacs-lisp 

(add-hook 'css-mode-hook 'rainbow-mode)

#+end_src 

** camelCase

You can set emacs so that word moving commands will move cursor into
between CamelCaseWords. (word deletion behavior also changes
accordingly.)

To toggle it globally, call “global-subword-mode”. To set it for
current file only, call “subword-mode”. (subword mode is available in
Emacs 23.2)

To set it permanently, put one of the following in your emacs init
file:

#+begin_src emacs-lisp 

(subword-mode 1) ; 1 for on, 0 for off
(global-subword-mode 1) ; 1 for on, 0 for off

#+end_src 

** Whitespace

#+begin_src emacs-lisp 

(require 'whitespace)
(global-set-key (kbd "C-c w") 'whitespace-mode)
(global-set-key (kbd "C-c W") 'whitespace-toggle-options)
(setq whitespace-line-column 80
      whitespace-style '(tabs trailing lines-tail))
(set-face-attribute 'whitespace-line nil
                    :background "red1"
                    :foreground "yellow"
                    :weight 'bold)

;; face for Tabs
(set-face-attribute 'whitespace-tab nil
                    :background "red1"
                    :foreground "yellow"
                    :weight 'bold)
#+end_src 

** Programming languages

#+begin_src emacs-lisp 

(require 'js-mode-expansions)
(require 'html-mode-expansions)
(require 'css-mode-expansions)

#+end_src 

** Eclim
         
#+begin_src emacs-lisp :tangle no

(setq eclim-auto-save t) ;; very important (global-eclim-mode)

#+end_src 

** Eproject

(require 'eproject)
(require 'eproject-extras)

(define-project-type web (generic)
;;  (look-for "plan.org")
  (look-for "admin.php")
  :relevant-files ("\\.php$" "\\.js$" "\\.org$" "\\.sql$" "\\.css$" "authinfo" "vhost"))

(add-hook 'web-project-file-visit-hook '(lambda ()
                      (ignore-errors
                        (message "Web Project : %s" eproject-root)
                        )))

(define-project-type emacs-config (generic)
  (look-for "starter-kit.org")
  :relevant-files ("\\.el$" "\\.org$" "\\.gpg$"))

(add-hook 'emacs-config-project-file-visit-hook '(lambda ()
                           (ignore-errors
                             (message "Emacs Configuration")
                             )))

;;  (define-project-type php-web (generic)
;;    (look-for "plan.org")
;;    :relevant-files ("\\.php$" "\\.css$" "authinfo" "vhost"))

;;  (add-hook 'php-web-project-file-visit-hook '(lambda ()
;;    (ignore-errors
;;      (message "PHP-WEB")
;;      )))

(defmacro .emacs-curry (function &rest args)
  `(lambda () (interactive)
     (,function ,@args)))

(defmacro .emacs-eproject-key (key command)
  (cons 'progn
        (loop for (k . p) in (list (cons key 4) (cons (upcase key) 1))
              collect
              `(global-set-key
                (kbd ,(format "C-x p %s" k))
                (.emacs-curry ,command ,p)))))

(.emacs-eproject-key "k" eproject-kill-project-buffers)
(.emacs-eproject-key "v" eproject-revisit-project)
(.emacs-eproject-key "b" eproject-ibuffer)
(.emacs-eproject-key "o" eproject-open-all-project-files)

#+end_src 

** PHP

#+begin_src emacs-lisp 

(setq php-manual-path "~/docs/php/php-chunked-xhtml/")

(setq php-completion-file "~/git/.emacs.d/php-completion-file")

#+end_src

** Drupal

#+begin_src emacs-lisp 

(require 'drupal-mode)

(setq auto-mode-alist
      (append
       '(
("\\.php$" . php-mode)
("\.\(module\|test\|install\|theme\)$" . drupal-mode)
("/drupal.*\.\(php\|inc\)$" . drupal-mode)
("\.info" . conf-mode)
         ) auto-mode-alist))

#+end_src          

** Etags

#+begin_src emacs-lisp 

(require 'etags-select)

;; list of file names of tags tables to search
(setq tags-table-list
      '(
"~/.emacs.d/TAGS"
        ))

#+end_src 

*** TODO Etags with IDO

#+begin_src emacs-lisp 

(defun ido-find-tag ()
  "Find a tag using ido"
  (interactive)
  (tags-completion-table)
  (let (tag-names)
    (mapc (lambda (x)
        (unless (integerp x)
          (push (prin1-to-string x t) tag-names)))
      tags-completion-table)
    (find-tag (ido-completing-read "Tag: " tag-names))))
 
(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))
 
(global-set-key [remap find-tag] 'ido-find-tag)
(global-set-key (kbd "H-.") 'ido-find-file-in-tag-files)

(defun pm/find-tags-file ()
  "Recursively searches each parent directory for a file named `TAGS'
   and returns the path to that file or nil if a tags file is not found.
   Returns nil if the buffer is not visiting a file.
   (from jds-find-tags-file in the emacs-wiki)"
  (labels ((find-tags-file-r
            (path)
            (let* ((parent (if path (file-name-directory path)
                             default-directory))
                   (possible-tags-file (concat parent "TAGS")))
              (cond
               ((file-exists-p possible-tags-file)
                (shell-command (concat "make -C" parent " TAGS"))
                (throw 'found-it possible-tags-file))
               ((string= "/TAGS" possible-tags-file)
                (error "no tags file found"))
               (t
                (find-tags-file-r (directory-file-name parent)))))))
    (catch 'found-it 
      (find-tags-file-r (buffer-file-name)))))

(defadvice find-tag (before pm/before-find-tag activate)
  (setq tags-file-name (pm/find-tags-file)))

#+end_src 

** Generic X (for Apache logs)

#+begin_src emacs-lisp 

(require 'generic-x)

(define-generic-mode 'htaccess-mode
  '(?#)
  '(;; core
    "AcceptPathInfo" "AccessFileName" "AddDefaultCharset" "AddOutputFilterByType"
    "AllowEncodedSlashes" "AllowOverride" "AuthName" "AuthType"
    "CGIMapExtension" "ContentDigest" "DefaultType" "DocumentRoot"
    "EnableMMAP" "EnableSendfile" "ErrorDocument" "ErrorLog"
    "FileETag" "ForceType" "HostnameLookups" "IdentityCheck"
    "Include" "KeepAlive" "KeepAliveTimeout" "LimitInternalRecursion"
    "LimitRequestBody" "LimitRequestFields" "LimitRequestFieldSize" "LimitRequestLine"
    "LimitXMLRequestBody" "LogLevel" "MaxKeepAliveRequests" "NameVirtualHost"
    "Options" "Require" "RLimitCPU" "RLimitMEM"
    "RLimitNPROC" "Satisfy" "ScriptInterpreterSource" "ServerAdmin"
    "ServerAlias" "ServerName" "ServerPath" "ServerRoot"
    "ServerSignature" "ServerTokens" "SetHandler" "SetInputFilter"
    "SetOutputFilter" "TimeOut" "UseCanonicalName"
    ;; .htaccess tutorial
    "AddHandler" "AuthUserFile" "AuthGroupFile"
    ;; mod_rewrite
    "RewriteBase" "RewriteCond" "RewriteEngine" "RewriteLock" "RewriteLog"
    "RewriteLogLevel" "RewriteMap" "RewriteOptions" "RewriteRule"
    ;; mod_alias
    "Alias" "AliasMatch" "Redirect" "RedirectMatch" "RedirectPermanent"
    "RedirectTemp" "ScriptAlias" "ScriptAliasMatch")
  '(("%{\\([A-Z_]+\\)}" 1 font-lock-variable-name-face)
    ("\\b[0-9][0-9][0-9]\\b" . font-lock-constant-face)
    ("\\[.*\\]" . font-lock-type-face))
  '(".htaccess\\'")
  nil
  "Generic mode for Apache .htaccess files.")

(add-to-list 'auto-mode-alist '("\\.htaccess\\'" . htaccess-mode))

#+end_src

** HTML MODE

#+begin_src emacs-lisp 

(defun my-html-mode-setup ()                                    
(auto-fill-mode -1))                                          
(add-hook 'html-mode-hook 'my-html-mode-setup)

(defun prettify-key-sequence (&optional omit-brackets)
    "Markup a key sequence for pretty display in HTML.
  If OMIT-BRACKETS is non-null then don't include the key sequence brackets."
    (interactive "P")
    (let* ((seq (thing-at-point 'symbol))
           (key-seq (elt seq 0))
           (beg (elt seq 1))
           (end (elt seq 2))
           (key-seq-map (list (key "Ctrl") (key "Meta") (key "Shift")
                              (key "Tab") (key "Alt") (key "Esc")
                              (key "Enter") (key "Return") (key "Backspace")
                              (key "Delete") (key "F10") (key "F11")
                              (key "F12") (key "F2") (key "F3")
                              (key "F4") (key "F5") (key "F6") (key "F7")
                              (key "F8") (key "F9")
                              ;; Disambiguate F1
                              '("\\`F1" . "@<span class=\"key\">F1@</span>")
                              '("\\([^>]\\)F1" .
                                "\\1@<span class=\"key\">F1@</span>")
                              ;; Symbol on key
                              '("Opt" . "@<span class=\"key\">⌥ Opt@</span>")
                              '("Cmd" . "@<span class=\"key\">⌘ Cmd@</span>")
                              ;; Combining rules
                              '("\+\\(.\\) \\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span>")
                              '("\+\\(.\\) \\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span> ")
                              '("\+\\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> ")
                              '("\+\\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span>"))))
      (mapc (lambda (m) (setq key-seq (replace-regexp-in-string
                                       (car m) (cdr m) key-seq t)))
            key-seq-map)
      ;; Single key
      (if (= (length key-seq) 1)
          (setq key-seq (concat "@<span class=\"key\">" key-seq "@</span>")))
      (delete-region beg end)
      (if omit-brackets
          (insert key-seq)
        (insert (concat "【" key-seq "】")))))
  
(defalias 'pks 'prettify-key-sequence)

(defun open-in-desktop ()
  "Open the current file in desktop.
Works in Microsoft Windows, Mac OS X, Linux."
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux") (shell-command "xdg-open ."))
   ) )

(global-set-key (kbd "<f7>") 'open-in-desktop)


#+end_src

** JavaScript

#+begin_src emacs-lisp 

(starter-kit-load "js")

#+end_src 

** PSVN (subversion)

#+begin_src emacs-lisp 

;;; psvn
(setq svn-status-prefix-key '[(hyper s)])
(require 'psvn)
(define-key svn-log-edit-mode-map [f6] 'svn-log-edit-svn-diff)

(defun xsteve-svn-log-edit-setup ()
  (setq ispell-local-dictionary "english")
  (auto-fill-mode 1))

(add-hook 'svn-log-edit-mode-hook 'xsteve-svn-log-edit-setup)

#+end_src 

** Yas

#+begin_src emacs-lisp 

(yas/load-directory "~/git/.emacs.d/snippets2")

(yas/load-directory "~/git/.emacs.d/snippets")

(yas/define-snippets 'text-mode
             '(("email" "me@google.com" "(user's email)" nil nil nil nil nil)
               ("phone" "777-777-7777" "(phone numer)" nil nil nil nil nil)
               ("thanks" "Thanks. Let me know if you have any questions or concerns" "(salutation)" nil nil nil nil nil)
               ("time" "`(current-time-string)`" "(current time)" nil nil nil nil nil))
             'nil)

(setq yas/indent-line nil)

#+end_src 

** ECB

#+begin_src emacs-lisp :tangle no

;;(require 'cedet)

(add-hook 'ecb-deactivate-hook                                                                                                                          
      '(lambda ()                                                                                                                                       
         (ecb-disable-advices 'ecb-winman-not-supported-function-advices t)))

#+end_src 

** Stack Exchange mode

#+begin_src emacs-lisp 

;; Integrate Emacs with Stack Exchange http://stackoverflow.com/a/10386560/789593                                                       
(add-to-list 'auto-mode-alist '("\\(stack\\(exchange\\|overflow\\)\\|superuser\\|askubuntu\\)\\.com\\.[a-z0-9]+\\.txt" . markdown-mode))

#+end_src 

** Glasses mode
#+begin_src emacs-lisp 

;; face to be put on capitals of an identifier looked through glasses
(setq glasses-face 'bold)

;; string to be displayed as a visual separator in unreadable identifiers
(setq glasses-separator "")

#+end_src 

** Quick Tip: Spaces instead of Tabs
[2011-10-14 Fri 14:06]

September 30th, 2007 by Ryan McGeary · 11 Comments

Tab characters used as indentation of source code is a pet peeve of
mine. Add this to your emacs initialization to make sure all
indentation uses spaces instead.

#+begin_src emacs-lisp 

;; I hate tabs!
;; let tabs indent 4 spaces
(setq-default indent-tabs-mode nil)
(setq default-tab-width 4)
(setq indent-line-function 'insert-tab)

#+end_src 

** Whitespace mode

As usual Prelude comes with a lot of whitespace handling magic
pre-enabled (similar to the last tweets). whitespace-mode ftw :-)

#+begin_src emacs-lisp 

(setq whitespace-action '(auto-cleanup)) (whitespace-mode) ;; automatically clean up bad whitespace

(setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab)) ;; only show bad whitespace

(setq whitespace-style '(face trailing lines-tail) whitespace-line-column 80) 

;; handy too: ;; highlight long lines tails

#+end_src 

** Semantic
#+begin_src emacs-lisp

(setq semantic-load-turn-useful-things-on t)

#+end_src 

* Unicode

#+begin_src emacs-lisp 
;; set unicode data file location. (used by what-cursor-position and describe-char)
(let ((x "~/git/.emacs.d/UnicodeData.txt"))
  (when (file-exists-p x)
    (setq describe-char-unicodedata-file x)))

(defun my-print-chars (&optional start end)
  (interactive "nstart: \nnend: ")
  (switch-to-buffer (get-buffer-create "*UNICODE*"))
  (erase-buffer)
  (let ( (i start) )
    (while (<= i end)
      (insert (format "%s: U+%04x, %s\n" (char-to-string i) i (get-char-code-property i 'name)))
      (setq i (1+ i))
      )))

#+end_src 

* Fun (random)
** life expectancy

(setq sacha/life-expectancy 90)
(setq sacha/birth-date '(05 12 1971))
(defun sacha/memento-mori ()
  (interactive)
  (let* ((expected (list
                    (elt sacha/birth-date 0)
                    (elt sacha/birth-date 1)
                    (+ (elt sacha/birth-date 2) sacha/life-expectancy)))
       (days-left (- (calendar-absolute-from-gregorian expected)
                     (time-to-days (current-time)))))
    (message "~ %d years or %d months or %d weeks left; make the most of them!"
             (/ days-left 365)
             (/ days-left 30)
             (/ days-left 7))))

#+end_src 


* Turn off debugging

#+begin_src emacs-lisp :tangle no

;; Something in el-get is setting debug-on-error to t.
;; Not cool.
(if debug-on-error
    (setq debug-on-error nil))

#+end_src 

* Footnotes

